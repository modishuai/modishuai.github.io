---

title: 链表
date: 2018-06-06 21:16:24

categories:
- 数据结构
tags:
- 数据结构
- 链表
- 双链表

---


| 存储类别   | 顺序存储结构                     | 单链表                          |
| ------ | -------------------------- | ---------------------------- |
| 存储分配方式 | 用一组地址连续的存储单元依次存储线性表中的各个元素。 | 采用链式存储结构，用一组任意的存储单元存放线性表的元素。 |
| 时间性能   | 查找O(1) 插入和删除O(n)           | 查找O(n) 插入和删除O(1)             |
| 空间性能   | 需要分配存储空间，大了浪费，小了容易发生溢出。    | 不需要分配存储空间，只要有就可以分配，元素个数不受限制  |

# 线性表
线性表是逻辑机构，顺序表和链表是存储结构。

![链表\线性表](链表\线性表.png)

顺序表使用数组实现，是一组地址连续的存储单元。

通过动态分配和动态扩展来指定数组大小。

## 顺序表和链表区别

1. 顺序表支持随机、顺序存取；链表只能顺序存取。

2. 顺序表逻辑上相邻的物理上也相邻；而链表则不一定，因为它是用链表指针来描述元素之间的关系。

3. 顺序表通过移动数据元素来完成插入和删除动作；链表是通过修改链表指针来完成插入和删除动作；

# 链表

链表是常见的数据结构，也是一种线性表。但是并不会按线性的链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。

链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行是动态生成。每个结点包含两部分：数据域和指针域（备注：单链表）。

相比与线性顺序结构，操作复杂。由于不按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。

## 链表的优势和劣势

链表结构可以客服数组链表需要预先知道数据大小的缺点。

插入或删除不需要移动大量元素，只需要修改指针即可。

如果要查找某个元素，只能从头开始遍历整个链表。

由于链表增加结点指针域，内存空间开销比较大。



## 链表分类

单链表、双链表、循环链表

# 单链表

![链表\单链表](链表\单链表.png)

## 头插法

将新节点插入到当前链表的表头，（头结点之后），插入的顺序与链表中的顺序相反，关键点就是记住旧的表头，生成一个新的放到旧表头前面，如图：

![链表\单链表-头插法](链表\单链表-头插法.png)





```java
public void headInsert(T item) {
    Node old = first;
    first = new Node();
    first.item = item;
    first.next = old;
    count++;
}
```

## 尾插法

增加一个尾指针，新节点插到链表的尾部，插入的顺序和链表的顺序一致，如图：

![链表\单链表-尾插法](链表\单链表-尾插法.png)

```java
public void tailInsert(T item) {
    Node old = last;
    last = new Node();
    last.item = item;
    last.next = null;
    if (isEmpty()) {
        first = last;
    } else {
        old.next = last;
    }
    count++;
}
```

节点的插入和删除，要点是先断后连，关键就是不要断链了，以插入为例（把s插入p和q之间），先断意思是先把p->q断了，变成s->q，后连，最后再把p和s连接起来。

## 插入节点

待插入节点为s，一般采用后插法，即先找到插入位置节点的前驱节点，然后插入，时间复杂度O(n)。

![链表\单链表-插入节点](链表\单链表-插入节点.png)

```java
p=getNodeByIndex(i-1);
s.next = p.next;
p.next = s;
```

还有一种方法是，直接插入到位置的后面（前插法），然后交换两个节点的值，插入的节点到了指定位置，时间复杂度O(1)：

```java
s.next = p.next;
p.next = s;
temp = p.item;    // 交换内容
p.item = s.item;
s.item = temp;
```

## 删除节点

待删除节点为q，也是先找到前驱节点，修改指针域即可，时间复杂度O(n)。

```java
P = getNodeByIndex(i-1);
q = p.next;
p.next = q.next;
q = null;
```

除节点也能直接删除其后继节点，然后将后继节点的内容赋给自己即可，时间复杂度为O(1)：

```java
q = p.next;
p.item = p.next.item;
p.next = q.next;
q = null;
```

# 双链表

双向链表也称为“双链表”，是链表的一种。它的每个数据结点中都有两个指针，分别指向直接前驱和直接后继。所以从双向链表中的任意一个结点开始，都可以很方便的访问它的前驱结点和后继结点，一般我们都构造双向循环链表。

双向链表是对单链表的一种改进，添加了一个指向前驱的节点。因为单链表只有一个后继节点，访问前驱结点只能从头开始便利（如删除、插入）。

![链表\双向链表](链表\双向链表.png)

## 插入节点

在p节点后插入s节点，先断后连，先把p和原后继节点的链条给断了，使后继节点只跟s节点有关：

![链表\双向链表-插入节点](链表\双向链表-插入节点.png)

```java
①s.next = p.next; // 先断了p的后继
②p.next.prior = s; // 在断了p后继的前驱
③s.prior = p; // 让s的前驱指向p
④p.next = s; // p的后继指向s，重新连接上链条，此步必须在①②之后
```

## 删除节点

删除节点p的后继节点q，也是先断后连，把q和其后继节点的关系，转让给p即可：

![链表\双向链表-删除节点](链表\双向链表-删除节点.png)

```java
①p.next = q.next; // 先断了q的后继
②q.next.prior = p; // 在断了q后继的前驱
```

删除节点q的前驱节点p，把p和去前驱节点的关系转让给q即可：

```java
①q = p.prior.next; // 把p前驱节点的后继改成q
②q.prior = p.prior; // 把q的前驱节点改成p的前驱节点
```

# 循环链表

循环 链表是与单 链表一样，是一种链式的 存储结构，所不同的是，循环 链表的最后一个结点的 指针是指向该循环 链表的第一个结点或者表头结点，从而构成一个环形的链。

循环 链表的运算与单 链表的运算基本一致。所不同的有以下几点：

1. 在建立一个循环 链表时，必须使其最后一个结点的 指针指向表头结点，而不是象单 链表那样置为NULL。此种情况还使用于在最后一个结点后插入一个新的结点。

2. 在判断是否到表尾时，是判断该结点链域的值是否是表头结点，当链域值等于表头 指针时，说明已到表尾。而非象单 链表那样判断链域值是否为NULL。

![链表\循环链表](链表\循环链表.png)



**参考文献**

https://www.cnblogs.com/wincai/p/5893475.html

https://www.cnblogs.com/ysocean/p/7928988.html#\_label1\_0

https://www.cnblogs.com/whgk/p/6589920.html
