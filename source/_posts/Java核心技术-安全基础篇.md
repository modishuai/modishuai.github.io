---
title: Java 核心技术-安全基础篇
date: 2019-04-07 18:00:00
categories:
- Java
tags:
- Java
- JMM
---
> 常见应用安全问题和处理方法，编码规范。

# GC 调优思路？

> 本节不打算深入，只记录几个关键点了解即可。
> 
> 关于 G1 调优指南参考[官方文档]([https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector-tuning.htm#JSGCT-GUID-4914A8D4-DE41-4250-B68E-816B58D4E278](https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector-tuning.htm#JSGCT-GUID-4914A8D4-DE41-4250-B68E-816B58D4E278)

GC 调优思路，首先要明确调优的目的是解决什么问题？从性能调优角度来看不外乎关心三个方面：吞吐量（throughput）内存占用（footprint）延时（latency），多数情况倾向一到两个方面的调优。除了这三个方面外还可以考虑GC 相关场景，比如，OOM 可能与GC 参数设置有关；应用启动速度等；

## 基本调优思路

- 理解应用需求解决什么样的问题。

- 掌握 JVM 和 GC 状态，通过 jstat 查看 GC 状态；追踪 GC 日志等。

- 选择的 GC 类型 是否符合应用特征。

- 通过分析确定具体调整参数或软硬件配置。

- 验证是否达到调优目标。

## G1 内部结构和主要机制

![Java核心技术-安全基础篇\G1 内部结构](Java核心技术-安全基础篇\G1 内部结构.png)

region 大小一致，数值在 1M 到 32M 字节之间的一个 2 的幂数值，JVM 尽量划分 2048 个区域，该数字是可以手动调整， G1 会根据堆带下自动进行调整。

G1 实现中，年代是个逻辑概念，体现在，一部分 region 作为 Eden，一部分作为 Survivor，除了意料之中的 Old region ，G1 会将超过 region 50% 大小的对象（在应用中通常是 byte 或 char 数组）归类为 Humongous 对象，并放置在相应的 region 中，算是老年代的一部分。因为复制大对象是很昂贵的操作，并不适合新生代GC 的复制算法。

### region 设计的副作用

region 大小和大对象很难保证一致，这会导致空间浪费。

从上图看出 Humongous 标记出来的颜色却没有 H 标志，是为了表示特别大的对象是可能超过占用一个 region ，并且 region 太小也不合适，会令你在分配大对象时更难找到连续空间。解决办法就是直接设置 region 的大小，参数如下：

`-XX:G1HeapRegionSize=<N, 例如 16>M`

### G1 采用复合算法

- 新生代，G1 采用并行的复制算法，同样会发生 Stop-The-World 的暂停。

- 老年代，多数情况采用并发标记-整理，而整理则和新生代 GC 时捎带进行，并且不是整体性的整理，而是增量进行。

# Java 内存模型中的 happen-before？

Java 内存模型（Java Memory model , JMM）

- 什么是 Java 内存模型，为什么需要它。

- Java 内存模型如何解决可见性等各种问题？类似 volatile 体现在具体用例中有什么效果？

## 平台的内存模型

在共享内存的多处理器体系架构中，每个处理器都有自己的缓存，并且定期与主内存进行协调。在不同的处理器架构中提供了不同级别的缓存一致性（Cache Coherence）,其中一部分提供最小的保证，即允许不同的处理器在任意时刻从同一个存储位置看到不同的值。操作系统、编译器以及运行时（甚至包括应用程序）需要弥合这种在硬件能力与线程安全需求之间的差异。

要想确保每个处理器都能在任意时刻知道其他处理器正在进行的工作，将需要非常大的开销。因此处理器会适当放宽存储一致性保证，以换取性能的提升。在架构定义的内存模型中将告诉应用程序可以从内存系统中获得怎样的保证，此外还定义了额外的特殊指令（称为内存屏障），当需要共享数据时，这些指令就能实现额外的村粗协调保证。为了使 Java 开发人员无需关心不同架构上内存模型之间的差异，Java 提供了自己的内存模型，并且 JVM 通过在适当的位置上插入 内存屏障 来屏蔽 JMM 与底层平台内存模型之间的差异。

## Java 内存模型简介

Java 内存模型是通过各种操作来定义的，包括对变量的读写操作，监视器的加锁和释放操作，以及线程的启动和合并操作。JMM 为程序中所有的操作定义了一个偏序关系，称为 Happens-Before。要想保证执行操作 B 的线程看到操作 A 的结果（无论 A 和 B 是否在同一个线程执行）那么 A 和 B 之间必须满足 Happens-Before 关系。如果操作之间缺乏 Happens-Before 关系，那么 JVM 可以对它们任意的重排序。

当一个变量被多个线程读取并且至少被一个线程写入时，如果在读操作和写操作之间没有依照 Happens-Before 来排序，就会产生数据竞争问题。在正确同步的程序中部存在数据竞争，并会表现出串行一致性，这意味着程序中的所有操作都会按照一种固定的和全局的顺序执行。

> 偏序关系 π 是集合上的一种关系，具有反对称性、自反和传递属性，但对于任意两个元素 x ，y 来说，并不需要一定满足 x π y 或 y π x 的关系。

Happens- Before 的规则如下：

- 程序顺序规则，如果程序中操作 A 在操作 B 之前，那么在线程中 A 操作将在 B 操作之前执行。

- 监视器锁规则，在监视器锁上的解锁操作必须在同一个监视器锁上的加锁操作之前执行。

- volatile 变量规则，对 volatile 变量的写入操作必须在对该变量的读操作之前执行。

- 线程启动规则，在线程上对 Thread.Start() 的调用必须在该线程中执行任何操作之前执行。

- 线程结束规则，线程中的任何操作都必须在其他线程检测到该线程已经结束之前执行，或者从 Thread.join 中成功返回，或者在调用 Thread.isAlive 时返回 false。

- 中断规则，当一个线程在另一个线程上调用 interrupt 时，必须在被中断线程检测到 interrupt 调用之前执行（通过 抛出 InterruptedException，或者调用 isInterrupted 和 interrupted）

- 终结器规则，对象的构造函数必须在启动该对象的终结器之前执行完成。

- 传递性，如果 A 操作在操作 B 之前执行，并且操作 B 在 操作 C 之前执行，那么操作 A 必须在操作 C 之前执行。

![Java核心技术-安全基础篇\JMM](Java核心技术-安全基础篇\JMM.png)

在编译器中生成的指令顺序，可以与源代码中的顺序不同，此外编译器还会把变量保存在寄存器而不是内存中；处理器可以采用乱序或并行等方式执行指令；缓存可能会改变将写入变量提交到主内存的次序；而且，保存在处理器本地缓存中的值，对其他处理器是不可见的。这些因素都会导致一个线程无法看到变量的最新值，并且会导致其他线程中的内存操作似乎在乱序执行。

JMM 内部的实现通常依赖于“内存屏障”，通过禁止重排序的方式，提供内存可见性保证，也就是 实现各种 Happens-Before 规则。

### 如何利用内存屏障实现 JMM 定义的可见性

对于一个 volatile 变量：

- 对该变量的写操作之后，编译器会插入一个写屏障。

- 对该变量的读操作之前，编译器会插入一个读屏障。

线程写入，写屏障会通过类是强制刷出处理器缓存的方式，让其他线程得到最新的值。

# Java 程序运行在Docker 容器环境有那些新问题？

> 目前工作中还没用过 Docker 部署过 Java 应用。
> 
> 本节只记录作为了解。
> 
> [Docker、VM 入门介绍]([https://medium.freecodecamp.org/a-beginner-friendly-introduction-to-containers-vms-and-docker-79a9e3e119b](https://medium.freecodecamp.org/a-beginner-friendly-introduction-to-containers-vms-and-docker-79a9e3e119b)

Docker 使用 CGroup 来管理 CPU、内存等资源限制，早起版本的 JDK 并不能识别这些这些限制，就会导致以下问题：

- 如果未配置合适的 JVM 堆和元数据区、直接内存等参数，Java 就有可能试图使用超过容器限制的内存，最终被容器 OOM kill，或者自身发生 OOM。

- 错误判断了可获取的 CPU 资源，例如，Docker 限制了 CPU 的核数，JVM 就可能设置不合适的 GC 并行线程数等。



![Java核心技术-安全基础篇\Docker](Java核心技术-安全基础篇\Docker.png)

上面的示意图，展示了 Docker 与虚拟机的区别。从技术角度，基于 namespace，Docker 为每个容器提供了单独的命名空间，对网络、PID、用户、IPC 通信、文件系统挂载点等实现了隔离。对于 CPU、内存、磁盘 IO 等计算资源，则是通过 CGroup 进行管理。

# Java 应用开发中的注入攻击？

## 常见的注入攻击

- SQL 注入攻击

- 操作系统命令注入，类似 Runtime.exec() 

- XML 注入攻击，XML 自身可以包含动态内容，例如：XPATH，使用不当，可能导致范文恶意内容。 

## 安全知识要点

- Java 应用安全，主要涉及那些安全机制。

- 什么是安全漏洞？

## Java API 和 工具构成 Java 安全基础

- 运行时安全机制，限制 Java 运行时的行为，不要做越权或者不靠谱的事情。

  - 类加载过程中，进行字节码验证，防止不符合规范的代码影响 JVM 运行或者再入其他恶意代码。

  - 利用 SecurityManager 机制和相关组件，限制代码运行时行为能力，可以定制 policy 文件和各种粒度的权限定义，限制代码的作用域和权限。

- Java 提供的安全框架 API，这是构建安全通信应用的基础。

  - 加密、解密 API

  - 授权、鉴权 API

  - 安全通信相关类库，比如基于 HTTPS 通信协议相关标准实现。

- JDK 集成的安全工具

  - keytool，管理安全场景中密钥、证书等，并且可以管理 Java 程序使用的 keystore 文件。

  - jarsinger，用于 jar 文件进行签名或者验证。

安全倾向于：“明显没有漏洞”，而不是“没有明显漏洞”·

### Man-In-The-Middle（MITM） 攻击

MITM 攻击可以理解为中间人攻击。

# 如何写出安全的 Java 代码？

> 推荐阅读《阿里巴巴 Java 开发手册》



Java 序列化特性，广泛使用在远程调用等方面，但也存在复杂的安全问题。针对序列化，通常建议：

- 敏感信息不要被序列化，编码中建议使用 Transient 关键字将其保护起来。

- 反序列化中，建议 readObject 中实现与对象构建过程相同的安全检查和数据检查。



## 开发和测试阶段

- 早期设计阶段，由安全专家组对新特性进行风险评估。

- 开发过程中，code review 阶段，应用 OpenJDK 自身定制的代码规范。

- 利用静态分析工具：[FindBugs]([http://findbugs.sourceforge.net/](http://findbugs.sourceforge.net/)、[Parfait]([https://labs.oracle.com/pls/apex/f?p=labs:49:::::P49_PROJECT_ID:13](https://labs.oracle.com/pls/apex/f?p=labs:49:::::P49_PROJECT_ID:13)等，帮组早期发现潜在安全风险。

- 在代码 check-in 等关键环节，利用 hook 机制去调用规则检查工具，保证不合规范代码不进入代码库。
