---
title: 散列表
date: 2018-06-03 21:07:53
categories:
- 数据结构
tags:
- 数据结构
---


# 哈希表

## 哈希表的定义

哈希表又称为“散列表”，主要是面向查找的一种存储结构。是根据（key value）键值而直接进行访问的数据结构。也就是说，通过把（key value）键值映射到表中的一个位置来访问记录，以加快查找的速度。这个映射函数称为“散列函数”，存放记录的数组称为“散列表”。

**散列过程**

存储：通过散列函数将 key 转换成一个整型数字，让后将该数字对数组长度进行取余，将取余的结果作为数组下标，将 value 存储在该下标的数组空间内。

查询：通过散列函数将 key 转换为对应的数组下标，并定位到该空间获取 value 就可以充分利用到数组的定位性能进行数据定位。

它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。这个源于Hash表设计的特殊性，**它采用了函数映射的思想将存储记录的位置与记录的关键字关联起来，从而能够更加快速的进行查找。**

Hash表采用一个映射函数 f : key —> address 将关键字映射到该记录在表中的存储位置，从而在想要查找该记录时，可以直接根据关键字和映射关系计算出该记录在表中的存储位置，通常情况下，这种映射关系称作为Hash函数，而通过Hash函数和关键字计算出来的存储位置(注意这里的存储位置只是表中的存储位置，并不是实际的物理地址)称作为Hash地址。

## 散列函数

对输入值运算，得到一个固定长度的散列值(Hash value);

不同的输入值可能对应同样的输出值。

以下函数都可以认为是一个散列函数：

- f(x) = x mod 16;

- f(x) = (x2 + 10) * x;

- f(x) = (x | 0×0000FFFF) XOR (x >> 16);

散列函数就是将任意长度的输入（又叫做预映射，pre-image）,通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是散列值的空间小于输入空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。

**数组的特点是：寻址容易，插入和删除困难；**

**链表的特点是：寻址困难，插入和删除容易；**

那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？

答案是肯定的，这就是我们要提起的哈希表，哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法——拉链法，我们可以理解为“链表的数组”，如图：

![散列表\拉链法](散列表\拉链法.png)

左边是个数组，数组的下标指向一个链表的头。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再冲链表中找到这个元素。

## hash 函数的设计

一般的线性表，树中，记录在结构中的相对位置是随机的，即和记录的关键字之间不存在确定的关系，因此，在结构中查找记录时需进行一系列和关键字的比较。这一类查找方法建立在“比较“的基础上，查找的效率依赖于查找过程中所进行的比较次数。

理想的情况是能直接找到需要的记录，因此必须在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应。

哈希表最常见的例子是以学生学号为关键字的成绩表，１号学生的记录位置在第一条，１０号学生的记录位置在第１０条...

如果我们以学生姓名为关键字，如何建立查找表，使得根据姓名可以直接找到相应记录呢？

![散列表\0](散列表\0.png)

用上述得到的数值作为对应记录在表中的位置，得到下表：

![散列表\1](散列表\1.png)

上面这张表即哈希表。

如果将来要查李秋梅的成绩，可以用上述方法求出该记录所在位置：

李秋梅:lqm 12+17+13=42 取表中第42条记录即可。

问题：如果两个同学分别叫 刘丽 刘兰 该如何处理这两条记录？

这个问题是哈希表不可避免的，即冲突现象：对不同的关键字可能得到同一哈希地址。

## 哈希表的构造方法

1. 直接定址法

   例如：有一个从1到100岁的人口数字统计表，其中，年龄作为关键字，哈希函数取关键字自身。

   但这种方法效率不高,时间复杂度是O(1),空间复杂度是O(n),n是关键字的个数。

![散列表\直接定址法](散列表\直接定址法.png)

2. 平法取中法

   取关键字平方后的中间几位作为哈希地址。假如有以下关键字序列{421，423，436}，平方之后的结果为{177241，178929，190096}，那么可以取{72，89，00}作为Hash地址。

3. 折叠法

   将关键字分割成位数相同的几部分（最后一部分可以不同），然后去这几部分的叠加和（舍去进位）作为哈希地址。例如：每一种西文图书都有一个国际标准图书编号，它是一个10位的十进制数字，若要以它作关键字建立一个哈希表，当馆藏书种类不到10,000时，可采用此法构造一个四位数的哈希函数。如果一本书的编号为0-442-20586-4,则：

   ![散列表\折叠法](散列表\折叠法.png)

4. 数字分析法

   有学生的生日数据如下：

   年.月.日

   75.10.03

   75.11.23

   76.03.02

   76.07.12

   75.04.21

   76.02.15

   经分析,第一位，第二位，第三位重复的可能性大，取这三位造成冲突的机会增加，所以尽量不取前三位，取后三位比较好。

5. 除留余数法

   取关键字被某个不大于哈希表表长m的数p除后所得余数为哈希地址。

   H(key)=key MOD p(p<=m)

6. 随机数法

   选择一个随机函数，取关键字的随机函数作为它的哈希地址（通常用于关键字长度不等式的场景）

   H(key)=random(key)， 其中random 为随机函数。

## 哈希冲突处理

在理想的情况下，每一个关键字，通过散列函数计算出来的地址都是不一样的，可现实中，这只是一个理想。

我们时常会碰到两个关键字key1 ≠ key2，但是却有f (key1) = f (key2)，这种现象我们称为冲突（collision)，并把key1和 key2称为这个散列函数的同义词（synonym）。出现了冲突当然非常糟糕，那将造成数据査找错误。尽管我们可以通过精心设计的散列函数让冲突尽可能的少，但是不能完全避免。

![散列表\example1](散列表\example1.png)

如果两个同学分别叫刘丽刘兰，当加入刘兰时，地址24发生了冲突，我们可以以某种规律使用其它的存储位置，如果选择的一个其它位置仍有冲突，则再选下一个，直到找到没有冲突的位置。选择其它位置的方法有：

1. 开发定址法

   开放定址法的基本思想就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录插入。

   公式：Hi=(H(key)+di) MOD m i=1,2,...,k(k<=m-1)

   公式：fi(key) = (f(key)+di) MOD m (di=1,2,3,......,m-1)

   其中m为表长，di为增量序列，如果di值可能为1,2,3,...m-1，称线性探测再散列。

   如果di取值可能为1,-1,2,-2,4,-4,9,-9,16,-16,...k\*k,-k\*k(k<=m/2)称二次探测再散列。

   如果di取值可能为伪随机数列。称伪随机探测再散列。

   例一：在长度为11的哈希表中已填有关键字分别为17,60,29的记录，现有第四个记录，其关键字为38，由哈希函数得到地址为5，若用线性探测再散列，如下：

   ![散列表\开放定址法](散列表\开放定址法.png)

   例二：比如说，我们的关键字集合为{12,67,56,16,25,37,22,29,15,47,48,34},表长为12。 我们用散列函数f(key) = key mod 12。

   **线性探测法**

   当计算前S个数{12,67,56,16,25}时，都是没有冲突的散列地址，直接存入：

   ![散列表\线性探测法](散列表\线性探测法.png)

   计算key = 37时，发现f(37) = 1，此时就与25所在的位置冲突

   于是我们应用上面的公式f(37) = (f(37)+1) mod 12 = 2。于是将37存入下标为2的位置。

   ![散列表\线性探测法2](散列表\线性探测法2.png)

   接下来22,29,15,47都没有冲突，正常的存入：

   ![散列表\线性探测法3](散列表\线性探测法3.png)

   我们把这种解决冲突的开放定址法称为线性探测法。

   从这个例子我们也看到，我们在解决冲突的时候，还会碰到如48和37这种本来都不是同义词却需要争夺一个地址的情况，我们称这种现象为堆积。很显然，堆积的出现，使得我们需要不断处理冲突，无论是存入还是査找效率都会大大降低。

   **二次探测法**

   考虑深一步，如果发生这样的情况，当最后一个key=34，f(key)=10,与22所在的位置冲突，可是22后面没有空位置了，反而它的前面有一个空位置，尽管可以 不断地求余数后得到结果，但效率很差。

   因此我们可以改进di = 12, -12, 22, -22,……, q2, -q2 (q <= m/2),这样就等于是可以双向寻找到可能的空位置。

   对于34来说，我 们取di即可找到空位置了。另外增加平方运算的目的是为了不让关键字都聚集在 某一块区域。我们称这种方法为二次探测法。

   fi(key) = (f(key)+di) MOD m (di = 12, -12, 22, -22,……, q2, -q2, q <= m/2)

   **随机探测法**

   还有一种方法是，在冲突时，对于位移量 di 采用随机函数计算得到，我们称之为随机探测法。

   一定会有人问，既然是随机，那么查找的时候不也随机生成办吗？如何可以获得相同的地址呢？这是个问题。这里的随机其实是伪随机数。

   伪随机数是说，如果我们设置随机种子相同，则不断调用随机函数可以生成不会重复的数列，我们在査找时，用同样的随机种子，它每次得到的数列是相同的，相同的 di 当然可以得到相同的散列地址。

   fi(key) = (f(key)+di) MOD m (di是一个随机数列)

   总之，开放定址法只要在散列表未填满时，总是能找到不发生冲突的地址，是我们常用的解决冲突的办法。

   2. 再哈希法

      当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。

   3. 链地址法（拉链法）

      散列冲突处理的开放定址法，它的思路就是一旦发生了冲突，就去寻找下一个空的散列地址。那么，有冲突就非要换地方呢，我们直接就在原地处理行不行呢？这就是链地址法。

      将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。

      对于关键字集合{12,67,56,16,25,37, 22,29,15,47,48,34}，我们用前面同样的12为除数，进行除留余数法：

      ![散列表\拉链法1](散列表\拉链法1.png)

      Tips：此时，已经不存在什么冲突换址的问题，无论有多少个冲突，都只是在当前位置给单链表增加结点的问题。很不错的解决思路吧？

      拉链法解决冲突的做法是：将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数组T\[0..m-1\]。凡是散列地址为i的结点，均插入到以T\[i\]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于 1，但一般均取α≤1。

      **拉链发的优缺点**

      与开放定址法相比，拉链法有如下几个优点：

      - 拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；

      - 由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；

      - 开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；

      - 在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元（即开放地址）都是查找失败的条件。因此在用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。

      拉链法的缺点：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。

      Tips:链地址法的优势是对于可能会造成很多冲突的散列函数来说，提供了绝不会出现找不到地址的保障。当然，这也就带来了査找时需要遍历单链表的性能损耗，不过性能损耗在很多场合下也不是什么大问题。

   4. 建立一个公共溢出区

      假设哈希函数的值域为\[0,m-1\],则设向量HashTable\[0..m-1\]为基本表，另外设立存储空间向量OverTable\[0..v\]用以存储发生冲突的记录。

   ## 补充

   哈希表是基于数组的，数组创建后难于扩展某些哈希表被基本填满时，性能下降的严重，所以程序必须要清楚表中将要存储的数据（或者准备好定期将数据转移到更大的哈希表中，很耗时。）

   哈希表的数组是定长的，如果太大，则浪费，如果太小，体现不出效率。合适的数组大小是哈希表的性能的关键。哈希表的尺寸最好是一个质数。当然，根据不同的数据量，会有不同的哈希表的大小。对于数据量时多时少的应用，最好的设计是使用动态可变尺寸的哈希表，那么如果你发现哈希表尺寸太小了，比如其中的元素是哈希表尺寸的2倍时，我们就需要扩大哈希表尺寸，一般是扩大一倍。

   参考文献：

   http://blog.jobbole.com/49229/

   http://www.cnblogs.com/jiewei915/archive/2010/08/09/1796042.html

   http://www.jpk.pku.edu.cn/pkujpk/course/sjjg/chapter9/03/03_02.html

   http://www.cnblogs.com/dolphin0520/archive/2012/09/28/2700000.html

   https://www.cnblogs.com/youngerchina/p/5624453.html

   http://www.nowamagic.net/academy/detail/3008050
