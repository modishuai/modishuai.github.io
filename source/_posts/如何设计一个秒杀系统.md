---
title: 如何设计一个秒杀系统
date: 2019-03-3 
categories: 
- 架构
tags:
- 秒杀
---

> 专栏《如何设计一个秒杀系统-许令波》学习笔记
> 
> 秒杀特点：稳、准、快
> 
> 重点围绕：并发读 和 并发写；
> 
> 并发读核心优化理念：尽量减少用户到服务端来“读”数据；并发写的原则类似，要求将数据层独立出来，特殊处理。另外还需要兜底方案。

# 01|设计秒杀系统应注意的5个架构原则？

**数据要尽量少** 

用户请求数据尽量少，请求和响应都需要时间，服务器在写网络通常要做压缩和编码很好 CPU，所以尽量让秒杀界面简洁实用。

**请求数量尽量少**

主要包括图片、JavaScript、CSS等，脚本合并成一个文件，在 URL 中用逗号隔开（服务端需要组件来解析该URL，然后将这些动态文件合并起来一并返回。）

**路径要尽量短**

所谓“路径”，就是用户发出请求到返回数据这个过程中，需求经过的中间的节点数。（不要转来转去）

**依赖要尽量少**

所谓依赖，指的是要完成一次用户请求必须依赖的系统或者服务，这里的依赖指的是强依赖。

例子：秒杀商品页面依赖商品详情信息、用户信息、优惠卷诸如此类的；

**不要有单点**

单点意味着没有备份，分布式系统重要的原则就是消除单点。

# 02|如何做好动静分离？有哪些方案可选？

动静分离，区分出秒杀网页中的动态数据（每个人看到都不一样）和静态数据（每个人看到都一样）。

对静态数据做缓存处理，自然就能提高访问效率。

## 静态数据如何做缓存？

* **将静态数据缓存到离用户最近的地方**。常见有三种：服务端Cache、浏览器、CDN。

* **静态化改造就是直接缓存 HTTP 连接。**静态化改造是直接缓存 HTTP 连接而不是仅仅缓存数据，如下图所示，Web 代理服务器根据请求 URL，直接取出对应的 HTTP 响应头和响应体然后直接返回，这个响应过程简单得连 HTTP 协议都不用重新组装，甚至连 HTTP 请求头也不需要解析。

![如何设计一个秒杀系统\缓存HTTP连接](如何设计一个秒杀系统\缓存HTTP连接.jpg)

* **谁来做静态数据缓存。**直接在 Web 服务器层上做（Nginx、Apache、Varnish）更擅长处理大并发的静态文件请求。

## 如何做动静分离改造？

- URL 唯一化。商品详情系统天然地就可以做到 URL 唯一化，比如每个商品都由 ID 来标识，那么 http://item.xxx.com/item.htm?id=xxxx 就可以作为唯一的 URL 标识。为啥要 URL 唯一呢？前面说了我们是要缓存整个 HTTP 连接，那么以什么作为 Key 呢？就以 URL 作为缓存的 Key，例如以 id=xxx 这个格式进行区分。

- 分离浏览者相关的因素，浏览者相关的因素包括是否已登录，以及登录身份等，这些相关因素我们可以单独拆分出来，通过动态请求来获取。

- 分离时间因素。服务端输出的时间也通过动态请求获取。

- 异步化地域因素。详情页面上与地域相关的因素做成异步方式获取，当然你也可以通过动态请求方式获取，只是这里通过异步获取更合适。

- 去掉 Cookie。服务端输出的页面包含的 Cookie 可以通过代码软件来删除，如 Web 服务器 Varnish 可以通过 unset req.http.cookie 命令去掉 Cookie。注意，这里说的去掉 Cookie 并不是用户端收到的页面就不含 Cookie 了，而是说，在缓存的静态数据中不含有 Cookie。

> 分离出动态内容之后，如何组织这些内容页就变得非常关键了。这里我要提醒你一点，因为这其中很多动态内容都会被页面中的其他模块用到，如判断该用户是否已登录、用户 ID 是否匹配等，所以这个时候我们应该将这些信息 JSON 化（用 JSON 格式组织这些数据），以方便前端获取。

**动态内容处理方案：**

1. [ESI](https://baike.baidu.com/item/ESI/42448?fr=aladdin)（Edge Side Includes）即在 Web 代理服务器上做动态内容请求，将请求内容插入到静态页面中；

2. CSI（Client Side Include）即单独发起一个异步 JavaScript 请求，向服务端获取动态内容。

# 03|二八原则：有正对性地处理好系统的“热点数据”

用户在购物网站执行的一系列操作都可以抽象为“读请求”和“写请求”，而写请求瓶颈一般都在存储层。

热点数据又分为：静态热点数据 和 动态热点数据。

## 如何发现热点数据

**发现静态热点数据**，有两种方式，其一，是通过卖家报名，通过运营系统把参加活动商品标识出来，然后通过后台系统对热点商品进行预热处理，比如提前缓存。其二，利用技术手段统计出买家访问的商品进行大数据统计分析，统计出 TOP N的商品，就可以认为是热点商品。

**发现动态热点数据**，前面两种方式实时性太差。想办法构建几个动态热点发现系统。

> 构建一个异步的系统，它可以收集交易链路上各个环节中的中间件产品的热点 Key，如 Nginx、缓存、RPC 服务框架等这些中间件（一些中间件产品本身已经有热点统计模块）。
> 
> 建立一个热点上报和可以按照需求订阅的热点服务的下发规范，主要目的是通过交易链路上各个系统（包括详情、购物车、交易、优惠、库存、物流等）访问的时间差，把上游已经发现的热点透传给下游系统，提前做好保护。比如，对于大促高峰期，详情系统是最早知道的，在统一接入层上 Nginx 模块统计的热点 URL。
> 
> 将上游系统收集的热点数据发送到热点服务台，然后下游系统（如交易系统）就会知道哪些商品会被频繁调用，然后做热点保护。
> 
> 这里我给出了一个图，其中用户访问商品时经过的路径有很多，我们主要是依赖前面的导购页面（包括首页、搜索页面、商品详情、购物车等）提前识别哪些商品的访问量高，通过这些系统中的中间件来收集热点数据，并记录到日志中。
> 
> ![img\构建动态热点发现系统](如何设计一个秒杀系统\\构建动态热点发现系统.jpg)
> 
> ## 处理热点数据
> 
> 处理热点数据思路：一优化，二限制，三隔离
> 
> 优化：指的是将热点数据放在缓存中。
> 
> 限制：对访问商品的ID 做一致性 Hash，然后根据 Hash 做分桶，每个分桶设置一个处理队列，吧热点商品限制在请求队列里，防止因某些热点商品占用太多的服务器资源，从而使其他请求始终得到服务器的处理资源。
> 
> 隔离：隔离的原则是不要让 1% 的请求影响到其他 99%，对这 1% 做针对性优化。

# 04|流量削峰这事应该怎么做？

## 为什么要削峰？

这个问题就好比交通限行限号是一个道理。

对于互联网系统引入削峰手段第，一、可以保证服务器处理变得更加平稳。二、可以节省服务器的资源成本。本质上来讲削峰更多的 是延缓用户发出的请求，以便减少或过滤掉一些无效请求，遵循“**请求数量尽量少**”的原则。

## 削峰的操作思路？

无损方案：排队、答题、分层过滤（无损，即不会损失用户发出的请求）

有损方案：限流、机器负载保护等一些强制措施。

### 排队

排队的方式：

一、利用线程池加锁等待。

二、先进先出、先进后出等常用内存排序算法。

三、把请求序列化到文件中，然后在顺序地读文件来恢复请求。

四、利用消息队列方式。

最通用的解决方案，用消息队列缓冲流量的方案。这就好比在河道中修一座大坝留几个出口来泄洪，但洪水持续过大终究还是会被压垮的。把同步的直接调用转换成异步的间接推送，中间通过一个队列在一端承接瞬时的洪峰流量，在另一端平滑地将消息推送出去。

![img\削峰-消息队列缓冲流量](如何设计一个秒杀系统\\削峰-消息队列缓冲流量.jpg)

### 答题

答题的两个目的：一、防止秒杀器作弊。二、延缓请求，起到对请求流量削峰的作用。

秒杀答题思路如下图：

![img\秒杀答题思路](如何设计一个秒杀系统\\秒杀答题思路.jpg)

秒杀答题的主要逻辑：

1. 题库生成模块。生成一个个问题和答案

2. 题库推送模块。将题目提前推送给详情系统和交易系统。推送主要是保证用户请求的题目是唯一的。

3. 题库图片生成模块。网络拥挤是，应该把图片提前推送至 CDN 并进行预热处理。

问题和答案用如下的 key 进行 MD5 加密：

问题 key：userId + itemId + questionId + time  + PK

答案 key：userId + itemId + answer + PK

答题的验证逻辑：

![img\答题的验证逻辑](如何设计一个秒杀系统\\答题的验证逻辑.jpg)

注意：这里的逻辑，除了验证问题答案外还包括用户身份验证。

除了答题的正确性验证，还可以对提交答案时间做限制。

### 分层过滤

分层过滤的核心思想：**像漏斗一样在不同层次过滤掉无效请求，进入末端的请求才是有效的**。

分层过滤的目的是过滤掉一些无效请求。

![img\分层过滤](如何设计一个秒杀系统\分层过滤.jpg)

- CDN 层：拦截大部分数据的读取。

- 前台系统层的数据（包括强一致性的数据）尽量走 Cache ，过滤一些无效请求。

- 后台系统层：主要执行数据的二次校验，对系统做好保护和限流，减少数据量和请求。

- DB 层：完成数据的强一致性校验。

### 分层过滤的基本原则

1. 将动态请求的读数据缓存（Cache）在 Web 端，过滤掉无效的数据读。

2. 对读数据不做强一致性校验，减少因为一致性校验产生瓶颈的问题。

3. 对写数据进行基于时间的合理分片，过滤掉过期的失效请求。

4. 对写请求做限流保护，将超出系统承载能力的请求过滤掉。

5. 对写数据进行强一致性校验，只保留最后有效的数据。

# 05|影响性能的因素？该如何提高系统的性能？

> IOPS （Input/Output Operations Per Second，每秒读写操作次数 ）
> 
> QPS （Query Per Second，每秒请求数）
> 
> RT（Response Time，响应时间）

QPS 一般用来衡量一个系统服务端性能，还有一个影响和 QPS 息息相关， RT 可理解为服务器处理响应耗时。

正常情况下 RT（响应时间） 越短，一秒处理请求数（QPS）自然就越多，这在单线程处理的情况下看起来是线性的关系，即我们自要把每个请求的响应时间降到最低，那么性能就会最高。

## 响应时间对 QPS 的影响

响应时间一般是由 CPU 执行时间和线程等待时间（RPC、IO等待、Sleep、Wait等）组成，即服务器在处理每一个请求时，一部分事 CPU 本身在做运算，还有一部分是在等待。

真正对性能有影响的是 CPU 的执行时间，应致力于减少 CPU 的执行时间。

## 线程数对 QPS 的影响

线程越多的系统，线程的切换成本越高，而且线程也会消耗一定内存。

线程场景默认配置，**线程数= 2 * CPU 核数 + 1**，除此配置外，最佳实践得来公式

`线程数 = [(线程等待时间 + 线程 CPU 时间)  / 线程CPU时间] * CPU 数量`

最好是通过性能测试来发现最佳的线程数。

要想显著的提升性能我们要减少 CPU 的执行时间，除此之外还需要设置一个合理的并发线程数。

## 如何发现瓶颈？

服务器出现瓶颈的地方：CPU、内存、磁盘、网络。

万物相生相克，缓存系统——内存；存储型系统——I/O

### 有那些工具可发现 CPU 瓶颈呢？

JProfiler 和 Yourkit，就可以列出整个请求中每个函数的 CPU 执行时间，还可以发现那个函数消耗的 CPU 时间最多。

对于海量请求涌过来，页面又大，网络也可能出现瓶颈。

### 如何判断 CPU 是不是瓶颈呢？

看 QPS 达到极限时，服务器 CPU 使用率是否超过 95% ，如果草果，那表示 CPU 还有提升空间，要么有锁限制，要么有本地 I/O 等待发生。

## 如何优化系统？

1、减少编码

 Java 的编码运行比较慢，这是 Java 的一大硬伤。在很多场景下，只要涉及字符串的操作（如输入输出操作、I/O 操作）都比较耗 CPU 资源，不管它是磁盘 I/O 还是网络 I/O，因为都需要将字符转换成字节，而这个转换必须编码。

每个字符的编码都需要查表，而这种查表的操作非常耗资源，所以减少字符到字节或者相反的转换、减少字符编码会非常有成效。减少编码就可以大大提升性能。

那么如何才能减少编码呢？例如，网页输出是可以直接进行流输出的，即用 resp.getOutputStream() 函数写数据，把一些静态的数据提前转化成字节，等到真正往外写的时候再直接用 OutputStream() 函数写，就可以减少静态数据的编码转换。

序列化大部分是在 RPC 中发生的，因此避免或者减少 RPC 就可以减少序列化，当然当前的序列化协议也已经做了很多优化来提升性能。有一种新的方案，就是可以将多个关联性比较强的应用进行“合并部署”，而减少不同应用之间的 RPC 也可以减少序列化的消耗。

2、减少序列化

序列化也是 Java 性能的一大天敌，减少 Java 中的序列化操作也能大大提升性能。又因为序列化往往是和编码同时发生的，所以减少序列化也就减少了编码。

3、Java极致优化

对Web 系统做静态化改造，让大部分请求和数据直接在 Nginx 服务器或则 Web代理服务器（Varnish、Squid）上直接返回，这样做的好处是减少数据的序列化和反序列化，让 Java 层处理少量的动态数据请求。

- 直接使用 Servlet 处理请求。避免使用传统的 MVC 框架，这样可以绕过一大堆复杂且用处不大的处理逻辑，节省 1ms 时间（具体取决于你对 MVC 框架的依赖程度）。

- 直接输出流数据。使用 resp.getOutputStream() 而不是 resp.getWriter() 函数，可以省掉一些不变字符数据的编码，从而提升性能；数据输出时推荐使用 JSON 而不是模板引擎（一般都是解释执行）来输出页面。

4、并发读优化

答案是采用应用层的 LocalCache，即在秒杀系统的单机上缓存商品相关的数据。

# 06|秒杀系统"减库存"设计的核心逻辑？

## 减库存有那几种方式？

- 下单减库存，即买家下单后，就去商品总库存中减去购买数量。一定不会出现超卖现象，但是买家不一定付款。

- 付款减库存，即买家下单付款后，才去商品总库存中减去购买数量，否则将库存一直保留给其他买家。如果并发很高，可能会导致买家付不了款，因为商品被其他买家买走了，又会导致库存超卖。

- 预扣库存，常见的减库存方式，买家下单后，库存将保持一段时间，超过时间，自动释放库存；释放后其他买家可继续购买。在买家付款前，系统会校验订单库存是否还有保留，如果没有保留，则再次尝试预扣；如果库存不足（预扣失败），则不允许继续付款；如果预扣成功，则完成付款并实际地减去库存。

### 如何避免恶意买家操作？

打标，也就是要识别出那些是恶意买家，给某些类目设置最大购买数量、以及重复下单不付款的操作次数进行限制。

**“超卖”**现象仍旧会发生，只能通过补货；或者买家付款时提示库存不足。

### 秒杀场景如何减库存？

秒杀，即秒到即赚到，应该采用“**下单减库存**”方案。

“**下单减库存**”主要解决的问题是，保证大并发请求时库存数据不能为负数，常见的解决方案如下：

一、应用程序中通过事务来判断，即保证减库存后不能为负数，否则就回滚事务；

二、直接将数据库的字段数据为无符号整数，只要减库存字段值小于零时运行SQL 语句来报错；

三、利用 CASE WHEN 判断语句。

```sql
UPDATE item SET inventory = CASE WHEN inventory >= xxx THEN 
inventory - xxx ELSE inventory END
```

## 秒杀库存的极致优化

提升读性能：库存，作为关键数据和热点数据，秒杀场景并不需要对库存有精确性的一致性读，把库存数据放到缓存（Cache）；

解决打并发读问题：采用 LocalCahe（即秒杀系统的单机上缓存商品相关数据）和对数据进行分层过滤方式。无论如何也无法避免大并发减库存操作。

### 如何在缓存中减库存和数据库中减库存？

> 如果你的秒杀商品的减库存逻辑非常单一，比如没有复杂的 SKU 库存和总库存这种联动关系的话，我觉得完全可以放在缓存中减库存。但是如果有比较复杂的减库存逻辑，或者需要使用事务，你还是必须在数据库中完成减库存。
> 
> 由于 MySQL 存储数据的特点，同一数据在数据库里肯定是一行存储（MySQL），因此会有大量线程来竞争 InnoDB 行锁，而并发度越高时等待线程会越多，TPS（Transaction Per Second，即每秒处理的消息数）会下降，响应时间（RT）会上升，数据库的吞吐量就会严重受影响。
> 
> 这就可能引发一个问题，就是单个热点商品会影响整个数据库的性能， 导致 0.01% 的商品影响 99.99% 的商品的售卖，这是我们不愿意看到的情况。一个解决思路是遵循前面介绍的原则进行隔离，把热点商品放到单独的热点库中。但是这无疑会带来维护上的麻烦，比如要做热点数据的动态迁移以及单独的数据库等。
> 
> 而分离热点商品到单独的数据库还是没有解决并发锁的问题，我们应该怎么办呢？要解决并发锁的问题，有两种办法：
> 
> - 应用层做排队，按照商品维度设置队列顺序，能减少同一台机器对数据同一行进行操作的并发度，同时也能控制单个商品占用数据库连接数量，防止热点商品占用太多的数据库连接。
> 
> - 数据库分层做排队，应用层只能做到单机的排队，但是应用机器数本身很多，这种排队方式控制并发的能力仍然有限，所以如果能在数据库层做全局排队是最理想的。阿里的数据库团队开发了针对这种 MySQL 的 InnoDB 层上的补丁程序（patch），可以在数据库层上对单行记录做到并发排队。

# 07|准备Plan B：如何设计兜底方案？

任何一个系统都需要“反脆弱”。

## 高可用系统建设

![img\高可用系统全生命周期](如何设计一个秒杀系统\高可用系统全生命周期.jpg)

> - 架构阶段：架构阶段主要考虑系统的可扩展性和容错性，要避免系统出现单点问题。例如多机房单元化部署，即使某个城市的某个机房出现整体故障，仍然不会影响整体网站的运转。
> 
> - 编码阶段：编码最重要的是保证代码的健壮性，例如涉及远程调用问题时，要设置合理的超时退出机制，防止被其他系统拖垮，也要对调用的返回结果集有预期，防止返回的结果超出程序处理范围，最常见的做法就是对错误异常进行捕获，对无法预料的错误要有默认处理结果。
> 
> - 测试阶段：测试主要是保证测试用例的覆盖度，保证最坏情况发生时，我们也有相应的处理流程。
> 
> - 发布阶段：发布时也有一些地方需要注意，因为发布时最容易出现错误，因此要有紧急的回滚机制。
> 
> - 运行阶段：运行时是系统的常态，系统大部分时间都会处于运行态，运行态最重要的是对系统的监控要准确及时，发现问题能够准确报警并且报警数据要准确详细，以便于排查问题。
> 
> - 故障发生：故障发生时首先最重要的就是及时止损，例如由于程序问题导致商品价格错误，那就要及时下架商品或者关闭购买链接，防止造成重大资产损失。然后就是要能够及时恢复服务，并定位原因解决问题。

### 如何保障系统稳定运行

那么针对秒杀系统，我们重点介绍在遇到大流量时，应该从哪些方面来保障系统的稳定运行，所以更多的是看如何针对运行阶段进行处理，这就引出了接下来的内容：降级、限流和拒绝服务。

#### 降级

当系统的容量达到一定程度时，限制或者关闭系统的某些非核心功能，从而把有限的资源保留给更核心的业务。

它是一个有目的、有计划的执行过程，所以对降级我们一般需要有一套预案来配合执行。如果我们把它系统化，就可以通过预案系统和开关系统来实现降级。

![img\开关系统](如何设计一个秒杀系统\开关系统.jpg)

#### 限流

限流就是当系统容量达到瓶颈时，我们需要通过限制一部分流量来保护系统，并做到既可以人工执行开关，也支持自动化保护的措施。

- 客户端限流，好处可以限制请求的发出，通过减少发出无用请求从而减少对系统的消耗。缺点就是当客户端比较分散时，没法设置合理的限流阈值：如果阈值设的太小，会导致服务端没有达到瓶颈时客户端已经被限制；而如果设的太大，则起不到限制的作用。

- 服务端限流：好处是可以根据服务端的性能设置合理的阈值，而缺点就是被限制的请求都是无效的请求，处理这些无效的请求本身也会消耗服务器资源。

![img\限流](如何设计一个秒杀系统\限流.jpg)

#### 拒绝服务

实在招架不住，也就只能拒绝服务了。

当系统负载达到一定阈值时，例如 CPU 使用率达到 90% 或者系统 load 值达到 2*CPU 核数时，系统直接拒绝所有请求，这种方式是最暴力但也最有效的系统保护方式。例如秒杀系统，我们在如下几个环节设计过载保护：

> 在最前端的 Nginx 上设置过载保护，当机器负载达到某个值时直接拒绝 HTTP 请求并返回 503 错误码，在 Java 层同样也可以设计过载保护。
