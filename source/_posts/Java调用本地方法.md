---

title: Java调用本地方法
date: 2018-06-07 19:43:08
categories:
- Java
tags:
- Java

---

# JNI （Java Native Interface)

JNI（Java Native Interface） Java 本地接口,实现 Java 和本地已编译代码之间的双向交互。

JNI 是 Java 平台的一部分可以，它允许 Java 代码和其他编程语言编写的代码进行交互（最初是为了本地已编译语言比如C和C++而设计）但并不妨碍使用其他编程，只要调用约定支持就行。使用 Java 与本地已编译代码进行交互，通常会丧失跨平台特性。

## 初识 native

初识 native 是在 Java 中的`java.lang.Object` 类中。

```java
 private static native void registerNatives();
    static {
        registerNatives();
    }
```

native 关键字表示这是一个本地方法。

## JNI 实现流程

![Java调用本地方法\JNI 实现流程示意图](Java调用本地方法\JNI 实现流程示意图.jpg)

## 示例代码

## 编写 Java 代码

```java
public class HelloNative{
    static{
        System.loadLibrary("HelloNative");
    }

    public native void sayHello();
    public native double sum(double a, double b);


    public static void main(String[] args){
        new HelloNative().sayHello();
        System.out.println(new HelloNative().sum(3.5, 4.0));
    }
}
```

该类声明了两个本地方法，且没有实现方法体。加载动态库`System.loadLibrary("HelloNative");` 其中的参数就是我们的动态库名称。

## 编译成字节码

javac  HelloNative.java

## 生成头文件

javah HelloNative

```c++
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class HelloNative */

#ifndef _Included_HelloNative
#define _Included_HelloNative
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     HelloNative
 * Method:    sayHello
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_HelloNative_sayHello
  (JNIEnv *, jobject);

/*
 * Class:     HelloNative
 * Method:    sum
 * Signature: (DD)D
 */
JNIEXPORT jdouble JNICALL Java_HelloNative_sum
  (JNIEnv *, jobject, jdouble, jdouble);

#ifdef __cplusplus
}
#endif
#endif
```

## 编写C的实现

```c++
#include <jni.h>
#include <stdio.h>
#include "HelloNative.h"    
JNIEXPORT void JNICALL Java_HelloNative_sayHello
  (JNIEnv *env, jobject ojb)
  {
      printf("Hello JNI");
      return;
  }

  JNIEXPORT jdouble JNICALL Java_HelloNative_sum
  (JNIEnv *env, jobject obj, jdouble a, jdouble b)
  {
      return a + b;
  }
```

## 编译成动态链接库文件

安装 GCC 64位的编译器 或者用Visual Studio 生成 64 位文件

```shell
gcc -c -I"D:\Program Files\Java\jdk1.8\jdk1.8.0_102\include" -I"D:\Program Files\Java\jdk1.8\jdk1.8.0_102\include\win32" HelloNative.c  

 gcc -Wl,--add-stdcall-alias -shared -o HelloNative.dll HelloNative.o
```

将 HelloNative.dll 文件拷贝至java项目根目录

## 运行

输出：

7.5

Hello JNI 

异常信息：

```shell
Exception in thread "main" java.lang.UnsatisfiedLinkError: E:\repository\java\eclipse-workspace\jni\HelloNative.dll: Can't load IA 32-bit .dll on a AMD 64-bit platform
```

错误原因是因为我们 gcc 编译出来的HelloNative.dll 是32位的，而我们的Jdk 版本是64位的。

## JNI 的副作用

- 可移植性，也就是说当你要实现跨平台就必须重新编辑本地代码。

- 不稳定性，可能会因为本地代码的使用不当导致整个系统崩盘。

参考文献：

https://www.jianshu.com/p/44cbe11e5d35
