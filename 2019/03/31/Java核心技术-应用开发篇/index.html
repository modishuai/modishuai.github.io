<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="请介绍类加载过程，什么是双亲委派模型？Java 类加载过程主要分为三个阶段：加载、链接、初始化。  加载（Loading），将 Java 字节码数据从不同的数据源读取到 JVM 中并映射为 JVM 认可的数据结构（Class 对象）。数据源可能的形态包括 jar 文件、class 文件、网络数据源等；如果输入数据不是 ClassFile 结构则抛出 ClassFormatError 错误。加载阶段">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 核心技术-应用开发篇">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;03&#x2F;31&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87&#x2F;index.html">
<meta property="og:site_name" content="莫非的技术笔记">
<meta property="og:description" content="请介绍类加载过程，什么是双亲委派模型？Java 类加载过程主要分为三个阶段：加载、链接、初始化。  加载（Loading），将 Java 字节码数据从不同的数据源读取到 JVM 中并映射为 JVM 认可的数据结构（Class 对象）。数据源可能的形态包括 jar 文件、class 文件、网络数据源等；如果输入数据不是 ClassFile 结构则抛出 ClassFormatError 错误。加载阶段">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;03&#x2F;31&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87&#x2F;Java核心技术-应用开发篇&#x2F;类加载器.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;03&#x2F;31&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87&#x2F;Java核心技术-应用开发篇&#x2F;java9模块.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;03&#x2F;31&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87&#x2F;Java核心技术-应用开发篇&#x2F;java9模块化.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;03&#x2F;31&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87&#x2F;Java核心技术-应用开发篇&#x2F;JVM内存区域.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;03&#x2F;31&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87&#x2F;Java核心技术-应用开发篇&#x2F;堆内结构.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;03&#x2F;31&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87&#x2F;Java核心技术-应用开发篇&#x2F;Eden区域.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;03&#x2F;31&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87&#x2F;Java核心技术-应用开发篇&#x2F;Eden1.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;03&#x2F;31&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87&#x2F;Java核心技术-应用开发篇&#x2F;Eden2.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;03&#x2F;31&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87&#x2F;Java核心技术-应用开发篇&#x2F;Eden3.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;03&#x2F;31&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87&#x2F;Java核心技术-应用开发篇&#x2F;老年代标记-压缩.png">
<meta property="article:published_time" content="2019-03-31T08:40:00.000Z">
<meta property="article:modified_time" content="2019-06-02T13:54:50.556Z">
<meta property="article:author" content="mofei">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Java GC">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;03&#x2F;31&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87&#x2F;Java核心技术-应用开发篇&#x2F;类加载器.png">

<link rel="canonical" href="http://yoursite.com/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Java 核心技术-应用开发篇 | 莫非的技术笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">莫非的技术笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mofei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫非的技术笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 核心技术-应用开发篇
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-31 16:40:00" itemprop="dateCreated datePublished" datetime="2019-03-31T16:40:00+08:00">2019-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-06-02 21:54:50" itemprop="dateModified" datetime="2019-06-02T21:54:50+08:00">2019-06-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="请介绍类加载过程，什么是双亲委派模型？"><a href="#请介绍类加载过程，什么是双亲委派模型？" class="headerlink" title="请介绍类加载过程，什么是双亲委派模型？"></a>请介绍类加载过程，什么是双亲委派模型？</h1><p>Java 类加载过程主要分为三个阶段：加载、链接、初始化。</p>
<ul>
<li><p>加载（Loading），将 Java 字节码数据从不同的数据源读取到 JVM 中并映射为 JVM 认可的数据结构（Class 对象）。数据源可能的形态包括 jar 文件、class 文件、网络数据源等；如果输入数据不是 ClassFile 结构则抛出 ClassFormatError 错误。加载阶段是用户可参与的阶段，也就是说我们可以自定义类加载器，去实现自己的类加载过程。</p>
</li>
<li><p>链接（Linking），核心步骤，将原始的类定义信息平滑的转化入 JVM 运行的过程中。</p>
<ul>
<li><p>验证（Verification）这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规的信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。</p>
</li>
<li><p>准备（Preparation）创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令。</p>
</li>
<li><p>解析（Resolution）在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。在<a href="[https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3"> Java 虚拟机</a>规范中，详细介绍了类、接口、方法和字段等各个方面的解析。</p>
</li>
</ul>
</li>
<li><p>初始化（Initialization）执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。</p>
</li>
</ul>
<h2 id="Java-8-之前的类加载器"><a href="#Java-8-之前的类加载器" class="headerlink" title="Java 8 之前的类加载器"></a>Java 8 之前的类加载器</h2><p>双亲委派模型，当类加载器（Class-Loader）试图加载某个类型的时候，先是委托给父加载器去完成，除非父加载器找不到相应类型，子加载器才会去加载。使用委派模型的目的是避免重复加载 Java 类型。</p>
<p><img src="/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/Java核心技术-应用开发篇\类加载器.png" alt="Java核心技术-应用开发篇\类加载器"></p>
<ul>
<li><p>启动类加载器（BootStrap Class-Loader）负责加载 jre/lib 目录下的 jar 文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"># 指定新的 bootclasspath，替换 java.* 包的内部实现</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath:&lt;your_boot_classpath&gt; your_App</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"># a 意味着 append，将指定目录添加到 bootclasspath 后面</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath/a:&lt;your_dir&gt; your_App</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"># p 意味着 prepend，将指定目录添加到 bootclasspath 前面</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath/p:&lt;your_dir&gt; your_App</span></pre></td></tr></table></figure>
</li>
<li><p>扩展类加载器（Extension or Ext Class-Loader）负责加载 jre/lib/ext 目录下的 jar 文件，所谓的 extension 机制，该目录可通过设置<code>javax.ext.dirs</code> 覆盖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">java -Djava.ext.dirs=your_ext_dir HelloWorld</span></pre></td></tr></table></figure>
</li>
<li><p>应用类加载器（Application or App Class-Loader）负责加载 classpath 中内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">java -Djava.system<span class="class">.<span class="keyword">class</span>.<span class="title">loader</span></span>=com.yourcorp.YourClassLoader HelloWorld</span></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="类加载机制的三个基本特征"><a href="#类加载机制的三个基本特征" class="headerlink" title="类加载机制的三个基本特征"></a>类加载机制的三个基本特征</h3><ul>
<li><p>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型， 是可能要加载用户代码的，比如 JDK 内部的 ServiceProvider/ServiceLoader机制，用户可以在标准 API 框架上，提供自己的实现，JDK 也需要提供些默认的参考实现。 例如，Java 中 JNDI、JDBC、文件系统、Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的<strong>上下文加载器</strong>。</p>
</li>
<li><p>可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑</p>
</li>
<li><p>单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</p>
</li>
</ul>
<h3 id="Java-9-平台模块化系统后的类加载器"><a href="#Java-9-平台模块化系统后的类加载器" class="headerlink" title="Java 9 平台模块化系统后的类加载器"></a>Java 9 平台模块化系统后的类加载器</h3><p>Java 9 ，由于 jigsaw 项目引入 Java 平台模块化系统（JPMS）,Java SE 源代码被划分为一系列模块。</p>
<p><img src="/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/Java核心技术-应用开发篇\java9模块.png" alt="Java平台模块化系统"></p>
<p>所以很多类加载器，类文件容器都发生了重大变化。</p>
<ul>
<li><p>前面提到的 -Xbootclasspath 参数不可用了。API 已经被划分到具体的模块，所以上文中，利 用“-Xbootclasspath/p”替换某个 Java 核心类型代码，实际上变成了对相应的模块进行的修补，可以采用下面的解决方案：</p>
<p>首先，确认要修改的类文件已经编译好，并按照对应模块（假设是 java.base）结构存放， 然后，给模块打补丁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">java --patch-<span class="keyword">module</span> java.base=your_patch yourApp</span></pre></td></tr></table></figure>
</li>
<li><p>扩展类加载器被重命名为平台类加载器（Platform Class-Loader），而且 extension 机制则被移除。也就意味着，如果我们指定 java.ext.dirs 环境变量，或者 lib/ext 目录存在，JVM 将直接返回.</p>
</li>
<li><p>部分不需要 AllPermission 的 Java 基础模块，被降级到平台类加载器中，相应的权限也被更精细粒度地限制起来。</p>
</li>
<li><p>rt.jar 和 tools.jar 同样是被移除了！JDK 的核心类库以及相关资源，被存储在 jimage 文件 中，并通过新的 JRT 文件系统访问，而不是原有的 JAR 文件系统。虽然看起来很惊人，但幸好对于大部分软件的兼容性影响，其实是有限的，更直接地影响是 IDE 等软件，通常只要升级到新版本就可以了。</p>
</li>
<li><p>增加了 Layer 的抽象， JVM 启动默认创建 BootLayer，开发者也可以自己去定义和实例化 Layer，可以更加方便的实现类似容器一般的逻辑抽象。</p>
</li>
</ul>
<p>结合了 Layer，目前的 JVM 内部结构就变成了下面的层次，内建类加载器都在 BootLayer 中， 其他 Layer 内部有自定义的类加载器，不同版本模块可以同时工作在不同的 Layer。</p>
<p><img src="/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/Java核心技术-应用开发篇\java9模块化.png" alt="Java9模块化"></p>
<h2 id="降低类加载的开销？"><a href="#降低类加载的开销？" class="headerlink" title="降低类加载的开销？"></a>降低类加载的开销？</h2><p>Java 需要类加载和解释、编译，这些都导致 Java 启动变慢。有没有通用办法，不需要代码和其他工作量，就能降低类加载的开销呢？</p>
<ul>
<li><p>AOT（Aheadof-Time Compilation）直接编译成机器码，降低解释和编译开销。但还在试验阶段，支持平台有限。</p>
</li>
<li><p>AppCDS（Application Class-Data Sharing），Java 5 中引进，但仅限于 Bootstrap Class-Loader。</p>
</li>
</ul>
<h3 id="AppCDS-基本原理和工作过程"><a href="#AppCDS-基本原理和工作过程" class="headerlink" title="AppCDS 基本原理和工作过程"></a>AppCDS 基本原理和工作过程</h3><p>首先，JVM 将类信息加载， 解析成为元数据，并根据是否需要修改，将其分类为 Read-Only 部分和 Read-Write 部分。然后，将这些元数据直接存储在文件系统中，作为所谓的 Shared Archive。命令很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Java -Xshare:dump -XX:+UseAppCDS -XX:SharedArchiveFile=&lt;jsa&gt;  \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">         -XX:SharedClassListFile=&lt;classlist&gt; -XX:SharedArchiveConfigFile=&lt;config_file&gt;</span></pre></td></tr></table></figure>

<p>第二，在应用程序启动时，指定归档文件，并开启 AppCDS。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Java -Xshare:on -XX:+UseAppCDS -XX:SharedArchiveFile=&lt;jsa&gt; yourApp</span></pre></td></tr></table></figure>

<p>通过上面的命令，JVM 会通过内存映射技术，直接映射到相应的地址空间，免除了类加载、解析等各种开销。</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><ul>
<li><p>什么是双亲委派模型，首先要知道什么是类加载器？</p>
<p>当某个类加载器要加载某个类型时，先是将加载任务委托给父加载器去完成，依次递归，只有当父加载器找不到指定类时（ClassNotFoundException）,子加载器才会尝试自己加载。</p>
</li>
<li><p>为什么需要双亲委派模型？</p>
<ul>
<li><p>避免重复加载。</p>
</li>
<li><p>避免恶意类的加载。</p>
</li>
<li><p>使用双亲委派模型的好处在于Java 类随着他的类加载器一起具备了优先级的层次关系</p>
</li>
</ul>
</li>
</ul>
<h1 id="有哪些方法可以在运行时动态生成一个Java类？"><a href="#有哪些方法可以在运行时动态生成一个Java类？" class="headerlink" title="有哪些方法可以在运行时动态生成一个Java类？"></a>有哪些方法可以在运行时动态生成一个Java类？</h1><ol>
<li><p>生成一段 Java 源代码，利用 ProcessBuilder 之类启动 javac 进程，指定 Java 源文件进行编译，最后利用类加载器，运行时加载即可。</p>
</li>
<li><p>借助<a href="https://docs.oracle.com/javase/8/docs/api/javax/tools/package-summary.html" target="_blank" rel="noopener"> Java Compiler API</a>  来实现，里面提供了与 javac 对等的编译功能。</p>
</li>
</ol>
<h2 id="重点掌握"><a href="#重点掌握" class="headerlink" title="重点掌握"></a>重点掌握</h2><ul>
<li><p>字节码和类加载到底是怎么无缝进行转换的？发生在整个类加载过程的哪一步？</p>
</li>
<li><p>如何利用字节码操纵技术，实现基本的动态代理逻辑？</p>
</li>
<li><p>除了动态代理，字节码操纵技术还有那些应用场景？</p>
</li>
</ul>
<h2 id="字节码转换为-Class-对象"><a href="#字节码转换为-Class-对象" class="headerlink" title="字节码转换为 Class 对象"></a>字节码转换为 Class 对象</h2><p>类从字节码到 Class 对象的转换，在类加载过程中是通过下面的方法提供的功能。</p>
<p>java.lang.ClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span>                   off, <span class="keyword">int</span> len,ProtectionDomain protectionDomain)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, java.nio.ByteBuffer b,ProtectionDomain protectionDomain)</span></pre></td></tr></table></figure>

<p>这里选取了最基础的两个典型的 defineClass 实现，Java 重载了几个不同的方法。</p>
<p>可以看出，只要能够生成出规范的字节码，不管是作为 byte 数组的形式，还是放到 ByteBuffer 里，都可以平滑地完成字节码到 Java 对象的转换过程。</p>
<p>JDK 提供的 defineClass 方法，最终都是本地代码实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass0(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len, ProtectionDomain pd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass1(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len, ProtectionDomain pd, String source);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass2(String name, java.nio.ByteBuffer b, <span class="keyword">int</span> off, <span class="keyword">int</span> len, ProtectionDomain pd,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">String source);</span></pre></td></tr></table></figure>

<h3 id="JDK-dynamic-proxy-的实现"><a href="#JDK-dynamic-proxy-的实现" class="headerlink" title="JDK dynamic proxy 的实现"></a>JDK dynamic proxy 的实现</h3><p><a href="http://hg.openjdk.java.net/jdk/jdk/file/29169633327c/src/java.base/share/classes/java/lang/reflect/Proxy.java" target="_blank" rel="noopener">jdk dynamic proxy </a> 来自 Java 9 ，对应逻辑是实现在 ProxyBuilder 这个静态内部类中，ProxyGenerator 生成字节码，并以 byte 数组的形式保存， 然后通过调用 Unsafe 提供的 defineClass 入口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Generate the specified proxy class.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    proxyName, interfaces.toArray(EMPTY_CLASS_ARRAY), accessFlags);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    Class&lt;?&gt; pc = UNSAFE.defineClass(proxyName, proxyClassFile,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                                    <span class="number">0</span>, proxyClassFile.length,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                                    loader, <span class="keyword">null</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    reverseProxyCache.sub(pc).putIfAbsent(loader, Boolean.TRUE);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> pc;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    * A ClassFormatError here means that (barring bugs in the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    * proxy class generation code) there was some other</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    * invalid aspect of the arguments supplied to the proxy</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    * class creation (such as virtual machine limitations</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    * exceeded).</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="Jdk-动态代理实现过程"><a href="#Jdk-动态代理实现过程" class="headerlink" title="Jdk 动态代理实现过程"></a>Jdk 动态代理实现过程</h3><ul>
<li><p>提供一个基础接口，作为被调用类型和代理类之间的统一入口。</p>
</li>
<li><p>实现 InvocationHandler，对代理对象方法的调用，会被分配到其 invoke 方法来真正实现动作。</p>
</li>
<li><p>通过 Proxy 类，调用器 newProxyInstance 方法，生成一个实现了相应基础接口的代理类实例。</p>
</li>
</ul>
<h2 id="字节码操纵逻辑"><a href="#字节码操纵逻辑" class="headerlink" title="字节码操纵逻辑"></a>字节码操纵逻辑</h2><p>JDK 内部动态代理的逻辑，可以参考java.lang.reflect.ProxyGenerator的内部实现。可以认为这是种另类的字节码操纵技术，其利用了 DataOutputStrem 提供的能力，配合 hard-coded 的各种 JVM 指令实现方法，生成所需的字节码数组。你可以参考下面的示例代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">codeLocalLoadStore</span><span class="params">(<span class="keyword">int</span> lvar, <span class="keyword">int</span> opcode, <span class="keyword">int</span> opcode_0,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                                DataOutputStream out)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">assert</span> lvar &gt;= <span class="number">0</span> &amp;&amp; lvar &lt;= <span class="number">0xFFFF</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 根据变量数值，以不同格式，dump 操作码</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (lvar &lt;= <span class="number">3</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        out.writeByte(opcode_0 + lvar);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lvar &lt;= <span class="number">0xFF</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        out.writeByte(opcode);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        out.writeByte(lvar &amp; <span class="number">0xFF</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 使用宽指令修饰符，如果变量索引不能用无符号 byte</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        out.writeByte(opc_wide);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        out.writeByte(opcode);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        out.writeShort(lvar &amp; <span class="number">0xFFFF</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="动态代码的生成发生在那个阶段？"><a href="#动态代码的生成发生在那个阶段？" class="headerlink" title="动态代码的生成发生在那个阶段？"></a>动态代码的生成发生在那个阶段？</h2><p>newProxyInstance 生成代理类实例的时候。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节有关动态代理技术及实现细节，常用的字节码操纵工具如 ASM、Javassit、cglib、JDK Proxy</p>
<p>Java 标准库也提供了与 javac 对等的编译器功能。</p>
<p>字节码操纵技术不仅仅用在动态代理，还应用在常见的ORM框架（MyBatis 用的javassit）、IOC容器、Mock 框架等；</p>
<h1 id="谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError"><a href="#谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError" class="headerlink" title="谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError?"></a>谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError?</h1><blockquote>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.5" target="_blank" rel="noopener">Java 虚拟机规范</a></p>
</blockquote>
<h2 id="运行时数据区-Run-Time-Data-Areas"><a href="#运行时数据区-Run-Time-Data-Areas" class="headerlink" title="运行时数据区(Run-Time Data Areas)"></a>运行时数据区(Run-Time Data Areas)</h2><ul>
<li><p>程序计数器（Program Counter Register）每个线程都有自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，即该线程的当前方法。在 JVM 规范中规定，如果线程执行的是非 native 方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是 native 方法，则程序计数器中的值是 undefined。</p>
</li>
<li><p>Java 虚拟机栈（Java Virtual Machine Stack）也叫 Java 栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用。在一个时间点，对应的只会有一个活动的栈帧，通常叫作当前帧，方法所在的类叫作当前类。如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，成为新的当前帧，一直到它返回结果或者执行结束<strong>。JVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈。</strong>栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。</p>
</li>
<li><p>堆（Heap）<strong>Java 内存管理的核心区域，用来存放对象实例和数组。</strong>被所有线程共享，虚拟机启动时创建可以指定“Xmx”之类参数指定堆空间大小。堆也是垃圾收集器重点照顾的区域，所以堆内空间还会被不同的垃圾收集器进行进一步的细分，最有名的就是新生代、老年代的划分。</p>
</li>
<li><p>方法区（Method Area）<strong>用来存储元数据信息，类结构、运行时产量池、字段、方法代码等。</strong>被所有线程共享，虚拟机启动时创建。方法区逻辑上是堆的一部分，但是可以通过简单实现让垃圾收集器不碰它。由于早期的 Hotspot JVM 实现，很多人习惯于将方法区称为永久代（Permanent Generation）。Oracle JDK 8 中将永久代移除，同时增加了元数据区（Metaspace）。</p>
</li>
<li><p>运行时常量池（Run-Time Constant Pool）是方法区的一部分，每个运行时常量池都是从 Java 虚拟机的方法区域中分配的。当Java虚拟机创建类或接口时，将构造类或接口的运行时常量池。</p>
</li>
<li><p>本地方法栈（Native Method Stack）和 Java 虚拟机栈是非常相似的，支持对本地方法的调用，也是每个线程都会创建一个。在 Oracle Hotspot JVM 中，本地方法栈和 Java 虚拟机栈是在同一块儿区域，这完全取决于技术实现的决定，并未在规范中强制。</p>
</li>
</ul>
<p><img src="/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/Java核心技术-应用开发篇\JVM内存区域.png" alt="JVM内存区域"></p>
<h2 id="哪些区域可能发生OutOfMemoryError"><a href="#哪些区域可能发生OutOfMemoryError" class="headerlink" title="哪些区域可能发生OutOfMemoryError?"></a>哪些区域可能发生OutOfMemoryError?</h2><p>除了程序计数器以外，其他区域都可能发生 OutOfMemoryError。</p>
<ul>
<li><p>堆内存不足，抛出错误信息是“java.lang.OutOfMemoryError:Java heap space”</p>
</li>
<li><p>Java 虚拟机栈和本地方法栈，这里要稍微复杂一点。如果我们写一段程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。类似这种情况，JVM 实际会抛出 StackOverFlowError；当然，如果 JVM 试图去扩展栈空间的时候失败，则会抛出 OutOfMemoryError。</p>
</li>
<li><p>对于老版本的 Oracle JDK，因为永久代的大小是有限的，并且 JVM 对永久代垃圾回收（如， 常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OutOfMemoryError 也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似 Intern 字符串缓存占用太多空间，也会导致 OOM 问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError: PermGen space”。</p>
</li>
<li><p>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的 OOM 有所改观，出现 OOM，异常信息则变成了：“java.lang.OutOfMemoryError: Metaspace”。</p>
</li>
<li><p>直接内存不足，也会导致 OOM</p>
</li>
</ul>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>在试图分配一个 100M bytes 大数组的时候发生了 OOME，但是 GC 日志显示，明明堆上还有远不止 100M 的空间， 你觉得可能问题的原因是什么？想要弄清楚这个问题，还需要什么信息呢？</p>
<ul>
<li><p>从 JVM 的角度来看：</p>
<p>要看下新生代和老年代的垃圾回收机制是什么。如果新生代是 serial，会默认使用 copying 算法，利用两块 eden 和survivor 来进行处理。但是默认当遇到超大对象时，会直接将超大对象放置到老年代中，而不用走正常对象的存活次数记录。因为要放置的是一个 byte 数组，那么必然需要申请连续的空间，当空间不足时，会进行 gc 操作。这里又需要看老年代的 gc 机制是哪一种。如果是 serial old，那么会采用 mark compat，会进行整理，从而整理出连续空间，如果还不够，说明是老年代的空间不够，所谓的堆内存大于 100m 是新+老共同的结果。如果采用的是cms(concurrent mark sweep)，那么只会标记清理，并不会压缩，所以内存会碎片化，同时可能出现浮游垃圾。如果是 cms 的话，即使老年代的空间大于100m，也会出现没有连续的空间供该对象使用。</p>
</li>
<li><p>从垃圾收集器角度来看：  首先，数组的分配是需要连续的内存空间的（据说，有个别非主流JVM支持大数组用不连续的内存空间分配🤔）。所以：  </p>
<ul>
<li><p>对于使用年轻代和老年代来管理内存的垃圾收集器，堆大于 100M，表示的是新生代和老年代加起来总和大于100M，而新生代和老年代各自并没有大于 100M 的连续内存空间。  进一步，又由于大数组一般直接进入老年代（会跳过对对象的年龄的判断），所以，是否可以认为老年代中没有连续大于 100M 的空间呢。  </p>
</li>
<li><p>对于 G1 这种按 region 来管理内存的垃圾收集器，可能的情况是没有多个连续的 region，它们的内存总和大于 100M。  当然，不管是哪种垃圾收集器以及收集算法，当内存空间不足时，都会触发 GC，只不过，可能 GC 之后，还是没有连续大于 100M 的内存空间，于是 OOM了。</p>
</li>
</ul>
</li>
</ul>
<h1 id="如何监控和诊断JVM堆内和堆外内存使用？"><a href="#如何监控和诊断JVM堆内和堆外内存使用？" class="headerlink" title="如何监控和诊断JVM堆内和堆外内存使用？"></a>如何监控和诊断JVM堆内和堆外内存使用？</h1><p>了解 JVM 内存的方法很多，具体能力范围也有区别：</p>
<ul>
<li><p>图形化工具：JConsole、JMC、 VisualVM（Oracle JDK 9 不再包含） ，其中 JMC 和 JConsole 统计部分非堆内存。</p>
</li>
<li><p>命令行工具：jstat 、 jmap，可查看堆、方法区等使用数据。</p>
</li>
<li><p>JavaEE 服务器也提供内存管理功能，如 Tomcat 、 WebLogic</p>
</li>
<li><p>GC 日志的输出也同样包含丰富的内存信息。</p>
</li>
<li><p>NMT（Native Memory Tracking）监控堆外内存中的直接内存。</p>
</li>
</ul>
<h2 id="重点掌握-1"><a href="#重点掌握-1" class="headerlink" title="重点掌握"></a>重点掌握</h2><ul>
<li><p>细化对各部分内存区域的理解，堆内结构是怎样的？如何通过参数调整。</p>
</li>
<li><p>堆外内存到底包括那些部分？具体大小受那些因素影响？</p>
</li>
</ul>
<h2 id="堆内部结构"><a href="#堆内部结构" class="headerlink" title="堆内部结构"></a>堆内部结构</h2><p>对于堆内存，我在上一讲介绍了最常见的新生代和老年代的划分，其内部结构随着 JVM 的发展和新 GC 方式的引入，可以有不同角度的理解，下图就是以年代视角的堆结构示意图。</p>
<p><img src="/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/Java核心技术-应用开发篇\堆内结构.png" alt="Java核心技术-应用开发篇\堆内结构"></p>
<p>关于 Virtual 区域：在 JVM 内部，如果 Xms 小于 Xmx，堆的大小并不会直接扩展到其上限，也就是说保留的空间（reserved）大于实际能够使用的空间（committed）。当内存需求不断增长的时候，JVM 会逐渐扩展新生代等区域的大小，所以 Virtual 区域代表的就是暂时不可用（uncommitted）的空间。</p>
<p>按照通常的 GC 年代方式划分，Java 堆内分为：</p>
<ul>
<li><p>新生代</p>
<p><strong>大部分对象的创建和销毁都在新生代区域，绝大多数对象生命周期是很短暂的</strong>。其内部有分为 Eden 区域，作为对象初始化分配的区域；两个 Survivor，也叫 from、to 区域，被用来放置 Minor GC 中保留下来的对象。</p>
<ul>
<li><p>JVM 会随意选一个 Survivor 区域作为“to”，然后会在 GC 过程中进行区域间拷贝，也就是将 Eden 和 from 区域中存活下来的的对象，拷贝到这个 to 区域。这种设计主要是为了防止内存的碎片化，并进一步清理无用对象。</p>
</li>
<li><p>从内存模型的角度，又对 Eden 区域继续进行划分，Hotspot JVM 还有一个概念叫做 Thread Local Allocation Buffer（TLAB）。这是 JVM 为每个线程分配的一个私有缓存区域，否则，多线程同时分配内存时，为避免操作同一地址，可能需要使用加锁等机制，进而影响分配速度，你可以参考下面的示意图。从图中可以看出，TLAB 仍然在堆上，它是分配在 Eden 区域内的。其内部结构比较直观易懂，start、end 就是起始地址，top（指针）则表示已经分配到哪里了。所以我们分配新对象，JVM 就会移动 top，当 top 和 end 相遇时，即表示该缓存已满，JVM 会试图再从 Eden 里分配一块儿。</p>
<p><img src="/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/Java核心技术-应用开发篇\Eden区域.png" alt="Java核心技术-应用开发篇\Eden区域"></p>
</li>
</ul>
</li>
<li><p>老年代</p>
<p><strong>用来存放生命周期比较长的对象，也就是从 Survivor 区域拷贝过来的对象</strong>。特殊情况下，如果对象较大 JVM 会试图直接分配在 Eden 其他位置；如果对象太大，在新生代找不到足够长的连续空间，JVM 就会直接分配到老年代。</p>
</li>
<li><p>永久代</p>
<p>早期 Hotspot JVM 的方法去实现方式，用来储存 Java 类元数据、常量池、Intern 字符串池，JDK 8 之后就不存在了。</p>
</li>
</ul>
<h3 id="利用-JVM-参数影响堆和内部区域大小。"><a href="#利用-JVM-参数影响堆和内部区域大小。" class="headerlink" title="利用 JVM 参数影响堆和内部区域大小。"></a>利用 JVM 参数影响堆和内部区域大小。</h3><ul>
<li><p>最大堆体积 ，<code>-Xmx value</code></p>
</li>
<li><p>初始最小的堆体积，<code>-Xms value</code></p>
</li>
<li><p>老年代和新生代的比例，<code>-XX:NewRatio=value</code>，默认数值是 2 ，意味着老年代是新生代的 2 倍大；</p>
</li>
<li><p>指定具体的内存大小数值，<code>-XX:NewSize=value</code> 代替用比例的方式调整新生代的大小。</p>
</li>
<li><p>Eden 和 Survivor 的大小是按照比例设置的，如果 SurvivorRatio 是 8，那么 Survivor 区域就是 Eden 的 1/8 大小，也就是新生代的 1/10，因为 YoungGen=Eden + 2*Survivor，JVM 参数格式是，<code>-XX:SurvivorRatio=value</code></p>
</li>
<li><p>TLAB 也可以调整，参考<a href="https://blogs.oracle.com/jonthecollector/the-real-thing" target="_blank" rel="noopener">资料</a></p>
</li>
</ul>
<h2 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h2><p>Java 分配堆外内存的两种方式如下：</p>
<ul>
<li><p><code>java.nio.ByteBuffer.allocateDirect</code> 获得DirectByteBuffer 对象实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Primary constructor</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//1. 调用基类构造为字段赋值。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> ps = Bits.pageSize();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//2. 预先分配内存</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        Bits.reserveMemory(size, cap);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//3. unsafe 分配内存。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">long</span> base = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            base = unsafe.allocateMemory(size);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            Bits.unreserveMemory(size, cap);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">throw</span> x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//4. 为已分配内存初始值为0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Round up to page boundary</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            address = base;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//5. 创建Cleaner 对象，用来释放堆外内存。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        att = <span class="keyword">null</span>;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
</li>
<li><p><code>sun.misc.Unsafe.allocateMemory</code> 分配内存。</p>
</li>
</ul>
<h3 id="堆外内存适用场景"><a href="#堆外内存适用场景" class="headerlink" title="堆外内存适用场景"></a>堆外内存适用场景</h3><ul>
<li><p>适合长生命周期存在的对象。</p>
</li>
<li><p>适合网络 IO 或外部文件读写。</p>
</li>
<li><p>堆外内存能有效避免因 GC 导致的暂停问题。</p>
</li>
</ul>
<h2 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h2><p>除了使用工具对 Java 内存进行监控外，还有哪些方式能做到呢？</p>
<p>java.lang.Runtime 类中包含如下方法可以监控 Java 内存的使用情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回 Java 虚拟机可用的内存容量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">freeMemory</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回 Java 虚拟机内存总容量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">totalMemory</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回Java虚拟机将占用的最大内存</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">maxMemory</span><span class="params">()</span></span>;</span></pre></td></tr></table></figure>

<p>为什么在标记垃圾的时候，需要stop the world？</p>
<p>以 cms 为例，它有不同的 mark： initial mark，conc mark， remark；conc 时候不需要 stw；其他需要短暂 stw，这样引用关系才不变，另外效率也高</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html" target="_blank" rel="noopener">JConsole 文档</a></p>
<p><a href="https://docs.oracle.com/cd/E15289_01/JRMCI/toc.htm" target="_blank" rel="noopener">JRockit Mission Control 文档</a></p>
<p>补充一些关于Eden、两个 Survivor 的细节。</p>
<ul>
<li><p>大部分对象创建都是在 Eden 的，除了个别大对象。</p>
</li>
<li><p>Minor GC 开始前，to-survivor 是空的，from-survivor 是有对象的。</p>
</li>
<li><p>Minor GC 后，Eden 的存活对象都 copy 到 to-survivor 中，from-survivor 的存活对象也复制 to-survivor 中。其中所有对象的年龄+1</p>
</li>
<li><p>from-survivor 清空，成为新的 to-survivor，带有对象的 to-survivor 变成新的 from-survivor。重复回到步骤2</p>
</li>
</ul>
<h1 id="Java常见的垃圾收集器有哪些？"><a href="#Java常见的垃圾收集器有哪些？" class="headerlink" title="Java常见的垃圾收集器有哪些？"></a>Java常见的垃圾收集器有哪些？</h1><p>垃圾收集器（GC，Garbage Collector）和 JVM 紧密相关，不同厂商有不同版本的 JVM 存在较大的差异性。</p>
<ul>
<li><p>垃圾收集算法？如何判断一个对象是否可以回收？</p>
</li>
<li><p>垃圾收集器的工作流程？</p>
</li>
</ul>
<h2 id="多维度分析垃圾收集"><a href="#多维度分析垃圾收集" class="headerlink" title="多维度分析垃圾收集"></a>多维度分析垃圾收集</h2><ul>
<li><p>按线程数目，可分为串行和并行垃圾收集器。在并行能力较强的 CPU 使用并行垃圾收集器可缩短应用程序停顿时间。</p>
</li>
<li><p>按工作模式，可分为并发式和独占式垃圾收集器。并发式垃圾收集器与应用程序交替工作，尽量减少应用停顿时间，独占式垃圾收集器（Stop-the-world）一旦运行，就停止应用程序中所有线程，直到垃圾收集工作完成。</p>
</li>
<li><p>按碎片处理方式，可分为压缩式和非压缩式垃圾收集器。压缩式垃圾收集器在工作完成之后，对存活对象进行压缩整理，消除收集后的碎片。</p>
</li>
<li><p>按工作的内存区域，可分为老年代和新生代垃圾收集器。</p>
</li>
</ul>
<h2 id="常见的垃圾收集器"><a href="#常见的垃圾收集器" class="headerlink" title="常见的垃圾收集器"></a>常见的垃圾收集器</h2><ul>
<li><p>Serial GC，两个显著特点：第一，使用单线程进行垃圾收集；第二，它以独占的垃圾收集；进行垃圾收集工作时 Java 应用程序中的线程需要暂停，直到垃圾收集工作完成，也就是常说的（Stop-The-World）</p>
<p><code>-XX:+UseSerialGC</code></p>
<ul>
<li><p>新生代串行收集器，采用复制（Copying）算法。</p>
</li>
<li><p>老年代串行收集器，标记 - 压缩（Mark-Compact）算法；垃圾收集需要比新生代垃圾收集更长的时间。</p>
</li>
</ul>
</li>
<li><p>ParNew GC，新生代 GC 的实现，是 Serial GC 的多线程版本，常见的应用场景是配合老年代的 CMS GC 工作。</p>
<p><code>-XX:+UseConcMarkSweepGC -XX:+UseParNewGC</code></p>
</li>
<li><p>CMS（Concurrent Mark Sweep），<strong>关注减少系统停顿时间（对响应时间的 Web 等应用非常重要），采用标记-清除（Makr - Sweep）算法（缺点是存在内存碎片化），使用多线程并发回收的垃圾收集器。</strong>CMS 主要工作步骤：初始标记、并发标记、重新标记、清除并发和并发重置。初始标记和重新标记是独占系统资源，并发标记和并发重置是可以和用户线程一起执行。采用标记-清除算法，将会产生大量内存碎片。由于CMS 和应用程序线程并发执行，也就意味着相互抢占 CPU ，工作期间对应用程序吞吐量造成影响。</p>
</li>
<li><p>Parrallel GC，作为早期 JDK8 等版本，server 模式 JVM 的默认 GC， 吞吐量优先的 GC。并行收集器和串行收集器差不多一样，主要的区别在于多线程。在并发能力较强的 CPU 上产生的停顿时间更短，反之不如串行收集器。</p>
<p><code>-XX:+UseParallelGC</code> 开启并行回收器；<code>XX:ParallelGCThreads</code>指定并行收集器工作的线程数目，建议与 CPU 数量相当，避免过多的线程数影响垃圾收集性能。</p>
<ul>
<li><p>新生代并行收集器，采用复制算法</p>
</li>
<li><p>老年代并行收集器，采用标记-压缩算法</p>
</li>
</ul>
</li>
<li><p>G1 GC，作为 JDK 9 中默认的 GC，同时 CMS 并标记为废弃（deprecated）。<strong>G1 作为一款服务器的垃圾收集器，重点关注吞吐量和停顿。</strong>G1 GC 仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一 个个 region。Region 之间是复制算法，但整体上实际可看作是标记 - 整理（MarkCompact）算法，可以有效地避免内存碎片，尤其是当 Java 堆非常大的时候，G1 的优势更加明显。使用参数 <code>-XX:+UnlockExperimentalVMOptions –XX:+UseG1GC</code>来启用 G1 回收器，设置 G1 回收器的目标停顿时间：<code>-XX:MaxGCPauseMills=20,-XX:GCPauseIntervalMills=200</code>。</p>
</li>
</ul>
<h2 id="垃圾收集原理和基础概念"><a href="#垃圾收集原理和基础概念" class="headerlink" title="垃圾收集原理和基础概念"></a>垃圾收集原理和基础概念</h2><p>自动垃圾收集前需要明确哪些内存可以被释放，内存结构和类加载。</p>
<p>主要有两方面，存放在堆上的  Java 对象实例；方法区中的元数据信息。</p>
<ul>
<li><p><strong>引用计数</strong>，引用计数的难题在于处理“循环引用”关系，所以 Java 垃圾收集器没有采用这种算法。</p>
<p>引用计数器的实现很简单，对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1，当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，则对象 A 就不可能再被使用。</p>
<p>所谓<strong>循环引用</strong>，对象 A 和对象 B，对象 A 中含有对象 B 的引用，对象 B 中含有对象 A 的引用。此时，对象 A 和对象 B 的引用计数器都不为 0。但是在系统中却不存在任何第 3 个对象引用了 A 或 B。也就是说，A 和 B 是应该被回收的垃圾对象，但由于垃圾对象间相互引用，从而使垃圾回收器无法识别，引起内存泄漏。</p>
</li>
<li><p><strong>可达性分析</strong>，将对象及其引用关系看作一个图，选定活动的对象作为 GC Roots，然后跟踪引用链条，若一个对象和 GC Roots 之间不可达，也就是不存在引用链条，就可以认为是可回收的对象。JVM 会把虚拟机栈中和本地方法栈中长在引用的对象、静态属性引用的对象和常量，作为 GC Roots。</p>
</li>
<li><p>复制（Copying）将内存分为两块区域，每次只使用其中一块区域，进行垃圾回收时将活着的对象复制到另一块区域，复制过程将对象顺序放置（<strong>避免内存碎片化</strong>），然后清除正在使用的内存块中的所有对象，交换两个内存角色，完成垃圾回收。<strong>其缺陷是在进行复制需要提前预留内存空间；对于 G1这种大量拆分成多个 region 的 GC ，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，这种开销也不小，无论是内存占用还是时间开销。</strong></p>
<p>Java 的新生代串行垃圾回收器中使用了复制算法的思想。新生代分为 eden 空间、from 空间、to 空间 3 个部分。其中 from 空间和 to 空间可以视为用于复制的两块大小相同、地位相等，且可进行角色互换的空间块。from 和 to 空间也称为 survivor 空间，即幸存者空间，用于存放未被回收的对象。</p>
<p>在垃圾回收时，eden 空间中的存活对象会被复制到未使用的 survivor 空间中（假设是 to），正在使用的 survivor 空间 （假设是 from)）中的年轻对象也会被复制到 to 空间中 （大对象，或者老年对象会直接进入老年代，如果 to 空间已满，则对象也会直接进入老年代）。此时，eden 空间和 from 空间中的剩余对象就是垃圾对象，可以直接清空，to 空间则存放此次回收后的存活对象。这种改进的复制算法既保证了空间的连续性，又避免了大量的内存空间浪费。</p>
<p>新生代 GC 都是基于复制算法。</p>
</li>
<li><p>标记 - 清除（Mark-Sweep）在标记阶段首先通过根节点，标记所有从根节点开始的较大对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。<strong>该算法最大的问题是存在大量的空间碎片，因为回收后的空间是不连续的。</strong>在对象的堆空间分配过程中，尤其是大对象的内存分配，不连续的内存空间的工作效率要低于连续的空间。</p>
</li>
<li><p>标记 - 压缩 （Mark - Compact）和标记-清除算法类似，在此基础上做了些优化。首先从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。</p>
</li>
<li><p>增量算法（Incremental Collecting）为了减少系统的停顿时间，让垃圾收集和应用线程交替执行。每次，垃圾收集线程收集一小片区域的内存空间，接着切换到应用程序线程。但是线程切换和上下文转换的消耗，造成垃圾回收总成本上升，系统吞吐量下降。</p>
</li>
<li><p>分代（Generational Collecting）<strong>根据垃圾回收对象的特点，选择合适的回收算法。</strong>它将内存区间根据对象的特点分成几块，根据每块内存区间的特点，使用不同的回收算法，以提高垃圾回收的效率。以 Hot Spot 虚拟机为例，它将所有的新建对象都放入称为新生代的内存区域，<strong>新生代的特点是对象会很快回收，因此，新生代选择效率较高的复制算法</strong>。当一个对象经过几次回收后依然存活，对象就会被放入称为老年代的内存空间。在老年代中，几乎所有的对象都是经过几次垃圾回收后依然得以幸存的。因此，可以认为这些对象在一段时期内，甚至在应用程序的整个生命周期中，将是常驻内存的。如果依然使用复制算法回收老生代，将需要复制大量对象。再加上老生代的回收性价比也要低于新生代，因此这种做法也是不可取的。根据分代的思想，<strong>可以对老年代的回收使用与新生代不同的标记-压缩算法，以提高垃圾回收效率。</strong></p>
</li>
</ul>
<h2 id="垃圾收集过程"><a href="#垃圾收集过程" class="headerlink" title="垃圾收集过程"></a>垃圾收集过程</h2><p>第一，Java 应用不断创建对象，通常都是分配在 Eden 区域，当其空间占用达到一定阈值时，触发 minor GC。仍然被引用的对象（绿色方块）存活下来，被复制到 JVM 选择的 Survivor 区域，而没有被引用的对象（黄色方块）则被回收。注意，我给存活对象标记了“数字 1”，这是为了表明对象的存活时间。</p>
<p><img src="/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/Java核心技术-应用开发篇\Eden1.png" alt="Java核心技术-应用开发篇\Eden1"></p>
<p>第二， 经过一次 Minor GC，Eden 就会空闲下来，直到再次达到 Minor GC 触发条件，这时候，另外一个 Survivor 区域则会成为 to 区域，Eden 区域的存活对象和 From 区域对象，都会被复制到 to 区域，并且存活的年龄计数会被加 1。</p>
<p><img src="/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/Java核心技术-应用开发篇\Eden2.png" alt="Java核心技术-应用开发篇\Eden2"></p>
<p>第三， 类似第二步的过程会发生很多次，直到有对象年龄计数达到阈值，这时候就会发生所谓的晋升（Promotion）过程，如下图所示，超过阈值的对象会被晋升到老年代。这个阈值是可以通过参数指定：<code>-XX:MaxTenuringThreshold=&lt;N&gt;</code></p>
<p><img src="/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/Java核心技术-应用开发篇\Eden3.png" alt="Java核心技术-应用开发篇\Eden3"></p>
<p>后面就是老年代 GC，具体取决于选择的 GC 选项，对应不同的算法。下面是一个简单标记 - 压缩算法过程示意图，老年代中的无用对象被清除后， GC 会将对象进行整理，以防止内存碎片化。</p>
<p><img src="/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/Java核心技术-应用开发篇\老年代标记-压缩.png" alt="Java核心技术-应用开发篇\老年代标记-压缩"></p>
<h2 id="GC-新的发展"><a href="#GC-新的发展" class="headerlink" title="GC 新的发展"></a>GC 新的发展</h2><p>JDK 11 中有新增了 2 中 GC 方式。</p>
<ul>
<li><p>Epsilon GC，控制内存分配，不做垃圾收集。一旦 Java 堆空间被耗尽，JVM 直接关闭。</p>
</li>
<li><p>ZGC ，Oracle 开源产品，支持 T bytes 级别的堆大小，大部分情况下延迟不会超过 10 ms，目前处于试验阶段，仅支持 Linux 64 位平台。</p>
</li>
</ul>
<h2 id="思考题-2"><a href="#思考题-2" class="headerlink" title="思考题"></a>思考题</h2><p>通常使用什么参数去打开 GC 日志呢？还会额外添加哪些选项？</p>
<p><a href="https://dzone.com/articles/disruptive-changes-to-gc-logging-in-java-9" target="_blank" rel="noopener">参考资料</a></p>
<p><a href="http://openjdk.java.net/jeps/158" target="_blank" rel="noopener">JEP 158: Unified JVM Logging</a></p>
<p>Enable Java 8 GC Logs:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails -Xloggc:&lt;gc-log-file-path&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC -Xloggc:&lt;gc-log-file-path&gt;</span></pre></td></tr></table></figure>

<p>Enable Java 9 GC Logs：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">-Xlog:gc*:file=&lt;gc-log-file-path&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">-Xlog:gc:file=&lt;gc-log-file-path&gt;</span></pre></td></tr></table></figure>

<h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><p><a href="https://www.cnblogs.com/cxxjohnson/p/8625713.html" target="_blank" rel="noopener">Java虚拟机垃圾回收(三) 7种垃圾收集器</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-JVMGarbageCollection/index.html" target="_blank" rel="noopener"> JVM 垃圾回收器分类</a></p>
<p><a href="http://www.importnew.com/23752.html" target="_blank" rel="noopener"> Java GC算法 垃圾收集器</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/Java-GC/" rel="tag"># Java GC</a>
              <a href="/tags/JVM/" rel="tag"># JVM</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/03/24/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87%E4%BA%8C/" rel="prev" title="Java 核心技术-进阶篇二">
      <i class="fa fa-chevron-left"></i> Java 核心技术-进阶篇二
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/04/07/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%AF%87/" rel="next" title="Java 核心技术-安全基础篇">
      Java 核心技术-安全基础篇 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#请介绍类加载过程，什么是双亲委派模型？"><span class="nav-number">1.</span> <span class="nav-text">请介绍类加载过程，什么是双亲委派模型？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-8-之前的类加载器"><span class="nav-number">1.1.</span> <span class="nav-text">Java 8 之前的类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载机制的三个基本特征"><span class="nav-number">1.1.1.</span> <span class="nav-text">类加载机制的三个基本特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-9-平台模块化系统后的类加载器"><span class="nav-number">1.1.2.</span> <span class="nav-text">Java 9 平台模块化系统后的类加载器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#降低类加载的开销？"><span class="nav-number">1.2.</span> <span class="nav-text">降低类加载的开销？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AppCDS-基本原理和工作过程"><span class="nav-number">1.2.1.</span> <span class="nav-text">AppCDS 基本原理和工作过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双亲委派模型"><span class="nav-number">1.3.</span> <span class="nav-text">双亲委派模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#有哪些方法可以在运行时动态生成一个Java类？"><span class="nav-number">2.</span> <span class="nav-text">有哪些方法可以在运行时动态生成一个Java类？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#重点掌握"><span class="nav-number">2.1.</span> <span class="nav-text">重点掌握</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字节码转换为-Class-对象"><span class="nav-number">2.2.</span> <span class="nav-text">字节码转换为 Class 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK-dynamic-proxy-的实现"><span class="nav-number">2.2.1.</span> <span class="nav-text">JDK dynamic proxy 的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Jdk-动态代理实现过程"><span class="nav-number">2.2.2.</span> <span class="nav-text">Jdk 动态代理实现过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字节码操纵逻辑"><span class="nav-number">2.3.</span> <span class="nav-text">字节码操纵逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态代码的生成发生在那个阶段？"><span class="nav-number">2.4.</span> <span class="nav-text">动态代码的生成发生在那个阶段？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">2.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError"><span class="nav-number">3.</span> <span class="nav-text">谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError?</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#运行时数据区-Run-Time-Data-Areas"><span class="nav-number">3.1.</span> <span class="nav-text">运行时数据区(Run-Time Data Areas)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哪些区域可能发生OutOfMemoryError"><span class="nav-number">3.2.</span> <span class="nav-text">哪些区域可能发生OutOfMemoryError?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思考题"><span class="nav-number">3.3.</span> <span class="nav-text">思考题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何监控和诊断JVM堆内和堆外内存使用？"><span class="nav-number">4.</span> <span class="nav-text">如何监控和诊断JVM堆内和堆外内存使用？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#重点掌握-1"><span class="nav-number">4.1.</span> <span class="nav-text">重点掌握</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆内部结构"><span class="nav-number">4.2.</span> <span class="nav-text">堆内部结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#利用-JVM-参数影响堆和内部区域大小。"><span class="nav-number">4.2.1.</span> <span class="nav-text">利用 JVM 参数影响堆和内部区域大小。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆外内存"><span class="nav-number">4.3.</span> <span class="nav-text">堆外内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#堆外内存适用场景"><span class="nav-number">4.3.1.</span> <span class="nav-text">堆外内存适用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思考题-1"><span class="nav-number">4.4.</span> <span class="nav-text">思考题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结-1"><span class="nav-number">4.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java常见的垃圾收集器有哪些？"><span class="nav-number">5.</span> <span class="nav-text">Java常见的垃圾收集器有哪些？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#多维度分析垃圾收集"><span class="nav-number">5.1.</span> <span class="nav-text">多维度分析垃圾收集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见的垃圾收集器"><span class="nav-number">5.2.</span> <span class="nav-text">常见的垃圾收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集原理和基础概念"><span class="nav-number">5.3.</span> <span class="nav-text">垃圾收集原理和基础概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集过程"><span class="nav-number">5.4.</span> <span class="nav-text">垃圾收集过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC-新的发展"><span class="nav-number">5.5.</span> <span class="nav-text">GC 新的发展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思考题-2"><span class="nav-number">5.6.</span> <span class="nav-text">思考题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他资料"><span class="nav-number">5.7.</span> <span class="nav-text">其他资料</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">mofei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mofei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.1.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
