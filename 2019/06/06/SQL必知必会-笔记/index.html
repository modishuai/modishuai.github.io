<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Structured Query Language（结构化查询语言），是一种专门用来与数据库沟通的语言。 标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。主要的 DBMS，即使有自己的扩展，也都支持 ANSI SQL。各个数据库对 SQL 的扩展也有差异，实际中可参考其手册。  SQL 基础主键设计规范 任意两行，不具有相同的主键值； 每行都必须具有一个主键值（主键不允许">
<meta property="og:type" content="article">
<meta property="og:title" content="SQL必知必会第四版-笔记">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;06&#x2F;06&#x2F;SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E7%AC%94%E8%AE%B0&#x2F;index.html">
<meta property="og:site_name" content="莫非的技术笔记">
<meta property="og:description" content="Structured Query Language（结构化查询语言），是一种专门用来与数据库沟通的语言。 标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。主要的 DBMS，即使有自己的扩展，也都支持 ANSI SQL。各个数据库对 SQL 的扩展也有差异，实际中可参考其手册。  SQL 基础主键设计规范 任意两行，不具有相同的主键值； 每行都必须具有一个主键值（主键不允许">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-06-06T14:43:59.000Z">
<meta property="article:modified_time" content="2019-12-10T11:47:17.162Z">
<meta property="article:author" content="mofei">
<meta property="article:tag" content="SQL">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2019/06/06/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>SQL必知必会第四版-笔记 | 莫非的技术笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">莫非的技术笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/06/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mofei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫非的技术笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SQL必知必会第四版-笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-06 22:43:59" itemprop="dateCreated datePublished" datetime="2019-06-06T22:43:59+08:00">2019-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-10 19:47:17" itemprop="dateModified" datetime="2019-12-10T19:47:17+08:00">2019-12-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">后端笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>Structured Query Language（结构化查询语言），是一种专门用来与数据库沟通的语言。</p>
<p>标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。主要的 DBMS，即使有自己的扩展，也都支持 ANSI SQL。各个数据库对 SQL 的扩展也有差异，实际中可参考其手册。</p>
</blockquote>
<h1 id="SQL-基础"><a href="#SQL-基础" class="headerlink" title="SQL 基础"></a>SQL 基础</h1><h2 id="主键设计规范"><a href="#主键设计规范" class="headerlink" title="主键设计规范"></a>主键设计规范</h2><ul>
<li>任意两行，不具有相同的主键值；</li>
<li>每行都必须具有一个主键值（主键不允许为 null ）</li>
<li>主键列中的值不允许修改或更新；</li>
<li>主键值不允许重用；</li>
</ul>
<h2 id="字符串数据类型"><a href="#字符串数据类型" class="headerlink" title="字符串数据类型"></a>字符串数据类型</h2><ul>
<li>固定长度字符串，接受固定长度的字符串，其长度在创建时指定。如果字符串长度没有达到创建时指定的长度，缺少的字符串则用空格填充或补为 null。</li>
<li>可变长度字符串，存储任意长度的文本（最大长度随不同的数据类型和 DBMS 而变化），只保存指定的数据。</li>
</ul>
<p>问：有了可变长度字符串为什么还要选择固定长度字符串？</p>
<blockquote>
<p>固定长度字符串性能优于可变长度字符串，因为 DBMS 处理固定长度字符串列比可变长度字符串列更快，还有些 DBMS 不允许对可变长度字符串列进行索引。</p>
</blockquote>
<h2 id="通配符的使用"><a href="#通配符的使用" class="headerlink" title="通配符的使用"></a>通配符的使用</h2><p>一般而言，除非你确实需要表中的每一列，否则最好别使用 <code>*</code>通配符。虽然使用通配符能让你自己省事，不用明确列出所需列，但检索不需要的列通常会降低检索和应用程序的性能。</p>
<h3 id="检索未知列"><a href="#检索未知列" class="headerlink" title="检索未知列"></a>检索未知列</h3><p>使用通配符有一个大优点。由于不明确指定列名（因为星号检索每一列），所以能检索出名字未知的列。</p>
<h3 id="通配符使用技巧"><a href="#通配符使用技巧" class="headerlink" title="通配符使用技巧"></a>通配符使用技巧</h3><p>原则，能不用则不用（影响性能）。</p>
<ul>
<li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li>
<li>在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。</li>
<li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</li>
</ul>
<hr>
<h1 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h1><p><strong>不能部分使用 DISTINCT</strong></p>
<p>DISTINCT 关键字作用于所有的列，不仅仅是跟在其后的那一列。例如， SELECT DISTINCT vend_id, prod_price，除非指定的两列完全相同，否则所有的行都会被检索出来。</p>
<hr>
<p><strong>求值顺序</strong></p>
<p>WHERE 子句可以包含任意数目的 AND 和 OR 操作符。允许两者结合以进行复杂、高级的过滤。但是，组合 AND 和 OR 会带来了一个有趣的问题。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">输入</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, prod_price </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> Products </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> vend_id = <span class="string">'DLL01'</span> <span class="keyword">OR</span> vend_id = <span class="string">'BRS01'</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"> <span class="keyword">AND</span> prod_price &gt;= <span class="number">10</span>; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">输出</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">prod_name prod_price </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">------------------- ---------- </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">Fish bean bag toy 3.4900 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">Bird bean bag toy 3.4900 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">Rabbit bean bag toy 3.4900 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">18 inch teddy bear 11.9900 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">Raggedy Ann 4.9900</span></pre></td></tr></table></figure>

<p>原因在于求值的顺序。SQL（像多数语言一样）在处理 OR 操作符前，<strong>优先处理 AND 操作符</strong>。</p>
<hr>
<p><strong>在 WHERE 子句中使用圆括号</strong> </p>
<blockquote>
<p>任何时候使用具有 AND 和 OR 操作符的 WHERE 子句，都应该使用圆括号明确地分组操作符。不要过分依赖默认求值顺序，即使它确实如你希望的那样。使用圆括号没有什么坏处，它能消除歧义。</p>
</blockquote>
<hr>
<p>IN 操作符等价于使用 or 操作符，为什么要使用 IN 操作符呢？</p>
<blockquote>
<ul>
<li><p>在有很多合法选项时，IN 操作符的语法更清楚，更直观。</p>
</li>
<li><p>在与其他 AND 和 OR 操作符组合使用 IN 时，求值顺序更容易管理。</p>
</li>
<li><p>IN 操作符一般比一组 OR 操作符执行得更快（在上面这个合法选项很少的例子中，你看不出性能差异）</p>
</li>
<li><p>IN 的最大优点是可以包含其他 SELECT 语句，能够更动态地建立 WHERE 子句。</p>
</li>
</ul>
</blockquote>
<hr>
<p>NOT 操作符等价于使用<code>&lt;&gt;</code> 操作符，为什么要使用 NOT 操作符呢？</p>
<blockquote>
<p>因为 NOT 和 IN 操作符联合使用效果更好。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,prod_name, prod_price </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> Products </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">NOT</span> <span class="keyword">IN</span>(<span class="string">'BRS01'</span>,<span class="string">'DLL01'</span>)</span></pre></td></tr></table></figure>
</blockquote>
<hr>
<p><strong>谓词（predicate）</strong></p>
<p>操作符何时不是操作符？答案是，它作为谓词时。从技术上说，LIKE 是谓词而不是操作符。虽然最终的结果是相同的，但应该对此术语有所了解，以免在 SQL 文献或手册中遇到此术语时不知所云。</p>
<hr>
<p><strong>别名的使用</strong></p>
<p>别名的名字既可以是一个单词，也可以是一个字符串。如果是后者，字符串应该括在引号中。虽然这种做法是合法的，但不建议这么去做。多单词的名字可读性高，不过会给客户端应用带来各种问题。因此，别名最常见的使用是将多个单词的列名重命名为一个单词的名字。</p>
<hr>
<h1 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h1><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LEFT()（或使用子字符串函数）</td>
<td>返回字符串左边的字符</td>
</tr>
<tr>
<td>LENGTH()（也使用DATALENGTH()或LEN()）</td>
<td>返回字符串的长度</td>
</tr>
<tr>
<td>LOWER()（Access使用LCASE()）</td>
<td>将字符串转换为小写</td>
</tr>
<tr>
<td>LTRIM()</td>
<td>去掉字符串左边的空格</td>
</tr>
<tr>
<td>RIGHT()（或使用子字符串函数）</td>
<td>返回字符串右边的字符</td>
</tr>
<tr>
<td>RTRIM()</td>
<td>去掉字符串右边的空格</td>
</tr>
<tr>
<td>SOUNDEX()</td>
<td>返回字符串的SOUNDEX值</td>
</tr>
<tr>
<td>UPPER()</td>
<td>将字符串转换为大写</td>
</tr>
</tbody></table>
<h1 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h1><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AVG()</td>
<td>平均值</td>
</tr>
<tr>
<td>COUNT()</td>
<td>返回某列的行数</td>
</tr>
<tr>
<td>MAX()</td>
<td>返回某列的最大值</td>
</tr>
<tr>
<td>MIN()</td>
<td>返回某列的最小值</td>
</tr>
<tr>
<td>SUM()</td>
<td>返回某列值之和</td>
</tr>
</tbody></table>
<p><strong>MAX() ，对非数值数据使用 MAX()</strong> </p>
<p>虽然 MAX()一般用来找出最大的数值或日期值，但许多（并非所有）DBMS 允许将它用来返回任意列中的最大值，包括返回文本列中的最大值。在用于文本数据时，MAX()返回按该列排序后的最后一行。</p>
<hr>
<p><strong>MIN()，对非数值数据使用 MIN()</strong></p>
<p>虽然 MIN()一般用来找出最小的数值或日期值，但许多（并非所有）DBMS 允许将它用来返回任意列中的最小值，包括返回文本列中的最小值。在用于文本数据时，MIN()返回该列排序后最前面的行。</p>
<hr>
<p><strong>SUM()</strong></p>
<p>SUM() 也可以用来合计计算值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(item_price*quantity) <span class="keyword">AS</span> total_price </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> OrderItems </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> order_num = <span class="number">20005</span>;</span></pre></td></tr></table></figure>

<hr>
<p><strong>DISTINCT 不能用于 COUNT(*)</strong></p>
<blockquote>
<p>如果指定列名，则 DISTINCT 只能用于 COUNT()。DISTINCT 不能用于 COUNT(*)。类似地，DISTINCT 必须使用列名，不能用于计算或表达式。</p>
</blockquote>
<h2 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h2><p><strong>GROUP BY 使用规范</strong></p>
<ul>
<li><p>GROUP BY 子句可以包含任意数目的列，因而可以对分组进行嵌套，更细致地进行数据分组。</p>
</li>
<li><p>如果在 GROUP BY 子句中嵌套了分组，数据将在最后指定的分组上进行汇总。</p>
</li>
<li><p>GROUP BY 子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在 SELECT 中使用表达式，则必须在 GROUP BY 子句中指定相同的表达式。不能使用别名。</p>
</li>
<li><p>大多数 SQL 实现不允许 GROUP BY 列带有长度可变的数据类型（如文本或备注型字段）。</p>
</li>
<li><p>除聚集计算语句外，SELECT 语句中的每一列都必须在 GROUP BY 子句中给出。</p>
</li>
<li><p>如果分组列中包含具有 NULL 值的行，则 NULL 将作为一个分组返回。如果列中有多行 NULL 值，它们将分为一组。</p>
</li>
<li><p>GROUP BY 子句必须出现在 WHERE 子句之后，ORDER BY 子句之前。</p>
</li>
</ul>
<h2 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h2><p>HAVING 非常类似于 WHERE，所有类型的 WHERE 子句都可以用 HAVING 来替代。唯一的差别是，WHERE 过滤行，而 HAVING 过滤分组。</p>
<p>分组和排序（GROUP BY &amp; ORDER BY）</p>
<table>
<thead>
<tr>
<th>ORDER BY</th>
<th>GROUP BY</th>
</tr>
</thead>
<tbody><tr>
<td>对产生的输出排序</td>
<td>对行分组，但输出可能不是分组的顺序</td>
</tr>
<tr>
<td>任意列都可以使用（甚至非选择的列也可以使用）</td>
<td>只可能使用选择列或表达式列，而且必须使用每个选择列表达式</td>
</tr>
<tr>
<td>不一定需要</td>
<td>如果与聚集函数一起使用列（或表达式），则必须使用</td>
</tr>
</tbody></table>
<p><strong>不要忘记 ORDER BY</strong> </p>
<p>一般在使用 GROUP BY 子句时，应该也给出 ORDER BY 子句。这是保证数据正确排序的唯一方法。千万不要仅依赖 GROUP BY 排序数据。</p>
<hr>
<p><strong>子查询和性能</strong> </p>
<p>不过在实际使用时由于性能的限制，不能嵌套太多的子查询。</p>
<hr>
<p><strong>关系数据库</strong></p>
<p>关系表的设计就是要把信息分解成多个表，一类数据一个表。各表通过某些共同的值互相关联。</p>
<p><strong>笛卡儿积（cartesian product）</strong> </p>
<blockquote>
<p>由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。</p>
</blockquote>
<hr>
<p><strong>外联结的类型</strong></p>
<p>左外联结和右外联结。它们之间的唯一差别是所关联的表的顺序。</p>
<p>全外联结包含两个表的不关联的行。</p>
<hr>
<p><strong>复合查询（union）</strong></p>
<ul>
<li><p>在一个查询中从不同的表返回结构数据；</p>
</li>
<li><p>对一个表执行多个查询，按一个查询返回数据。</p>
</li>
</ul>
<p><strong>包含或取消重复的行</strong></p>
<p>UNION 默认从查询结果集中自动去除了重复的行；</p>
<p>UNION ALL 取消重复行；</p>
<p><strong>复合查询（union）使用规则</strong></p>
<ul>
<li>UNION 由两条或两条以上的 SELECT 语句组成，语句之间用关键字UNION分隔</li>
<li>UNION 中每个查询必须包含相同的列、表达式或聚集函数（不要求相同的顺序）</li>
<li>列数据类型必须兼容：类型不必完全相同，但必须是 DBMS 可以隐含转换的类型</li>
</ul>
<p><strong>对组合查询结果排序</strong></p>
<p>在用 UNION 组合查询时，只能使用一条 ORDER BY 子句，它必须位于最后一条 SELECT 语句之后。实际上 DBMS 将用它来排序所有 SELECT 语句返回的所有结果。UNION 操作多个表</p>
<p><strong>UNION 操作多个表</strong></p>
<p>UNION 在需要组合多个表的数据时也很有用，即使是有不匹配列名的表，在这种情况下，可以将 UNION 与别名组合，检索一个结果集。</p>
<hr>
<p><strong>INSERT</strong></p>
<p>如果表的定义允许，则可以在 INSERT 操作中省略某些列。省略的列必须满足以下某个条件。</p>
<ul>
<li>该列定义为允许 NULL 值（无值或空值）。</li>
<li>在表定义中给出默认值。这表示如果不给出值，将使用默认值。</li>
</ul>
<p>如果表中不允许有 NULL 值或者默认值，这时却省略了表中的值，DBMS 就会产生错误消息，相应的行不能成功插入。</p>
<p><strong>INSERT SELECT 中的列名</strong></p>
<p>在 INSERT 和 SELECT 语句中使用了相同的列名。但是，不一定要求列名匹配。事实上，DBMS 一点儿也不关心 SELECT 返回的列名。它使用的是列的位置，因此 SELECT 中的第一列（不管其列名）将用来填充表列中指定的第一列，第二列将用来填充表列中指定的第二列，如此等等。</p>
<p><strong>从一个表复制到另一个表（SELECT INTO ）</strong></p>
<p>INSERT SELECT 与 SELECT INTO</p>
<p>它们之间的一个重要差别是前者导出数据，而后者导入数据。</p>
<p><strong>使用 SELECT INTO</strong></p>
<ul>
<li><p>任何 SELECT 选项和子句都可以使用，包括 WHERE 和 GROUP BY；</p>
</li>
<li><p>可利用联结从多个表插入数据；</p>
</li>
<li><p>不管从多少个表中检索数据，数据都只能插入到一个表中。</p>
</li>
</ul>
<hr>
<p><strong>UPDATE</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Customers</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> cust_email = <span class="string">'kim@thetoystore.com'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> cust_id = <span class="string">'1000000005'</span>;</span></pre></td></tr></table></figure>

<p><strong>DELETE</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Customers </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> cust_id = <span class="string">'1000000006'</span>;</span></pre></td></tr></table></figure>

<p>提示：FROM 关键字</p>
<blockquote>
<p>DELETE 后的关键字 FROM 是可选的。但是即使不需要，考虑到移植性，最好提供这个关键字。</p>
</blockquote>
<p>提示：更快的删除 </p>
<blockquote>
<p>如果想从表中删除所有行，不要使用 DELETE。可使用 TRUNCATE TABLE 语句，它完成相同的工作，而速度更快（因为不记录数据的变动）。</p>
</blockquote>
<p>使用 UPDATE 或 DELETE 时所遵循的重要原则：</p>
<ul>
<li><p>除非确实打算更新和删除每一行，否则绝对不要使用不带 WHERE 子句的 UPDATE 或 DELETE 语句。</p>
</li>
<li><p>保证每个表都有主键尽可能像 WHERE 子句那样使用它（可以指定各主键、多个值或值的范围）。</p>
</li>
<li><p>在 UPDATE 或 DELETE 语句使用 WHERE 子句前，应该先用 SELECT 进行测试，保证它过滤的是正确的记录，以防编写的 WHERE 子句不正确。</p>
</li>
<li><p>使用强制实施引用完整性的数据库这样 DBMS 将不允许删除其数据与其他表相关联的行。</p>
</li>
<li><p>有的 DBMS 允许数据库管理员施加约束，防止执行不带 WHERE 子句的 UPDATE 或 DELETE 语句。如果所采用的 DBMS 支持这个特性，应该使用它。</p>
</li>
</ul>
<hr>
<p><strong>视图使用规则和限制</strong></p>
<ul>
<li><p>与表一样，视图必须唯一命名</p>
</li>
<li><p>对于可以创建的视图数目没有限制。</p>
</li>
<li><p>创建视图，必须具有足够的访问权限。</p>
</li>
<li><p>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造视图。</p>
</li>
<li><p>许多 DBMS 禁止在视图查询中使用 ORDER BY 子句。</p>
</li>
<li><p>有些 DBMS 要求对返回的所有列进行命名，如果列是计算字段，则需要使用别名</p>
</li>
<li><p>视图不能索引，也不能有关联的触发器或默认值。</p>
</li>
<li><p>有些 DBMS 把视图作为只读的查询，这表示可以从视图检索数据，但不能将数据写回底层表。</p>
</li>
</ul>
<p><strong>WHERE 子句与 WHERE 子句</strong></p>
<p>从视图检索数据时如果使用了一条 WHERE 子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。</p>
<hr>
<p><strong>存储过程的优劣</strong></p>
<p>优势：简单、安全、高性能</p>
<p>劣势：不可移植</p>
<hr>
<p><strong>游标的特性</strong></p>
<ul>
<li><p>能够标记游标为只读，使数据能读取，但不能更新和删除。</p>
</li>
<li><p>能控制可以执行的定向操作（向前、向后、第一、最后、绝对位置、相对位置等）。</p>
</li>
<li><p>能标记某些列为可编辑的，某些列为不可编辑的。</p>
</li>
<li><p>规定范围，使游标对创建它的特定请求（如存储过程）或对所有请求可访问。</p>
</li>
<li><p>指示 DBMS 对检索出的数据（而不是指出表中活动数据）进行复制，使数据在游标打开和访问期间不变化。</p>
</li>
</ul>
<p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p>
<hr>
<p><strong>使用索引</strong></p>
<ul>
<li><p>索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。在执行这些操作时，DBMS 必须动态地更新索引。</p>
</li>
<li><p>索引数据可能要占用大量的存储空间。</p>
</li>
<li><p>并非所有数据都适合做索引。</p>
</li>
<li><p>索引用于数据过滤和数据排序。</p>
</li>
<li><p>可以在索引中定义多个列.</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> prod_name_ind </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">ON</span> Products (prod_name);</span></pre></td></tr></table></figure>

<p>索引必须唯一命名。这里的索引名 prod_name_ind 在关键字 CREATE INDEX 之后定义。ON 用来指定被索引的表，而索引中包含的列（此例中仅有一列）在表名后的圆括号中给出。</p>
<p><strong>提示：检查索引</strong></p>
<blockquote>
<p>索引的效率随表数据的增加或改变而变化。许多数据库管理员发现，过去创建的某个理想的索引经过几个月的数据处理后可能变得不再理想了。最好定期检查索引，并根据需要对索引进行调整。</p>
</blockquote>
<hr>
<p><strong>触发器内的代码具有以下数据的访问权：</strong></p>
<ul>
<li><p>INSERT 操作中的所有新数据；</p>
</li>
<li><p>UPDATE 操作中的所有新数据和旧数据；</p>
</li>
<li><p>DELETE 操作中删除的数据。</p>
</li>
</ul>
<p><strong>提示：约束比触发器更快</strong></p>
<blockquote>
<p>一般来说，约束的处理比触发器快，因此在可能的时候，应该尽量使用约束。</p>
</blockquote>
<hr>
<p><strong>安全性</strong></p>
<p>安全性使用 SQL 的 GRANT 和 REVOKE 语句来管理</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/SQL/" rel="tag"># SQL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/06/02/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/" rel="prev" title="MySQL基础篇：一条SQL查询语句执行过程">
      <i class="fa fa-chevron-left"></i> MySQL基础篇：一条SQL查询语句执行过程
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/06/09/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/" rel="next" title="MySQL基础篇：一条SQL更新语句执行过程">
      MySQL基础篇：一条SQL更新语句执行过程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL-基础"><span class="nav-number">1.</span> <span class="nav-text">SQL 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#主键设计规范"><span class="nav-number">1.1.</span> <span class="nav-text">主键设计规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串数据类型"><span class="nav-number">1.2.</span> <span class="nav-text">字符串数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通配符的使用"><span class="nav-number">1.3.</span> <span class="nav-text">通配符的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#检索未知列"><span class="nav-number">1.3.1.</span> <span class="nav-text">检索未知列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通配符使用技巧"><span class="nav-number">1.3.2.</span> <span class="nav-text">通配符使用技巧</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#检索数据"><span class="nav-number">2.</span> <span class="nav-text">检索数据</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文本处理函数"><span class="nav-number">3.</span> <span class="nav-text">文本处理函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#聚集函数"><span class="nav-number">4.</span> <span class="nav-text">聚集函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分组数据"><span class="nav-number">4.1.</span> <span class="nav-text">分组数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过滤分组"><span class="nav-number">4.2.</span> <span class="nav-text">过滤分组</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">mofei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mofei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.1.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
