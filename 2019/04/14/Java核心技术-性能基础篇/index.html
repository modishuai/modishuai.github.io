<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="性能调优工具、方法、基础  后台服务运行”变慢”，诊断思路？诊断问题 服务是突然变慢还是长时间运行后变慢？类似问题是否重复出现？  “慢” 的定义是什么？可以理解为系统对其他方面的请求反应延时变长吗？  对于分布式系统和大型单体应用有着不同的诊断思路？   对症下药对于分布式系统的诊断主要还是借助于系统日志、性能监控系统，Java 诊断工具 JFR（Java Flight Recorder），监">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 核心技术-性能基础篇">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;04&#x2F;14&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87&#x2F;index.html">
<meta property="og:site_name" content="莫非的技术笔记">
<meta property="og:description" content="性能调优工具、方法、基础  后台服务运行”变慢”，诊断思路？诊断问题 服务是突然变慢还是长时间运行后变慢？类似问题是否重复出现？  “慢” 的定义是什么？可以理解为系统对其他方面的请求反应延时变长吗？  对于分布式系统和大型单体应用有着不同的诊断思路？   对症下药对于分布式系统的诊断主要还是借助于系统日志、性能监控系统，Java 诊断工具 JFR（Java Flight Recorder），监">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;04&#x2F;14&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87&#x2F;top.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;04&#x2F;14&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87&#x2F;JMH.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;04&#x2F;14&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87&#x2F;Java生命周期.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;04&#x2F;14&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87&#x2F;JVM运行时优化.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;04&#x2F;14&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87&#x2F;SpringBean生命周期.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;04&#x2F;14&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87&#x2F;SpringAdvice.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;04&#x2F;14&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87&#x2F;AOP流程图.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;04&#x2F;14&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87&#x2F;Snowflake.png">
<meta property="article:published_time" content="2019-04-14T09:00:00.000Z">
<meta property="article:modified_time" content="2019-12-10T11:58:35.852Z">
<meta property="article:author" content="mofei">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="性能调优">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;04&#x2F;14&#x2F;Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87&#x2F;top.png">

<link rel="canonical" href="http://yoursite.com/2019/04/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Java 核心技术-性能基础篇 | 莫非的技术笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">莫非的技术笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mofei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫非的技术笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 核心技术-性能基础篇
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-14 17:00:00" itemprop="dateCreated datePublished" datetime="2019-04-14T17:00:00+08:00">2019-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-10 19:58:35" itemprop="dateModified" datetime="2019-12-10T19:58:35+08:00">2019-12-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">后端笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>性能调优工具、方法、基础</p>
</blockquote>
<h1 id="后台服务运行”变慢”，诊断思路？"><a href="#后台服务运行”变慢”，诊断思路？" class="headerlink" title="后台服务运行”变慢”，诊断思路？"></a>后台服务运行”变慢”，诊断思路？</h1><h2 id="诊断问题"><a href="#诊断问题" class="headerlink" title="诊断问题"></a>诊断问题</h2><ul>
<li><p>服务是突然变慢还是长时间运行后变慢？类似问题是否重复出现？</p>
</li>
<li><p>“慢” 的定义是什么？可以理解为系统对其他方面的请求反应延时变长吗？</p>
</li>
<li><p>对于分布式系统和大型单体应用有着不同的诊断思路？</p>
</li>
</ul>
<h2 id="对症下药"><a href="#对症下药" class="headerlink" title="对症下药"></a>对症下药</h2><p>对于分布式系统的诊断主要还是借助于<strong>系统日志、性能监控系统</strong>，<strong>Java 诊断工具 JFR（Java Flight Recorder）</strong>，监控应用是否出现某种类型异常。如果没有异常，还可以查看系统级别资源，监控 CPU 、内存等；</p>
<p>监控 Java 服务自身，例如 GC 日志里面是否观察到 Full GC 等恶劣情况出现，或者是否 Minor GC 在变长等；利用 jstat 工具，获取内存使用的统计信息；利用 jstack 工具检查死锁情况；</p>
<h2 id="性能分析方法论"><a href="#性能分析方法论" class="headerlink" title="性能分析方法论"></a>性能分析方法论</h2><ul>
<li><p>自上而下，从应用顶层，逐步深入到具体的不同模块，找到问题和解决办法。</p>
</li>
<li><p>自下而上，从硬件底层，类似 CPU 判断 Cache-Miss 之类的问题和调优机会，出发点是指令级别优化。（专业的性能工程师）</p>
</li>
</ul>
<h3 id="自上而下的分析思路和应用工具"><a href="#自上而下的分析思路和应用工具" class="headerlink" title="自上而下的分析思路和应用工具"></a>自上而下的分析思路和应用工具</h3><h4 id="系统性能分析"><a href="#系统性能分析" class="headerlink" title="系统性能分析"></a>系统性能分析</h4><p>系统性能分析中主要关注 <strong>CPU</strong>、<strong>内存</strong>、<strong>IO</strong> </p>
<p>Linux 系统中先用 top命令查看 CPU 负载情况。</p>
<p><img src="/2019/04/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87/top.png" alt="top"></p>
<p>可以看到 load average（平均负载）三个值（1分钟，5分钟，15分钟）非常低，暂时没有升高迹象。如果数值非常高，并且短期平均值高于长期平均值，则表明负载很重；</p>
<p>利用 top 命令获取相应 pid，“H” 表示 thread 模式，可以配合 grep 命令精准定位。</p>
<p><code>top h</code></p>
<p>然后转成 16 进制</p>
<p>printf “%x” your_pid</p>
<p>利用 jstack 获取线程栈，对比相应的 ID</p>
<p>更加通用的诊断方向利用 vmstat 之类，查看上下文切换数量，比如指定时间间隔为 1 收集 10 次</p>
<p><code>vmstat -1 -10</code></p>
<p>除了 CPU，内存和 IO 是重要的注意事项，比如：</p>
<ul>
<li>利用 free 之类查看内存使用。</li>
<li>或者，进一步判断 swap 使用情况，top 命令输出中 Virt 作为虚拟内存使用量，就是物理内存（Res）和 swap 求和，所以可以反推 swap 使用。显然，JVM 是不希望发生大量的 swap 使用的。</li>
<li>对于 IO 问题，既可能发生在磁盘 IO，也可能是网络 IO。例如，利用 iostat 等命令有助于判断磁盘的健康状况。（dstat 命令用来替换 vmstat、iostat、netstat、nfsstat和ifstat这些命令的工具，是一个全能系统信息统计工具）</li>
</ul>
<h4 id="JVM-性能分析"><a href="#JVM-性能分析" class="headerlink" title="JVM 性能分析"></a>JVM 性能分析</h4><ul>
<li><p>JMC、JConsole 等工具进行运行时监控。</p>
</li>
<li><p>利用各种工具，在运行时进行堆转储分析，或者获取各种角度的统计数据（如 jstat -gcutil 分析 gc 、内存分带）</p>
</li>
<li><p>GC 日志等手段，诊断 Full GC、Minor GC，或者引用堆积等。</p>
</li>
</ul>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>Profiling 工具获取数据的主要方式有哪些？各有什么优缺点。</p>
<ul>
<li><p>事件方法：对于 Java，可以采用 JVMTI（JVM Tools Interface）API 来捕捉诸如方法调用、类载入、类卸载、进入 / 离开线程等事件，然后基于这些事件进行程序行为的分析。</p>
</li>
<li><p>统计抽样方法（sampling）: 该方法每隔一段时间调用系统中断，然后收集当前的调用栈（call stack）信息，记录调用栈中出现的函数及这些函数的调用结构，基于这些信息得到函数的调用关系图及每个函数的 CPU 使用信息。由于调用栈的信息是每隔一段时间来获取的，因此不是非常精确的，但由于该方法对目标程序的干涉比较少，目标程序的运行速度几乎不受影响。</p>
</li>
<li><p>植入附加指令方法（BCI）: 该方法在目标程序中插入指令代码，这些指令代码将记录 profiling 所需的信息，包括运行时间、计数器的值等，从而给出一个较为精确的内存使用情况、函数调用关系及函数的 CPU 使用信息。该方法对程序执行速度会有一定的影响，因此给出的程序执行时间有可能不准确。但是该方法在统计程序的运行轨迹方面有一定的优势。</p>
</li>
</ul>
<h1 id="Lambda-真的能让Java程序变慢吗？"><a href="#Lambda-真的能让Java程序变慢吗？" class="headerlink" title="Lambda 真的能让Java程序变慢吗？"></a>Lambda 真的能让Java程序变慢吗？</h1><p><strong>使用基准测试判断应用表现的性能必须明确定义自身的范围和目标，否则有可能产生误导的结果。</strong></p>
<h2 id="Lambda-Stream-局限性"><a href="#Lambda-Stream-局限性" class="headerlink" title="Lambda/Stream 局限性"></a>Lambda/Stream 局限性</h2><p>Lambda / Stream 提供了强大的函数式编程能力。</p>
<ul>
<li><p>Lambda / Stream 提供了与传统方式接近对等的性能，对于性能敏感的场景，就不能不关注它了。例如：<strong>初始化的开销，Lambda 并不算是语法糖，而是一种新的工作机制，在首次调用时，JVM 需要为其构建 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/CallSite.html" target="_blank" rel="noopener">CallSite</a> 实例。这意味着 Java 应用启动过程引入很多 Lambda 语句，会导致启动过程变慢。其实现特点决定了 JVM 对它的优化可能与传统方式存在差异。</strong></p>
</li>
<li><p>增加了程序诊断等方面的复杂性，程序栈复杂很多，Fluent 风格本身不算是对调试非常友好的结构，并且在检查异常的处理方面也存在局限性等。</p>
</li>
</ul>
<h2 id="如何利用主流框架构建简单的基准测试"><a href="#如何利用主流框架构建简单的基准测试" class="headerlink" title="如何利用主流框架构建简单的基准测试"></a>如何利用主流框架构建简单的基准测试</h2><h3 id="什么时候开发微基准测试？"><a href="#什么时候开发微基准测试？" class="headerlink" title="什么时候开发微基准测试？"></a>什么时候开发微基准测试？</h3><p>当需要对一个大型软件中的某一小部分的性能评估时，就可以开发微基准测试。</p>
<h3 id="微基准测试框架选型？"><a href="#微基准测试框架选型？" class="headerlink" title="微基准测试框架选型？"></a>微基准测试框架选型？</h3><p><a href="http://openjdk.java.net/projects/code-tools/jmh/" target="_blank" rel="noopener">JMH</a> 由 Hotspot JVM 团队专家开发，除了支持完整的基准测试过程，包括预热、运行、统计和报告等，还支持 Java 和其他 JVM 语言。它针对 Hotspot JVM 提供了各种特性，以保证基准测试的正确性，整体准确性优于其他框架。</p>
<p>Maven 工程</p>
<p><img src="/2019/04/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87/JMH.png" alt="JMH"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ mvn archetype:generate \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">          -DinteractiveMode=false \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">          -DarchetypeGroupId=org.openjdk.jmh \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">          -DarchetypeArtifactId=jmh-java-benchmark-archetype \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">          -DgroupId=org.sample \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">          -DartifactId=test \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">          -Dversion=<span class="number">1.0</span></span></pre></td></tr></table></figure>

<p>利用注解（Annotation）定义具体的测试方法，以及为基准测试详细配置。</p>
<p>示例：利用@Benchmark 标识基准测试方法，@BenchmarkMode 标识基准测试模式（如吞吐量、平局时间）等模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@BenchmarkMode</span>(Mode.Throughput)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   <span class="comment">// Put your benchmark code here.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>当实现具体的测试后，利用 Maven 命令构建</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mvn clean install</span></pre></td></tr></table></figure>

<p>运行基准测试</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">java -jar target/benchmarks.jar</span></pre></td></tr></table></figure>

<h2 id="如何保证基准测试的正确性。"><a href="#如何保证基准测试的正确性。" class="headerlink" title="如何保证基准测试的正确性。"></a>如何保证基准测试的正确性。</h2><p><a href="https://www.ibm.com/developerworks/java/library/j-jtp02225/" target="_blank" rel="noopener">微基准测试中的典型问题</a></p>
<ul>
<li>保证代码经过了足够并且合适的预热。默认情况，在 server 模式下，JIT 会在一段代码执行 10000 次后，将其编译为本地代码，client 模式则是 1500 次以后。我们需要排除代码执行初期的噪音，保证真正采样到的统计数据符合其稳定运行状态。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">-XX:+PrintCompilation</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">我这里建议考虑另外加上一个参数，否则 JVM 将默认开启后台编译，也就是在其他线程进行，可能导致输出的信息有些混淆。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">-Xbatch</span></pre></td></tr></table></figure>

<ul>
<li>防止 JVM 进行无效代码消除。例如下面的代码片段中，由于我们并没有使用计算结果 mul，那么 JVM 就可能直接判断无效代码，根本就不执行它</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">int</span> left = <span class="number">10</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">int</span> right = <span class="number">100</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">int</span> mul = left * right;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果你发现代码统计数据发生了数量级程度上的提高，需要警惕是否出现了无效代码消除的问题。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决办法也很直接，尽量保证方法有返回值，而不是 void 方法，或者使用 JMH 提供的</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(Blackhole blackhole)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">   <span class="comment">// …</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">   blackhole.consume(mul);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li>防止发生常量折叠。JVM 如果发现计算过程是依赖于常量或者事实上的常量，就可能会直接计算其结果，所以基准测试并不能真实反映代码执行的性能。JMH 提供了 State 机制来解决这个问题，将本地变量修改为 State 对象信息，请参考下面示例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span>(Scope.Thread)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyState</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> left = <span class="number">10</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> right = <span class="number">100</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(MyState state, Blackhole blackhole)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">int</span> left = state.left;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">int</span> right = state.right;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">int</span> mul = left * right;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">   blackhole.consume(mul);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li><p>另外 JMH 还会对 State 对象进行额外的处理，以尽量消除伪共享（<a href="https://blogs.oracle.com/dave/java-contended-annotation-to-help-reduce-false-sharing" target="_blank" rel="noopener">false-sharing</a>）的影响，标记 @State，JMH 会自动进行补齐。</p>
</li>
<li><p>如果你希望确定方法内联（Inlining）对性能的影响，可以考虑打开下面的选项。</p>
</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">-XX:+PrintInlining</span></pre></td></tr></table></figure>

<h2 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h2><h3 id="什么是常量折叠？"><a href="#什么是常量折叠？" class="headerlink" title="什么是常量折叠？"></a>什么是常量折叠？</h3><p>常量折叠是指 Java 在编译阶段做的一个优化，也就是说在编译阶段就把表达式计算好，不需要在运行时计算。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//折叠前</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mul = <span class="number">5</span> * <span class="number">5</span>; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//折叠后</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mul = <span class="number">25</span>;</span></pre></td></tr></table></figure>

<h1 id="JVM-优化-Java-代码都做了些什么？"><a href="#JVM-优化-Java-代码都做了些什么？" class="headerlink" title="JVM 优化 Java 代码都做了些什么？"></a>JVM 优化 Java 代码都做了些什么？</h1><p>JVM 对代码执行的优化分为：</p>
<ul>
<li><p>运行时（runtime）优化，主要是解释执行和动态编译通用的一些机制，比如锁机制（偏斜锁）、内存分配机制（TLAB），除此以外还有一些专门用于优化解释执行效率的，比如说模板解释器、内联缓存（inline cache，用于优化虚方法调用的动态绑定）。</p>
</li>
<li><p>即时编译器（JIT）优化，将热点代码以方法为单位转换成机器代码，直接运行在底层硬件之上。采用了多种优化方式，包括静态编译器可以使用的方法内联、逃逸分析、也包括基于程序运行 profile 的投机性优化（可以理解为，有一条 instanceof 指令，在编译之前的执行过程中，测试对象的类一直是同一个，那么即时编译器可以假设编译之后的执行过程还是这个类，并且根据这个类直接返回 instanceof 的结果。如果出现其他类，那就抛弃这段编译后的机器代码，并切换到解释执行）。</p>
</li>
</ul>
<p>Java 代码的生命周期</p>
<p><img src="/2019/04/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87/Java生命周期.png" alt="Java核心技术性能基础篇\Java 生命周期"></p>
<p>java 通过字节码屏蔽不同的硬件差异，JVM 负责完成字节码到机器码的转换。</p>
<p>javac 等编译器或者相关 API 等将源码转换成字节码的过程中也会进行少量类似常量折叠之类的优化。</p>
<p>javac 优化与 JVM 内部优化也存在关联，毕竟它负责字节码的生成。例如，Java 9 中的字符串拼接，会被 javac 替换成对 StringConcatFactory 的调用，进而为 JVM 进行字符串拼接优化提供了统一的入口。在实际场景中，还可以通过不同的<a href="http://openjdk.java.net/jeps/280" target="_blank" rel="noopener">策略</a>来干预这个过程。</p>
<h2 id="JVM-运行时优化"><a href="#JVM-运行时优化" class="headerlink" title="JVM 运行时优化"></a>JVM 运行时优化</h2><p><img src="/2019/04/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87/JVM运行时优化.png" alt="Java核心技术性能基础篇\JVM 运行时优化"></p>
<p>JVM 会根据统计信息，动态决定什么方法被编译，什么方法解释执行，即使是已经编译过的代码，也可能在不同的运行阶段不再是热点，JVM 有必要将这种代码从 Code Cache 中移除出去，毕竟其大小是有限的。</p>
<p><strong>即时编译（JIT），则是更多优化工作的承担者。JIT 对 Java 编译的基本单元是整个方法，通过对方法调用的计数统计，甄别出热点方法，编译为本地代码。</strong>另外一个优化场景，则是最针对所谓热点循环代码，利用通常说的栈上替换技术（OSR，On-Stack Replacement），如果方法本身的调用频度还不够编译标准，但是内部有大的循环之类，则还是会有进一步优化的价值。</p>
<p>从理论上来看，JIT 可以看作就是基于两个计数器实现，<strong>方法计数器和回边计数器</strong>提供给 JVM 统计数据，以定位到热点代码。实际中的 JIT 机制要复杂得多，逃逸分析、循环展开、方法内联等，包括前面提到的 Intrinsic 等通用机制同样会在 JIT 阶段发生。</p>
<h2 id="探查JVM-优化具体发生情况？"><a href="#探查JVM-优化具体发生情况？" class="headerlink" title="探查JVM 优化具体发生情况？"></a>探查JVM 优化具体发生情况？</h2><ul>
<li><p>打印编译发生细节 <code>-XX:+PrintCompilation</code></p>
</li>
<li><p>输出更多编译细节 <code>-XX:UnlockDiagnosticVMOptions -XX:+LogCompilation -XX:LogFile=&lt;your_file_path&gt;</code></p>
</li>
<li><p>打印内联的发生，可利用下面的诊断选项，也需要明确解锁。 <code>-XX:+PrintInlining</code></p>
</li>
<li><p>如何知晓 Code Cache 的使用状态呢？利用 JMC、JConsole 、NMT 等工具。</p>
</li>
</ul>
<h2 id="应用开发者的调优手段"><a href="#应用开发者的调优手段" class="headerlink" title="应用开发者的调优手段"></a>应用开发者的调优手段</h2><ul>
<li><p>调整热点代码门限值，<code>-XX:CompileThreshold=N</code>，server 模式默认 10000 次 ，client 模式默认 1500 次。</p>
</li>
<li><p>调整 Code Cache 大小，<code>-XX:ReservedCodeCacheSize=&lt;SIZE&gt;</code> 或调整其初始大小<code>-XX:InitialCodeCacheSize=&lt;SIZE&gt;</code></p>
</li>
<li><p>调整编译器线程数<code>-XX:CICompilerCount=N</code>，或选择适当的编译模式</p>
</li>
</ul>
<h2 id="知识补充-1"><a href="#知识补充-1" class="headerlink" title="知识补充"></a>知识补充</h2><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>参考维基百科<a href="https://en.wikipedia.org/wiki/Escape_analysis" target="_blank" rel="noopener">Escape_analysis</a></p>
<h3 id="循环开展"><a href="#循环开展" class="headerlink" title="循环开展"></a>循环开展</h3><p>参考维基百科<a href="https://en.wikipedia.org/wiki/Loop_unrolling" target="_blank" rel="noopener">Loop_unrolling</a></p>
<h1 id="MySQL-支持事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？"><a href="#MySQL-支持事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？" class="headerlink" title="MySQL 支持事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？"></a>MySQL 支持事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？</h1><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>MySQL InnoDB 引擎是基于 MVCC（Multi Versioning Concurrency Control） 和 锁的复合实现。按照隔离程度从低到高，MySQL 事务隔离级别分为四个不同层次。</p>
<ul>
<li><p>读未提交（Read uncommitted）允许脏读，也就是事务B能够看到事务A尚未提交的修改。</p>
</li>
<li><p>读已提交（Read committed），事务能够看到的数据都是其他事务已经提交的修改，保证不会看到任何中间性状态，允许不可重复读和幻象读。</p>
</li>
<li><p>可重复读（Repeatable reads），保证同一个事务中多次读取的数据是一致的，MySql InnoDB 默认的隔离级别。</p>
</li>
<li><p>串行化（Serializable），并发事务之间是串行化的，意味着读取需要获取共享读锁，更新需要获取排他写锁，如果 SQL 使用 WHERE 语句，还要获取区间锁（MySQL 以 GAP 锁形式实现，可重复读级别中默认也会使用）</p>
</li>
</ul>
<h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><p>主要的区别体现在操作共享数据时：“悲观锁”认为数据出现冲突可能性更大，“乐观锁”则认为大部分情况不会出现冲突，进而决定是否采用排他性措施。</p>
<p>反映到 MySQL 数据库应用中：</p>
<p>悲观锁一般是利用类是 SELECT …… FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。</p>
<p>乐观锁 与 Java 并发包中的 AtomicFieldUpdate 类是，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。</p>
<h2 id="重点掌握"><a href="#重点掌握" class="headerlink" title="重点掌握"></a>重点掌握</h2><ul>
<li>数据库设计基础，包括数据库设计中的几个基本范式，各种数据库的基础概念，例如表、视 图、索引、外键、序列号生成器等，清楚如何将现实中业务实体和其依赖关系映射到数据库结构中，掌握典型实体数据应该使用什么样的数据库数据类型等。</li>
<li>精通你使用过的数据库的设计要点。以 MySQL 为例进一步了解 MVCC、Locking 等机制对于处理进阶问题非常有帮助；还需要了解，不同索引类型的使用，甚至是底层数据结构和算法等。</li>
<li>常见的 SQL 语句，掌握基础的 SQL 调优技巧，至少要了解基本思路是怎样的，例如 SQL 怎 样写才能更好利用索引、知道如何分析SQL 执行计划等。</li>
<li>更进一步，至少需要了解针对高并发等特定场景中的解决方案，例如读写分离、分库分表，或 者如何利用缓存机制等，目前的数据存储也远不止传统的关系型数据库了。</li>
</ul>
<h2 id="开源框架学习指南"><a href="#开源框架学习指南" class="headerlink" title="开源框架学习指南"></a>开源框架学习指南</h2><ul>
<li>从整体上把握主流框架的架构和设计理念，掌握主要流程，例如 SQL 解析生成、SQL 执行到 结果映射等处理过程到底发生了什么。</li>
<li>掌握映射等部分的细节定义和原理，根据我在准备专栏时整理的面试题目，发现很多题目都是 偏向于映射定义的细节。</li>
<li>对比不同框架的设计和实现，既有利于你加深理解，也是面试考察的热点方向之一。</li>
</ul>
<h2 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h2><p>从架构设计的角度，可以将 MyBatis 分为哪几层？每层都有哪些主要模块？</p>
<p>mybatis 架构自下而上分为基础支撑层、数据处理层、API 接口层这三层。  </p>
<ul>
<li><p>基础支撑层：主要是用来做连接管理、事务管理、配置加载、缓存管理等最基础组件，为上层提供最基础的支撑。</p>
</li>
<li><p>数据处理层：主要是用来做参数映射、sql解析、sql执行、结果映射等处理，可以理解为请求到达，完成一次数据库操作的流程。</p>
</li>
<li><p>API 接口层：主要对外提供 API，提供诸如数据的增删改查、获取配置等接口。</p>
</li>
</ul>
<h1 id="Spring-生命周期和作用域？"><a href="#Spring-生命周期和作用域？" class="headerlink" title="Spring 生命周期和作用域？"></a>Spring 生命周期和作用域？</h1><h2 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h2><p><img src="/2019/04/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87/SpringBean生命周期.jpg" alt="Java核心技术性能基础篇\Spring Bean生命周期"></p>
<ol>
<li><p>Spring 对 bean 进行实例化。</p>
</li>
<li><p>Spring 将值和 bean 的引用注入到 bean 对应的属性中；</p>
</li>
<li><p>若 bean 实现了 BeanNameAware接口，Spring 将 Bean 的 ID 传递给 setBeanName() 方法。</p>
</li>
<li><p>若 bean 实现了 BeanFactoryAware 接口，Spring 将调用 setBeanFactory() 方法，将 BeanFactory 容器实例传入。</p>
</li>
<li><p>若 bean 实现了 ApplicationContextAware 接口，Spring 将调用 setApplicationContext() 方法，将 bean 所在的应用上下文的引用传入进来。</p>
</li>
<li><p>若 bean 实现了 BeanPostProcessor 接口，Spring 将调用 postProcessBeforeInitialization() 方法；</p>
</li>
<li><p>若 bean 实现了 InitializingBean 接口，Spring 将调用 afterPropertiesSet() 方法。类似的，若 bean 使用 init-method 声明了初始化方法，该方法也会调用；</p>
</li>
<li><p>若 bean 实现了 BeanPostProcessor 接口，Spring 将调用 postProcessAfterInitialization() 方法；</p>
</li>
<li><p>bean 准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到应用上下文被销毁；</p>
</li>
<li><p>若 bean 实现了 DisposableBean 接口，Spring 将调用 destory() 方法。类似的若 bean 使用 destory-method 声明了销毁方法，该方法也会被调用。</p>
</li>
</ol>
<h2 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h2><ul>
<li><p>单例（Singleton）默认选项，Spring 容器只创建一个实例。</p>
</li>
<li><p>原型（Prototype）每次注入或通过 Spring 上下文获取 bean 时候，都会创建一个 bean 实例。</p>
</li>
<li><p>会话（Session）Web 应用中使用，为每个会话创建一个 bean  实例。</p>
</li>
<li><p>请求（Request）Web 应用中使用，为每个请求创建一个 bean 实例。</p>
</li>
<li><p>全局（GlobalSession）用于 Portlet 容器，每个Portlet 有单独的 Session ，GlobalSession 提供一个全局的 HTTP Session.</p>
</li>
</ul>
<h2 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h2><p>控制反转（Inversion of Control）也称为依赖注入（Dependency Injection），主要作用就是解耦合。</p>
<ul>
<li><p>高层次模块不应该依赖低层次模块，他们应该依赖于一种抽象。</p>
</li>
<li><p>这种抽象不应该依赖细节，细节应该依赖于抽象</p>
</li>
</ul>
<h2 id="切面编程"><a href="#切面编程" class="headerlink" title="切面编程"></a>切面编程</h2><p>切面编程AOP（Aspect Oriented Programming）,把遍布在应用各处的功能分离出来，让服务模块化</p>
<p>切面提供了取代继承和委托的另一种解决方案。</p>
<p><img src="/2019/04/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87/SpringAdvice.png" alt="Java核心技术性能基础篇\Spring Advice"></p>
<h3 id="通知（Advice）"><a href="#通知（Advice）" class="headerlink" title="通知（Advice）"></a>通知（Advice）</h3><p>Advice <strong>明确了切面编程中的什么</strong>，Spring AOP 提供 5 种类型通知</p>
<ul>
<li><p>Before（前置通知）在目标方法调用之前调用通知功能；</p>
</li>
<li><p>After（后置通知）在目标方法完成之后调用通知，不关心方法输出是什么；</p>
</li>
<li><p>After-returning（返回通知）在目标方法成功执行后调用通知；</p>
</li>
<li><p>After-throwing（异常通知）在目标方法抛出异常后调用通知；</p>
</li>
<li><p>Around（环绕通知）通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行的自定义行为；</p>
</li>
</ul>
<h3 id="连接点（join-point）"><a href="#连接点（join-point）" class="headerlink" title="连接点（join point）"></a>连接点（join point）</h3><p><strong>join point 明确了切面编程中的目标。</strong></p>
<h3 id="切点（Ponitcut）"><a href="#切点（Ponitcut）" class="headerlink" title="切点（Ponitcut）"></a>切点（Ponitcut）</h3><p><strong>pointcut 明确了切面编程中的目标何处。</strong></p>
<h3 id="切面（Aspect）"><a href="#切面（Aspect）" class="headerlink" title="切面（Aspect）:"></a>切面（Aspect）:</h3><p><strong>切面是 Advice 和 Ponitcut 的结合，明确了它是什么，在何时和何处完成其功能。</strong></p>
<h3 id="引入（Introduction）"><a href="#引入（Introduction）" class="headerlink" title="引入（Introduction）"></a>引入（Introduction）</h3><p><strong>引入允许我们想现有的类中添加新方法或属性。</strong></p>
<h3 id="织入（Weaving）"><a href="#织入（Weaving）" class="headerlink" title="织入（Weaving）"></a>织入（Weaving）</h3><p><strong>织入把切面应用到目标对象并创建新的代理对象的过程</strong>。</p>
<p><img src="/2019/04/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87/AOP流程图.jpg" alt="AOP流程图"></p>
<h1 id="对比Java标准NIO类库，Netty是如何实现更高性能的吗？"><a href="#对比Java标准NIO类库，Netty是如何实现更高性能的吗？" class="headerlink" title="对比Java标准NIO类库，Netty是如何实现更高性能的吗？"></a>对比Java标准NIO类库，Netty是如何实现更高性能的吗？</h1><ul>
<li><p>更加优雅的 Reactor 模式实现、灵活的线程模型、利用 EventLoop 等创新性的机制，可以非常高效地管理成百上千的 Channel。</p>
</li>
<li><p>充分利用了 Java 的 Zero-Copy 机制，并且从多种角度，“斤斤计较”般的降低内存分配和回收的开销。例如，使用池化的 Direct Buffer 等技术，在提高 IO 性能的同时，减少了对象的创建和销毁；利用反射等技术直接操纵 SelectionKey，使用数组而不是 Java 容器等。</p>
</li>
<li><p>使用更多本地代码。例如，直接利用 JNI 调用 Open SSL 等方式，获得比 Java 内建 SSL 引擎更好的性能。</p>
</li>
<li><p>在通信协议、序列化等其他角度的优化。</p>
</li>
</ul>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p>Netty 是一个异步且基于事件 Client/Server 的网络框架，目标是提供一种简单、快速构建网络应用的方式，通知保证高吞吐量、低延时、高可靠性。</p>
<p>Netty 的设计强调关注点分离（Separation Of Concerns，SOC），通过精巧设计的事件机制，将业务逻辑和无关技术逻辑进行隔离，并通过各种方便的抽象，一定程度上填补了了基础平台和业务开发之间的鸿沟，更有利于在应用开发中普及业界的最佳实践。</p>
<p><strong>Netty &gt; java.io + java.net</strong></p>
<p>在基础 NIO 之上，Netty 构建了更加易用、高性能的网络框架，广泛应用于互联网、游戏、电信等各种领域。</p>
<h2 id="思考题-2"><a href="#思考题-2" class="headerlink" title="思考题"></a>思考题</h2><p>Netty 的线程模型是什么样 的？</p>
<p>Netty采用Reactor线程模型。这里面主要有三种Reactor线程模型。分别是单线程模式、主从Reactor模式、多Reactor线程模式。其都可以通过初试和EventLoopGroup进行设置。其主要区别在于，单Reactor模式就是一个线程，既进程处理连接，也处理IO。类似于我们传统的OIO编程。主从Reactor模式，其实就是将监听连接和处理IO的分开在不同的线程完成。最后，主从Reactor线程模型，为了解决多Reactor模型下单一线程性能不足的问题。改为了一组线程池进行处理。官方默认的是采用这种主从Reactor模型。其线程数默认为CPU内核的2倍。</p>
<h1 id="分布式ID的设计方案？Snowflake是否受冬令时切换影响？"><a href="#分布式ID的设计方案？Snowflake是否受冬令时切换影响？" class="headerlink" title="分布式ID的设计方案？Snowflake是否受冬令时切换影响？"></a>分布式ID的设计方案？Snowflake是否受冬令时切换影响？</h1><h2 id="分布式-ID-的基本要求"><a href="#分布式-ID-的基本要求" class="headerlink" title="分布式 ID 的基本要求"></a>分布式 ID 的基本要求</h2><ul>
<li><p>全局唯一，区别于单点系统的唯一，全局是要求分布式系统内唯一。</p>
</li>
<li><p>有序性，通常都需要保证生成的 ID 是有序递增的。例如，在数据库存储等场景中，有序 ID 便于确定数据位置，往往更加高效。</p>
</li>
</ul>
<h2 id="分布式-ID-的设计方案"><a href="#分布式-ID-的设计方案" class="headerlink" title="分布式 ID 的设计方案"></a>分布式 ID 的设计方案</h2><ul>
<li><p>数据库自增序列，简单易用，其扩展性和可靠性存在很大的局限性。</p>
</li>
<li><p>Snowflake，TWitter 早起的开源的 Snowflake 实现，结构定义如下</p>
<p><img src="/2019/04/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87/Snowflake.png" alt="Snowflake"></p>
<p>整体长度为 64（1 + 41 + 10 + 12 = 64）适合 Java 中 long 类型存储。</p>
<p>头部是 1 位的正负标识位。</p>
<p>41 位时间戳，通常使用System.currentTimeMills()</p>
<p>10 位WorkerID，标准定义的是 5 位数据中心 + 5为机器ID，组成机器编号，便于区分不同的集群点。</p>
<p>12 位序列，是单位毫秒内可生成的序列号数据的理论极限。</p>
</li>
<li><p>Redis、Zookeeper、MongoDB 等中间件也都有各种唯一 ID 解决方案</p>
</li>
</ul>
<p>Snowflake 算法的 Java 实现，依赖 System.currentTimeMillis() ,它是返回当前时间和 1970 年 1 月 1 号 UTC 时间相差的毫秒数，这个跟夏冬时令没关系，所以不受起影响。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/" rel="tag"># 性能调优</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/04/07/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%AF%87/" rel="prev" title="Java 核心技术-安全基础篇">
      <i class="fa fa-chevron-left"></i> Java 核心技术-安全基础篇
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/04/14/%E6%9E%84%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAELECTRON%E5%BA%94%E7%94%A8/" rel="next" title="构建一个 Electron 应用">
      构建一个 Electron 应用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#后台服务运行”变慢”，诊断思路？"><span class="nav-number">1.</span> <span class="nav-text">后台服务运行”变慢”，诊断思路？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#诊断问题"><span class="nav-number">1.1.</span> <span class="nav-text">诊断问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对症下药"><span class="nav-number">1.2.</span> <span class="nav-text">对症下药</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能分析方法论"><span class="nav-number">1.3.</span> <span class="nav-text">性能分析方法论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自上而下的分析思路和应用工具"><span class="nav-number">1.3.1.</span> <span class="nav-text">自上而下的分析思路和应用工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#系统性能分析"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">系统性能分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM-性能分析"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">JVM 性能分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思考题"><span class="nav-number">1.4.</span> <span class="nav-text">思考题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lambda-真的能让Java程序变慢吗？"><span class="nav-number">2.</span> <span class="nav-text">Lambda 真的能让Java程序变慢吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda-Stream-局限性"><span class="nav-number">2.1.</span> <span class="nav-text">Lambda&#x2F;Stream 局限性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何利用主流框架构建简单的基准测试"><span class="nav-number">2.2.</span> <span class="nav-text">如何利用主流框架构建简单的基准测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么时候开发微基准测试？"><span class="nav-number">2.2.1.</span> <span class="nav-text">什么时候开发微基准测试？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#微基准测试框架选型？"><span class="nav-number">2.2.2.</span> <span class="nav-text">微基准测试框架选型？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何保证基准测试的正确性。"><span class="nav-number">2.3.</span> <span class="nav-text">如何保证基准测试的正确性。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#知识补充"><span class="nav-number">2.4.</span> <span class="nav-text">知识补充</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是常量折叠？"><span class="nav-number">2.4.1.</span> <span class="nav-text">什么是常量折叠？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM-优化-Java-代码都做了些什么？"><span class="nav-number">3.</span> <span class="nav-text">JVM 优化 Java 代码都做了些什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-运行时优化"><span class="nav-number">3.1.</span> <span class="nav-text">JVM 运行时优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#探查JVM-优化具体发生情况？"><span class="nav-number">3.2.</span> <span class="nav-text">探查JVM 优化具体发生情况？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用开发者的调优手段"><span class="nav-number">3.3.</span> <span class="nav-text">应用开发者的调优手段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#知识补充-1"><span class="nav-number">3.4.</span> <span class="nav-text">知识补充</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#逃逸分析"><span class="nav-number">3.4.1.</span> <span class="nav-text">逃逸分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环开展"><span class="nav-number">3.4.2.</span> <span class="nav-text">循环开展</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-支持事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？"><span class="nav-number">4.</span> <span class="nav-text">MySQL 支持事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#隔离级别"><span class="nav-number">4.1.</span> <span class="nav-text">隔离级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#悲观锁和乐观锁"><span class="nav-number">4.2.</span> <span class="nav-text">悲观锁和乐观锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点掌握"><span class="nav-number">4.3.</span> <span class="nav-text">重点掌握</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开源框架学习指南"><span class="nav-number">4.4.</span> <span class="nav-text">开源框架学习指南</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思考题-1"><span class="nav-number">4.5.</span> <span class="nav-text">思考题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-生命周期和作用域？"><span class="nav-number">5.</span> <span class="nav-text">Spring 生命周期和作用域？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean-的生命周期"><span class="nav-number">5.1.</span> <span class="nav-text">Bean 的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean-的作用域"><span class="nav-number">5.2.</span> <span class="nav-text">Bean 的作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制反转"><span class="nav-number">5.3.</span> <span class="nav-text">控制反转</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#切面编程"><span class="nav-number">5.4.</span> <span class="nav-text">切面编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通知（Advice）"><span class="nav-number">5.4.1.</span> <span class="nav-text">通知（Advice）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接点（join-point）"><span class="nav-number">5.4.2.</span> <span class="nav-text">连接点（join point）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#切点（Ponitcut）"><span class="nav-number">5.4.3.</span> <span class="nav-text">切点（Ponitcut）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#切面（Aspect）"><span class="nav-number">5.4.4.</span> <span class="nav-text">切面（Aspect）:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引入（Introduction）"><span class="nav-number">5.4.5.</span> <span class="nav-text">引入（Introduction）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#织入（Weaving）"><span class="nav-number">5.4.6.</span> <span class="nav-text">织入（Weaving）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对比Java标准NIO类库，Netty是如何实现更高性能的吗？"><span class="nav-number">6.</span> <span class="nav-text">对比Java标准NIO类库，Netty是如何实现更高性能的吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Netty"><span class="nav-number">6.1.</span> <span class="nav-text">Netty</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思考题-2"><span class="nav-number">6.2.</span> <span class="nav-text">思考题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分布式ID的设计方案？Snowflake是否受冬令时切换影响？"><span class="nav-number">7.</span> <span class="nav-text">分布式ID的设计方案？Snowflake是否受冬令时切换影响？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式-ID-的基本要求"><span class="nav-number">7.1.</span> <span class="nav-text">分布式 ID 的基本要求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式-ID-的设计方案"><span class="nav-number">7.2.</span> <span class="nav-text">分布式 ID 的设计方案</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">mofei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mofei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.1.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
