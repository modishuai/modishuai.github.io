<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="莫非的技术笔记">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="莫非的技术笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="mofei">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>莫非的技术笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">莫非的技术笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/14/%E6%9E%84%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAELECTRON%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mofei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫非的技术笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/14/%E6%9E%84%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAELECTRON%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">构建一个 Electron 应用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-14 17:10:00" itemprop="dateCreated datePublished" datetime="2019-04-14T17:10:00+08:00">2019-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-10 20:00:16" itemprop="dateModified" datetime="2019-12-10T20:00:16+08:00">2019-12-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">前端笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>准备环境、开发、运行、打包、安装应用</p>
</blockquote>
<h1 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h1><p>Electron 依赖 Node.js 和 Chromium；</p>
<p>下载并安装<a href="[https://nodejs.org/en/](https://nodejs.org/en/"> Node.js</a> </p>
<h2 id="淘宝NPM镜像"><a href="#淘宝NPM镜像" class="headerlink" title="淘宝NPM镜像"></a>淘宝NPM镜像</h2><p>使用淘宝定制的<a href="https://github.com/cnpm/cnpm" target="_blank" rel="noopener">cnpm</a>(gzip 压缩支持) 命令行工具代替默认的<code>npm</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span></pre></td></tr></table></figure>

<h1 id="构建-Electron-应用"><a href="#构建-Electron-应用" class="headerlink" title="构建 Electron 应用"></a>构建 Electron 应用</h1><h2 id="初始化项目目录"><a href="#初始化项目目录" class="headerlink" title="初始化项目目录"></a>初始化项目目录</h2><p>一、新建项目文件目录</p>
<p>二、进入项目目录在命令行工具中打开，执行<code>cnpm init</code></p>
<p>三、在项目目录中 npm 会自动帮你创建 package.json 文件。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"name"</span>: <span class="string">"hello"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"description"</span>: <span class="string">"first electron app"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"main"</span>: <span class="string">"main.js"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"scripts"</span>: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"start"</span>: <span class="string">"electron ."</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"author"</span>: <span class="string">"mofei"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>注意：</strong>main 字段表示应用的启动脚本，若 main 字段不存在 Electron 则加载 index.js 脚本</p>
<h2 id="安装-Electron"><a href="#安装-Electron" class="headerlink" title="安装 Electron"></a>安装 Electron</h2><p>在项目中安装（首选）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cnpm install --save-dev electron</span></pre></td></tr></table></figure>

<p>全局安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cnpm install electron -g</span></pre></td></tr></table></figure>

<h2 id="Hello-Electron"><a href="#Hello-Electron" class="headerlink" title="Hello Electron"></a>Hello Electron</h2><p>创建 main.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; app, BrowserWindow &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保持对window对象的全局引用，如果不这么做的话，当JavaScript对象被</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 垃圾回收的时候，window对象将会自动的关闭</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> win</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 创建浏览器窗口。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  win = <span class="keyword">new</span> BrowserWindow(&#123; <span class="attr">width</span>: <span class="number">800</span>, <span class="attr">height</span>: <span class="number">600</span> &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 然后加载应用的 index.html。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  win.loadFile(<span class="string">'index.html'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 打开开发者工具</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  win.webContents.openDevTools()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 当 window 被关闭，这个事件会被触发。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  win.on(<span class="string">'closed'</span>, () =&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 取消引用 window 对象，如果你的应用支持多窗口的话，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 通常会把多个 window 对象存放在一个数组里面，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 与此同时，你应该删除相应的元素。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    win = <span class="literal">null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Electron 会在初始化后并准备</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建浏览器窗口时，调用这个函数。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 部分 API 在 ready 事件触发后才能使用。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">app.on(<span class="string">'ready'</span>, createWindow)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当全部窗口关闭时退出。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">app.on(<span class="string">'window-all-closed'</span>, () =&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 在 macOS 上，除非用户用 Cmd + Q 确定地退出，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 否则绝大部分应用及其菜单栏会保持激活。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (process.platform !== <span class="string">'darwin'</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    app.quit()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">app.on(<span class="string">'activate'</span>, () =&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 在macOS上，当单击dock图标并且没有其他窗口打开时，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 通常在应用程序中重新创建一个窗口。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (win === <span class="literal">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    createWindow()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这个文件中，你可以续写应用剩下主进程代码。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也可以拆分成几个文件，然后用 require 导入。</span></span></pre></td></tr></table></figure>

<p>创建 index.html</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  &lt;head&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &lt;title&gt;Hello Electron!&lt;&#x2F;title&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &lt;&#x2F;head&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  &lt;body&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &lt;h1&gt;Hello Electron!&lt;&#x2F;h1&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &lt;&#x2F;body&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;html&gt;</span></pre></td></tr></table></figure>

<p>启动应用，在项目目录中执行</p>
<ul>
<li><p>cnpm start （首选）</p>
</li>
<li><p>electron .</p>
</li>
<li><p>electron ，将应用程序拖入窗口中。</p>
</li>
</ul>
<p><img src="/2019/04/14/%E6%9E%84%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAELECTRON%E5%BA%94%E7%94%A8/hello-electron.jpg" alt="构建第一个ELECTRON应用\hello-electron"></p>
<h1 id="应用打包"><a href="#应用打包" class="headerlink" title="应用打包"></a>应用打包</h1><p>安装打包工具</p>
<p>全局安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">npm install electron-packager --save-dev</span></pre></td></tr></table></figure>

<p>打包命令格式：参考 <a href="[https://github.com/electron-userland/electron-packager/blob/master/usage.txt](https://github.com/electron-userland/electron-packager/blob/master/usage.txt">usage.txt</a>  详细说明</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">electron-packager &lt;sourcedir&gt; &lt;appname&gt; --platform=&lt;platform&gt; --arch=&lt;arch&gt; [optional flags...]</span></pre></td></tr></table></figure>

<p>我的打包格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">electron-packager . HelloElectron --platform=win32 --arch=ia32 HelloElectron</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">electron-packager ./ HelloElectron --platform=win32 --arch=ia32 --out ../Out/HelloElectron</span></pre></td></tr></table></figure>

<p>打包所有平台：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">electron-packager . --all</span></pre></td></tr></table></figure>

<h1 id="构建-Windows-安装程序"><a href="#构建-Windows-安装程序" class="headerlink" title="构建 Windows 安装程序"></a>构建 Windows 安装程序</h1><p>需要使用 Electron Installer Grunt 插件，<a href="[https://gruntjs.com/getting-started](https://gruntjs.com/getting-started">grunt</a> 查看入门，尤其是 <strong><a href="https://gruntjs.com/getting-started#installing-grunt-and-gruntplugins" target="_blank" rel="noopener">Installing Grunt and gruntplugins</a></strong>  , 我在这里栽了个跟斗。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cnpm install grunt --save-dev</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">cnpm install grunt-electron-installer --save-dev</span></pre></td></tr></table></figure>

<p>运行 grunt </p>
<p>提示如下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">grunt-cli: The grunt <span class="built_in">command</span> line interface (v1.3.2)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Fatal error: Unable to find <span class="built_in">local</span> grunt.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">If you<span class="string">'re seeing this message, grunt hasn'</span>t been installed locally to</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">your project. For more information about installing and configuring grunt,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">please see the Getting Started guide:</span></pre></td></tr></table></figure>

<p>解决，Unable to find local grunt 异常使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cnpm install grunt --save-dev</span></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在应用目录中新建 package.json（安装grunt 会自动创建） 和 Gruntfile.js</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"name"</span>: <span class="string">"Hello"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"grunt"</span>: <span class="string">"^1.0.4"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">"grunt-electron-installer"</span>: <span class="string">"^2.1.0"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Gruntfile.js 中的 outputDirectory 字段值一定是要 installer 否则就没有安装程序，哪怕是grunt 运行成功。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> grunt = <span class="built_in">require</span>(<span class="string">"grunt"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">grunt.config.init(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    pkg: grunt.file.readJSON(<span class="string">'package.json'</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="string">'create-windows-installer'</span>: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        x64: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            appDirectory: <span class="string">'./hello-win32-x64'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            outputDirectory: <span class="string">'./installer/64'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            authors: <span class="string">'mofei'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            exe: <span class="string">'hello.exe'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        ia32: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            appDirectory: <span class="string">'./hello-win32-ia32'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            outputDirectory: <span class="string">'./installer/32'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            authors: <span class="string">'mofei'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            exe: <span class="string">'hello.exe'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">grunt.loadNpmTasks(<span class="string">'grunt-electron-installer'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">grunt.registerTask(<span class="string">'default'</span>, [<span class="string">'create-windows-installer'</span>])</span></pre></td></tr></table></figure>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>命令行工具输入 grunt 开始构建安装包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">PS D:\Repository\Electron\electron-hello\build&gt; grunt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Running <span class="string">"create-windows-installer:x64"</span> (create-windows-installer) task</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Running <span class="string">"create-windows-installer:ia32"</span> (create-windows-installer) task</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">Done.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">PS D:\Repository\Electron\electron-hello\build&gt;</span></pre></td></tr></table></figure>

<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://npm.taobao.org/package/electron-packager#installation" target="_blank" rel="noopener">TAONPM:electron-package</a></p>
<p><a href="https://www.npmjs.com/package/electron-packager" target="_blank" rel="noopener">NPM:electron-package</a></p>
<p><a href="https://github.com/electron-userland/electron-packager" target="_blank" rel="noopener">GitHub:electron-package</a></p>
<p><a href="https://github.com/electron-archive/grunt-electron-installer" target="_blank" rel="noopener">github:grunt-electron-install</a></p>
<p><a href="https://blog.csdn.net/qq_26626113/article/details/81022347" target="_blank" rel="noopener">https://blog.csdn.net/qq_26626113/article/details/81022347</a></p>
<p><a href="https://blog.csdn.net/w342916053/article/details/51701722" target="_blank" rel="noopener">https://blog.csdn.net/w342916053/article/details/51701722</a></p>
<p><a href="https://juejin.im/entry/5805e39ad20309006854e58f" target="_blank" rel="noopener">https://juejin.im/entry/5805e39ad20309006854e58f</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mofei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫非的技术笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87/" class="post-title-link" itemprop="url">Java 核心技术-性能基础篇</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-14 17:00:00" itemprop="dateCreated datePublished" datetime="2019-04-14T17:00:00+08:00">2019-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-10 19:58:35" itemprop="dateModified" datetime="2019-12-10T19:58:35+08:00">2019-12-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">后端笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>性能调优工具、方法、基础</p>
</blockquote>
<h1 id="后台服务运行”变慢”，诊断思路？"><a href="#后台服务运行”变慢”，诊断思路？" class="headerlink" title="后台服务运行”变慢”，诊断思路？"></a>后台服务运行”变慢”，诊断思路？</h1><h2 id="诊断问题"><a href="#诊断问题" class="headerlink" title="诊断问题"></a>诊断问题</h2><ul>
<li><p>服务是突然变慢还是长时间运行后变慢？类似问题是否重复出现？</p>
</li>
<li><p>“慢” 的定义是什么？可以理解为系统对其他方面的请求反应延时变长吗？</p>
</li>
<li><p>对于分布式系统和大型单体应用有着不同的诊断思路？</p>
</li>
</ul>
<h2 id="对症下药"><a href="#对症下药" class="headerlink" title="对症下药"></a>对症下药</h2><p>对于分布式系统的诊断主要还是借助于<strong>系统日志、性能监控系统</strong>，<strong>Java 诊断工具 JFR（Java Flight Recorder）</strong>，监控应用是否出现某种类型异常。如果没有异常，还可以查看系统级别资源，监控 CPU 、内存等；</p>
<p>监控 Java 服务自身，例如 GC 日志里面是否观察到 Full GC 等恶劣情况出现，或者是否 Minor GC 在变长等；利用 jstat 工具，获取内存使用的统计信息；利用 jstack 工具检查死锁情况；</p>
<h2 id="性能分析方法论"><a href="#性能分析方法论" class="headerlink" title="性能分析方法论"></a>性能分析方法论</h2><ul>
<li><p>自上而下，从应用顶层，逐步深入到具体的不同模块，找到问题和解决办法。</p>
</li>
<li><p>自下而上，从硬件底层，类似 CPU 判断 Cache-Miss 之类的问题和调优机会，出发点是指令级别优化。（专业的性能工程师）</p>
</li>
</ul>
<h3 id="自上而下的分析思路和应用工具"><a href="#自上而下的分析思路和应用工具" class="headerlink" title="自上而下的分析思路和应用工具"></a>自上而下的分析思路和应用工具</h3><h4 id="系统性能分析"><a href="#系统性能分析" class="headerlink" title="系统性能分析"></a>系统性能分析</h4><p>系统性能分析中主要关注 <strong>CPU</strong>、<strong>内存</strong>、<strong>IO</strong> </p>
<p>Linux 系统中先用 top命令查看 CPU 负载情况。</p>
<p><img src="/2019/04/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87/top.png" alt="top"></p>
<p>可以看到 load average（平均负载）三个值（1分钟，5分钟，15分钟）非常低，暂时没有升高迹象。如果数值非常高，并且短期平均值高于长期平均值，则表明负载很重；</p>
<p>利用 top 命令获取相应 pid，“H” 表示 thread 模式，可以配合 grep 命令精准定位。</p>
<p><code>top h</code></p>
<p>然后转成 16 进制</p>
<p>printf “%x” your_pid</p>
<p>利用 jstack 获取线程栈，对比相应的 ID</p>
<p>更加通用的诊断方向利用 vmstat 之类，查看上下文切换数量，比如指定时间间隔为 1 收集 10 次</p>
<p><code>vmstat -1 -10</code></p>
<p>除了 CPU，内存和 IO 是重要的注意事项，比如：</p>
<ul>
<li>利用 free 之类查看内存使用。</li>
<li>或者，进一步判断 swap 使用情况，top 命令输出中 Virt 作为虚拟内存使用量，就是物理内存（Res）和 swap 求和，所以可以反推 swap 使用。显然，JVM 是不希望发生大量的 swap 使用的。</li>
<li>对于 IO 问题，既可能发生在磁盘 IO，也可能是网络 IO。例如，利用 iostat 等命令有助于判断磁盘的健康状况。（dstat 命令用来替换 vmstat、iostat、netstat、nfsstat和ifstat这些命令的工具，是一个全能系统信息统计工具）</li>
</ul>
<h4 id="JVM-性能分析"><a href="#JVM-性能分析" class="headerlink" title="JVM 性能分析"></a>JVM 性能分析</h4><ul>
<li><p>JMC、JConsole 等工具进行运行时监控。</p>
</li>
<li><p>利用各种工具，在运行时进行堆转储分析，或者获取各种角度的统计数据（如 jstat -gcutil 分析 gc 、内存分带）</p>
</li>
<li><p>GC 日志等手段，诊断 Full GC、Minor GC，或者引用堆积等。</p>
</li>
</ul>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>Profiling 工具获取数据的主要方式有哪些？各有什么优缺点。</p>
<ul>
<li><p>事件方法：对于 Java，可以采用 JVMTI（JVM Tools Interface）API 来捕捉诸如方法调用、类载入、类卸载、进入 / 离开线程等事件，然后基于这些事件进行程序行为的分析。</p>
</li>
<li><p>统计抽样方法（sampling）: 该方法每隔一段时间调用系统中断，然后收集当前的调用栈（call stack）信息，记录调用栈中出现的函数及这些函数的调用结构，基于这些信息得到函数的调用关系图及每个函数的 CPU 使用信息。由于调用栈的信息是每隔一段时间来获取的，因此不是非常精确的，但由于该方法对目标程序的干涉比较少，目标程序的运行速度几乎不受影响。</p>
</li>
<li><p>植入附加指令方法（BCI）: 该方法在目标程序中插入指令代码，这些指令代码将记录 profiling 所需的信息，包括运行时间、计数器的值等，从而给出一个较为精确的内存使用情况、函数调用关系及函数的 CPU 使用信息。该方法对程序执行速度会有一定的影响，因此给出的程序执行时间有可能不准确。但是该方法在统计程序的运行轨迹方面有一定的优势。</p>
</li>
</ul>
<h1 id="Lambda-真的能让Java程序变慢吗？"><a href="#Lambda-真的能让Java程序变慢吗？" class="headerlink" title="Lambda 真的能让Java程序变慢吗？"></a>Lambda 真的能让Java程序变慢吗？</h1><p><strong>使用基准测试判断应用表现的性能必须明确定义自身的范围和目标，否则有可能产生误导的结果。</strong></p>
<h2 id="Lambda-Stream-局限性"><a href="#Lambda-Stream-局限性" class="headerlink" title="Lambda/Stream 局限性"></a>Lambda/Stream 局限性</h2><p>Lambda / Stream 提供了强大的函数式编程能力。</p>
<ul>
<li><p>Lambda / Stream 提供了与传统方式接近对等的性能，对于性能敏感的场景，就不能不关注它了。例如：<strong>初始化的开销，Lambda 并不算是语法糖，而是一种新的工作机制，在首次调用时，JVM 需要为其构建 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/CallSite.html" target="_blank" rel="noopener">CallSite</a> 实例。这意味着 Java 应用启动过程引入很多 Lambda 语句，会导致启动过程变慢。其实现特点决定了 JVM 对它的优化可能与传统方式存在差异。</strong></p>
</li>
<li><p>增加了程序诊断等方面的复杂性，程序栈复杂很多，Fluent 风格本身不算是对调试非常友好的结构，并且在检查异常的处理方面也存在局限性等。</p>
</li>
</ul>
<h2 id="如何利用主流框架构建简单的基准测试"><a href="#如何利用主流框架构建简单的基准测试" class="headerlink" title="如何利用主流框架构建简单的基准测试"></a>如何利用主流框架构建简单的基准测试</h2><h3 id="什么时候开发微基准测试？"><a href="#什么时候开发微基准测试？" class="headerlink" title="什么时候开发微基准测试？"></a>什么时候开发微基准测试？</h3><p>当需要对一个大型软件中的某一小部分的性能评估时，就可以开发微基准测试。</p>
<h3 id="微基准测试框架选型？"><a href="#微基准测试框架选型？" class="headerlink" title="微基准测试框架选型？"></a>微基准测试框架选型？</h3><p><a href="http://openjdk.java.net/projects/code-tools/jmh/" target="_blank" rel="noopener">JMH</a> 由 Hotspot JVM 团队专家开发，除了支持完整的基准测试过程，包括预热、运行、统计和报告等，还支持 Java 和其他 JVM 语言。它针对 Hotspot JVM 提供了各种特性，以保证基准测试的正确性，整体准确性优于其他框架。</p>
<p>Maven 工程</p>
<p><img src="/2019/04/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87/JMH.png" alt="JMH"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ mvn archetype:generate \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">          -DinteractiveMode=false \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">          -DarchetypeGroupId=org.openjdk.jmh \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">          -DarchetypeArtifactId=jmh-java-benchmark-archetype \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">          -DgroupId=org.sample \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">          -DartifactId=test \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">          -Dversion=<span class="number">1.0</span></span></pre></td></tr></table></figure>

<p>利用注解（Annotation）定义具体的测试方法，以及为基准测试详细配置。</p>
<p>示例：利用@Benchmark 标识基准测试方法，@BenchmarkMode 标识基准测试模式（如吞吐量、平局时间）等模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@BenchmarkMode</span>(Mode.Throughput)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   <span class="comment">// Put your benchmark code here.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>当实现具体的测试后，利用 Maven 命令构建</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mvn clean install</span></pre></td></tr></table></figure>

<p>运行基准测试</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">java -jar target/benchmarks.jar</span></pre></td></tr></table></figure>

<h2 id="如何保证基准测试的正确性。"><a href="#如何保证基准测试的正确性。" class="headerlink" title="如何保证基准测试的正确性。"></a>如何保证基准测试的正确性。</h2><p><a href="https://www.ibm.com/developerworks/java/library/j-jtp02225/" target="_blank" rel="noopener">微基准测试中的典型问题</a></p>
<ul>
<li>保证代码经过了足够并且合适的预热。默认情况，在 server 模式下，JIT 会在一段代码执行 10000 次后，将其编译为本地代码，client 模式则是 1500 次以后。我们需要排除代码执行初期的噪音，保证真正采样到的统计数据符合其稳定运行状态。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">-XX:+PrintCompilation</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">我这里建议考虑另外加上一个参数，否则 JVM 将默认开启后台编译，也就是在其他线程进行，可能导致输出的信息有些混淆。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">-Xbatch</span></pre></td></tr></table></figure>

<ul>
<li>防止 JVM 进行无效代码消除。例如下面的代码片段中，由于我们并没有使用计算结果 mul，那么 JVM 就可能直接判断无效代码，根本就不执行它</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">int</span> left = <span class="number">10</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">int</span> right = <span class="number">100</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">int</span> mul = left * right;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果你发现代码统计数据发生了数量级程度上的提高，需要警惕是否出现了无效代码消除的问题。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决办法也很直接，尽量保证方法有返回值，而不是 void 方法，或者使用 JMH 提供的</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(Blackhole blackhole)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">   <span class="comment">// …</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">   blackhole.consume(mul);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li>防止发生常量折叠。JVM 如果发现计算过程是依赖于常量或者事实上的常量，就可能会直接计算其结果，所以基准测试并不能真实反映代码执行的性能。JMH 提供了 State 机制来解决这个问题，将本地变量修改为 State 对象信息，请参考下面示例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span>(Scope.Thread)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyState</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> left = <span class="number">10</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> right = <span class="number">100</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(MyState state, Blackhole blackhole)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">int</span> left = state.left;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">int</span> right = state.right;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">int</span> mul = left * right;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">   blackhole.consume(mul);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li><p>另外 JMH 还会对 State 对象进行额外的处理，以尽量消除伪共享（<a href="https://blogs.oracle.com/dave/java-contended-annotation-to-help-reduce-false-sharing" target="_blank" rel="noopener">false-sharing</a>）的影响，标记 @State，JMH 会自动进行补齐。</p>
</li>
<li><p>如果你希望确定方法内联（Inlining）对性能的影响，可以考虑打开下面的选项。</p>
</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">-XX:+PrintInlining</span></pre></td></tr></table></figure>

<h2 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h2><h3 id="什么是常量折叠？"><a href="#什么是常量折叠？" class="headerlink" title="什么是常量折叠？"></a>什么是常量折叠？</h3><p>常量折叠是指 Java 在编译阶段做的一个优化，也就是说在编译阶段就把表达式计算好，不需要在运行时计算。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//折叠前</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mul = <span class="number">5</span> * <span class="number">5</span>; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//折叠后</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mul = <span class="number">25</span>;</span></pre></td></tr></table></figure>

<h1 id="JVM-优化-Java-代码都做了些什么？"><a href="#JVM-优化-Java-代码都做了些什么？" class="headerlink" title="JVM 优化 Java 代码都做了些什么？"></a>JVM 优化 Java 代码都做了些什么？</h1><p>JVM 对代码执行的优化分为：</p>
<ul>
<li><p>运行时（runtime）优化，主要是解释执行和动态编译通用的一些机制，比如锁机制（偏斜锁）、内存分配机制（TLAB），除此以外还有一些专门用于优化解释执行效率的，比如说模板解释器、内联缓存（inline cache，用于优化虚方法调用的动态绑定）。</p>
</li>
<li><p>即时编译器（JIT）优化，将热点代码以方法为单位转换成机器代码，直接运行在底层硬件之上。采用了多种优化方式，包括静态编译器可以使用的方法内联、逃逸分析、也包括基于程序运行 profile 的投机性优化（可以理解为，有一条 instanceof 指令，在编译之前的执行过程中，测试对象的类一直是同一个，那么即时编译器可以假设编译之后的执行过程还是这个类，并且根据这个类直接返回 instanceof 的结果。如果出现其他类，那就抛弃这段编译后的机器代码，并切换到解释执行）。</p>
</li>
</ul>
<p>Java 代码的生命周期</p>
<p><img src="/2019/04/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87/Java生命周期.png" alt="Java核心技术性能基础篇\Java 生命周期"></p>
<p>java 通过字节码屏蔽不同的硬件差异，JVM 负责完成字节码到机器码的转换。</p>
<p>javac 等编译器或者相关 API 等将源码转换成字节码的过程中也会进行少量类似常量折叠之类的优化。</p>
<p>javac 优化与 JVM 内部优化也存在关联，毕竟它负责字节码的生成。例如，Java 9 中的字符串拼接，会被 javac 替换成对 StringConcatFactory 的调用，进而为 JVM 进行字符串拼接优化提供了统一的入口。在实际场景中，还可以通过不同的<a href="http://openjdk.java.net/jeps/280" target="_blank" rel="noopener">策略</a>来干预这个过程。</p>
<h2 id="JVM-运行时优化"><a href="#JVM-运行时优化" class="headerlink" title="JVM 运行时优化"></a>JVM 运行时优化</h2><p><img src="/2019/04/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87/JVM运行时优化.png" alt="Java核心技术性能基础篇\JVM 运行时优化"></p>
<p>JVM 会根据统计信息，动态决定什么方法被编译，什么方法解释执行，即使是已经编译过的代码，也可能在不同的运行阶段不再是热点，JVM 有必要将这种代码从 Code Cache 中移除出去，毕竟其大小是有限的。</p>
<p><strong>即时编译（JIT），则是更多优化工作的承担者。JIT 对 Java 编译的基本单元是整个方法，通过对方法调用的计数统计，甄别出热点方法，编译为本地代码。</strong>另外一个优化场景，则是最针对所谓热点循环代码，利用通常说的栈上替换技术（OSR，On-Stack Replacement），如果方法本身的调用频度还不够编译标准，但是内部有大的循环之类，则还是会有进一步优化的价值。</p>
<p>从理论上来看，JIT 可以看作就是基于两个计数器实现，<strong>方法计数器和回边计数器</strong>提供给 JVM 统计数据，以定位到热点代码。实际中的 JIT 机制要复杂得多，逃逸分析、循环展开、方法内联等，包括前面提到的 Intrinsic 等通用机制同样会在 JIT 阶段发生。</p>
<h2 id="探查JVM-优化具体发生情况？"><a href="#探查JVM-优化具体发生情况？" class="headerlink" title="探查JVM 优化具体发生情况？"></a>探查JVM 优化具体发生情况？</h2><ul>
<li><p>打印编译发生细节 <code>-XX:+PrintCompilation</code></p>
</li>
<li><p>输出更多编译细节 <code>-XX:UnlockDiagnosticVMOptions -XX:+LogCompilation -XX:LogFile=&lt;your_file_path&gt;</code></p>
</li>
<li><p>打印内联的发生，可利用下面的诊断选项，也需要明确解锁。 <code>-XX:+PrintInlining</code></p>
</li>
<li><p>如何知晓 Code Cache 的使用状态呢？利用 JMC、JConsole 、NMT 等工具。</p>
</li>
</ul>
<h2 id="应用开发者的调优手段"><a href="#应用开发者的调优手段" class="headerlink" title="应用开发者的调优手段"></a>应用开发者的调优手段</h2><ul>
<li><p>调整热点代码门限值，<code>-XX:CompileThreshold=N</code>，server 模式默认 10000 次 ，client 模式默认 1500 次。</p>
</li>
<li><p>调整 Code Cache 大小，<code>-XX:ReservedCodeCacheSize=&lt;SIZE&gt;</code> 或调整其初始大小<code>-XX:InitialCodeCacheSize=&lt;SIZE&gt;</code></p>
</li>
<li><p>调整编译器线程数<code>-XX:CICompilerCount=N</code>，或选择适当的编译模式</p>
</li>
</ul>
<h2 id="知识补充-1"><a href="#知识补充-1" class="headerlink" title="知识补充"></a>知识补充</h2><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>参考维基百科<a href="https://en.wikipedia.org/wiki/Escape_analysis" target="_blank" rel="noopener">Escape_analysis</a></p>
<h3 id="循环开展"><a href="#循环开展" class="headerlink" title="循环开展"></a>循环开展</h3><p>参考维基百科<a href="https://en.wikipedia.org/wiki/Loop_unrolling" target="_blank" rel="noopener">Loop_unrolling</a></p>
<h1 id="MySQL-支持事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？"><a href="#MySQL-支持事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？" class="headerlink" title="MySQL 支持事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？"></a>MySQL 支持事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？</h1><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>MySQL InnoDB 引擎是基于 MVCC（Multi Versioning Concurrency Control） 和 锁的复合实现。按照隔离程度从低到高，MySQL 事务隔离级别分为四个不同层次。</p>
<ul>
<li><p>读未提交（Read uncommitted）允许脏读，也就是事务B能够看到事务A尚未提交的修改。</p>
</li>
<li><p>读已提交（Read committed），事务能够看到的数据都是其他事务已经提交的修改，保证不会看到任何中间性状态，允许不可重复读和幻象读。</p>
</li>
<li><p>可重复读（Repeatable reads），保证同一个事务中多次读取的数据是一致的，MySql InnoDB 默认的隔离级别。</p>
</li>
<li><p>串行化（Serializable），并发事务之间是串行化的，意味着读取需要获取共享读锁，更新需要获取排他写锁，如果 SQL 使用 WHERE 语句，还要获取区间锁（MySQL 以 GAP 锁形式实现，可重复读级别中默认也会使用）</p>
</li>
</ul>
<h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><p>主要的区别体现在操作共享数据时：“悲观锁”认为数据出现冲突可能性更大，“乐观锁”则认为大部分情况不会出现冲突，进而决定是否采用排他性措施。</p>
<p>反映到 MySQL 数据库应用中：</p>
<p>悲观锁一般是利用类是 SELECT …… FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。</p>
<p>乐观锁 与 Java 并发包中的 AtomicFieldUpdate 类是，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。</p>
<h2 id="重点掌握"><a href="#重点掌握" class="headerlink" title="重点掌握"></a>重点掌握</h2><ul>
<li>数据库设计基础，包括数据库设计中的几个基本范式，各种数据库的基础概念，例如表、视 图、索引、外键、序列号生成器等，清楚如何将现实中业务实体和其依赖关系映射到数据库结构中，掌握典型实体数据应该使用什么样的数据库数据类型等。</li>
<li>精通你使用过的数据库的设计要点。以 MySQL 为例进一步了解 MVCC、Locking 等机制对于处理进阶问题非常有帮助；还需要了解，不同索引类型的使用，甚至是底层数据结构和算法等。</li>
<li>常见的 SQL 语句，掌握基础的 SQL 调优技巧，至少要了解基本思路是怎样的，例如 SQL 怎 样写才能更好利用索引、知道如何分析SQL 执行计划等。</li>
<li>更进一步，至少需要了解针对高并发等特定场景中的解决方案，例如读写分离、分库分表，或 者如何利用缓存机制等，目前的数据存储也远不止传统的关系型数据库了。</li>
</ul>
<h2 id="开源框架学习指南"><a href="#开源框架学习指南" class="headerlink" title="开源框架学习指南"></a>开源框架学习指南</h2><ul>
<li>从整体上把握主流框架的架构和设计理念，掌握主要流程，例如 SQL 解析生成、SQL 执行到 结果映射等处理过程到底发生了什么。</li>
<li>掌握映射等部分的细节定义和原理，根据我在准备专栏时整理的面试题目，发现很多题目都是 偏向于映射定义的细节。</li>
<li>对比不同框架的设计和实现，既有利于你加深理解，也是面试考察的热点方向之一。</li>
</ul>
<h2 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h2><p>从架构设计的角度，可以将 MyBatis 分为哪几层？每层都有哪些主要模块？</p>
<p>mybatis 架构自下而上分为基础支撑层、数据处理层、API 接口层这三层。  </p>
<ul>
<li><p>基础支撑层：主要是用来做连接管理、事务管理、配置加载、缓存管理等最基础组件，为上层提供最基础的支撑。</p>
</li>
<li><p>数据处理层：主要是用来做参数映射、sql解析、sql执行、结果映射等处理，可以理解为请求到达，完成一次数据库操作的流程。</p>
</li>
<li><p>API 接口层：主要对外提供 API，提供诸如数据的增删改查、获取配置等接口。</p>
</li>
</ul>
<h1 id="Spring-生命周期和作用域？"><a href="#Spring-生命周期和作用域？" class="headerlink" title="Spring 生命周期和作用域？"></a>Spring 生命周期和作用域？</h1><h2 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h2><p><img src="/2019/04/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87/SpringBean生命周期.jpg" alt="Java核心技术性能基础篇\Spring Bean生命周期"></p>
<ol>
<li><p>Spring 对 bean 进行实例化。</p>
</li>
<li><p>Spring 将值和 bean 的引用注入到 bean 对应的属性中；</p>
</li>
<li><p>若 bean 实现了 BeanNameAware接口，Spring 将 Bean 的 ID 传递给 setBeanName() 方法。</p>
</li>
<li><p>若 bean 实现了 BeanFactoryAware 接口，Spring 将调用 setBeanFactory() 方法，将 BeanFactory 容器实例传入。</p>
</li>
<li><p>若 bean 实现了 ApplicationContextAware 接口，Spring 将调用 setApplicationContext() 方法，将 bean 所在的应用上下文的引用传入进来。</p>
</li>
<li><p>若 bean 实现了 BeanPostProcessor 接口，Spring 将调用 postProcessBeforeInitialization() 方法；</p>
</li>
<li><p>若 bean 实现了 InitializingBean 接口，Spring 将调用 afterPropertiesSet() 方法。类似的，若 bean 使用 init-method 声明了初始化方法，该方法也会调用；</p>
</li>
<li><p>若 bean 实现了 BeanPostProcessor 接口，Spring 将调用 postProcessAfterInitialization() 方法；</p>
</li>
<li><p>bean 准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到应用上下文被销毁；</p>
</li>
<li><p>若 bean 实现了 DisposableBean 接口，Spring 将调用 destory() 方法。类似的若 bean 使用 destory-method 声明了销毁方法，该方法也会被调用。</p>
</li>
</ol>
<h2 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h2><ul>
<li><p>单例（Singleton）默认选项，Spring 容器只创建一个实例。</p>
</li>
<li><p>原型（Prototype）每次注入或通过 Spring 上下文获取 bean 时候，都会创建一个 bean 实例。</p>
</li>
<li><p>会话（Session）Web 应用中使用，为每个会话创建一个 bean  实例。</p>
</li>
<li><p>请求（Request）Web 应用中使用，为每个请求创建一个 bean 实例。</p>
</li>
<li><p>全局（GlobalSession）用于 Portlet 容器，每个Portlet 有单独的 Session ，GlobalSession 提供一个全局的 HTTP Session.</p>
</li>
</ul>
<h2 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h2><p>控制反转（Inversion of Control）也称为依赖注入（Dependency Injection），主要作用就是解耦合。</p>
<ul>
<li><p>高层次模块不应该依赖低层次模块，他们应该依赖于一种抽象。</p>
</li>
<li><p>这种抽象不应该依赖细节，细节应该依赖于抽象</p>
</li>
</ul>
<h2 id="切面编程"><a href="#切面编程" class="headerlink" title="切面编程"></a>切面编程</h2><p>切面编程AOP（Aspect Oriented Programming）,把遍布在应用各处的功能分离出来，让服务模块化</p>
<p>切面提供了取代继承和委托的另一种解决方案。</p>
<p><img src="/2019/04/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87/SpringAdvice.png" alt="Java核心技术性能基础篇\Spring Advice"></p>
<h3 id="通知（Advice）"><a href="#通知（Advice）" class="headerlink" title="通知（Advice）"></a>通知（Advice）</h3><p>Advice <strong>明确了切面编程中的什么</strong>，Spring AOP 提供 5 种类型通知</p>
<ul>
<li><p>Before（前置通知）在目标方法调用之前调用通知功能；</p>
</li>
<li><p>After（后置通知）在目标方法完成之后调用通知，不关心方法输出是什么；</p>
</li>
<li><p>After-returning（返回通知）在目标方法成功执行后调用通知；</p>
</li>
<li><p>After-throwing（异常通知）在目标方法抛出异常后调用通知；</p>
</li>
<li><p>Around（环绕通知）通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行的自定义行为；</p>
</li>
</ul>
<h3 id="连接点（join-point）"><a href="#连接点（join-point）" class="headerlink" title="连接点（join point）"></a>连接点（join point）</h3><p><strong>join point 明确了切面编程中的目标。</strong></p>
<h3 id="切点（Ponitcut）"><a href="#切点（Ponitcut）" class="headerlink" title="切点（Ponitcut）"></a>切点（Ponitcut）</h3><p><strong>pointcut 明确了切面编程中的目标何处。</strong></p>
<h3 id="切面（Aspect）"><a href="#切面（Aspect）" class="headerlink" title="切面（Aspect）:"></a>切面（Aspect）:</h3><p><strong>切面是 Advice 和 Ponitcut 的结合，明确了它是什么，在何时和何处完成其功能。</strong></p>
<h3 id="引入（Introduction）"><a href="#引入（Introduction）" class="headerlink" title="引入（Introduction）"></a>引入（Introduction）</h3><p><strong>引入允许我们想现有的类中添加新方法或属性。</strong></p>
<h3 id="织入（Weaving）"><a href="#织入（Weaving）" class="headerlink" title="织入（Weaving）"></a>织入（Weaving）</h3><p><strong>织入把切面应用到目标对象并创建新的代理对象的过程</strong>。</p>
<p><img src="/2019/04/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87/AOP流程图.jpg" alt="AOP流程图"></p>
<h1 id="对比Java标准NIO类库，Netty是如何实现更高性能的吗？"><a href="#对比Java标准NIO类库，Netty是如何实现更高性能的吗？" class="headerlink" title="对比Java标准NIO类库，Netty是如何实现更高性能的吗？"></a>对比Java标准NIO类库，Netty是如何实现更高性能的吗？</h1><ul>
<li><p>更加优雅的 Reactor 模式实现、灵活的线程模型、利用 EventLoop 等创新性的机制，可以非常高效地管理成百上千的 Channel。</p>
</li>
<li><p>充分利用了 Java 的 Zero-Copy 机制，并且从多种角度，“斤斤计较”般的降低内存分配和回收的开销。例如，使用池化的 Direct Buffer 等技术，在提高 IO 性能的同时，减少了对象的创建和销毁；利用反射等技术直接操纵 SelectionKey，使用数组而不是 Java 容器等。</p>
</li>
<li><p>使用更多本地代码。例如，直接利用 JNI 调用 Open SSL 等方式，获得比 Java 内建 SSL 引擎更好的性能。</p>
</li>
<li><p>在通信协议、序列化等其他角度的优化。</p>
</li>
</ul>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p>Netty 是一个异步且基于事件 Client/Server 的网络框架，目标是提供一种简单、快速构建网络应用的方式，通知保证高吞吐量、低延时、高可靠性。</p>
<p>Netty 的设计强调关注点分离（Separation Of Concerns，SOC），通过精巧设计的事件机制，将业务逻辑和无关技术逻辑进行隔离，并通过各种方便的抽象，一定程度上填补了了基础平台和业务开发之间的鸿沟，更有利于在应用开发中普及业界的最佳实践。</p>
<p><strong>Netty &gt; java.io + java.net</strong></p>
<p>在基础 NIO 之上，Netty 构建了更加易用、高性能的网络框架，广泛应用于互联网、游戏、电信等各种领域。</p>
<h2 id="思考题-2"><a href="#思考题-2" class="headerlink" title="思考题"></a>思考题</h2><p>Netty 的线程模型是什么样 的？</p>
<p>Netty采用Reactor线程模型。这里面主要有三种Reactor线程模型。分别是单线程模式、主从Reactor模式、多Reactor线程模式。其都可以通过初试和EventLoopGroup进行设置。其主要区别在于，单Reactor模式就是一个线程，既进程处理连接，也处理IO。类似于我们传统的OIO编程。主从Reactor模式，其实就是将监听连接和处理IO的分开在不同的线程完成。最后，主从Reactor线程模型，为了解决多Reactor模型下单一线程性能不足的问题。改为了一组线程池进行处理。官方默认的是采用这种主从Reactor模型。其线程数默认为CPU内核的2倍。</p>
<h1 id="分布式ID的设计方案？Snowflake是否受冬令时切换影响？"><a href="#分布式ID的设计方案？Snowflake是否受冬令时切换影响？" class="headerlink" title="分布式ID的设计方案？Snowflake是否受冬令时切换影响？"></a>分布式ID的设计方案？Snowflake是否受冬令时切换影响？</h1><h2 id="分布式-ID-的基本要求"><a href="#分布式-ID-的基本要求" class="headerlink" title="分布式 ID 的基本要求"></a>分布式 ID 的基本要求</h2><ul>
<li><p>全局唯一，区别于单点系统的唯一，全局是要求分布式系统内唯一。</p>
</li>
<li><p>有序性，通常都需要保证生成的 ID 是有序递增的。例如，在数据库存储等场景中，有序 ID 便于确定数据位置，往往更加高效。</p>
</li>
</ul>
<h2 id="分布式-ID-的设计方案"><a href="#分布式-ID-的设计方案" class="headerlink" title="分布式 ID 的设计方案"></a>分布式 ID 的设计方案</h2><ul>
<li><p>数据库自增序列，简单易用，其扩展性和可靠性存在很大的局限性。</p>
</li>
<li><p>Snowflake，TWitter 早起的开源的 Snowflake 实现，结构定义如下</p>
<p><img src="/2019/04/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80%E7%AF%87/Snowflake.png" alt="Snowflake"></p>
<p>整体长度为 64（1 + 41 + 10 + 12 = 64）适合 Java 中 long 类型存储。</p>
<p>头部是 1 位的正负标识位。</p>
<p>41 位时间戳，通常使用System.currentTimeMills()</p>
<p>10 位WorkerID，标准定义的是 5 位数据中心 + 5为机器ID，组成机器编号，便于区分不同的集群点。</p>
<p>12 位序列，是单位毫秒内可生成的序列号数据的理论极限。</p>
</li>
<li><p>Redis、Zookeeper、MongoDB 等中间件也都有各种唯一 ID 解决方案</p>
</li>
</ul>
<p>Snowflake 算法的 Java 实现，依赖 System.currentTimeMillis() ,它是返回当前时间和 1970 年 1 月 1 号 UTC 时间相差的毫秒数，这个跟夏冬时令没关系，所以不受起影响。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/07/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mofei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫非的技术笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/07/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%AF%87/" class="post-title-link" itemprop="url">Java 核心技术-安全基础篇</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-07 18:00:00" itemprop="dateCreated datePublished" datetime="2019-04-07T18:00:00+08:00">2019-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-10 19:58:58" itemprop="dateModified" datetime="2019-12-10T19:58:58+08:00">2019-12-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">后端笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>常见应用安全问题和处理方法，编码规范。</p>
</blockquote>
<h1 id="GC-调优思路？"><a href="#GC-调优思路？" class="headerlink" title="GC 调优思路？"></a>GC 调优思路？</h1><blockquote>
<p>关于 G1 调优指南参考<a href="[https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector-tuning.htm#JSGCT-GUID-4914A8D4-DE41-4250-B68E-816B58D4E278](https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector-tuning.htm#JSGCT-GUID-4914A8D4-DE41-4250-B68E-816B58D4E278">官方文档</a></p>
</blockquote>
<p>GC 调优思路，首先要明确调优的目的是解决什么问题？从性能调优角度来看不外乎关心三个方面：吞吐量（throughput）内存占用（footprint）延时（latency），多数情况倾向一到两个方面的调优。除了这三个方面外还可以考虑 GC 相关场景，比如，OOM 可能与 GC 参数设置有关；应用启动速度等；</p>
<h2 id="调优思路"><a href="#调优思路" class="headerlink" title="调优思路"></a>调优思路</h2><ul>
<li><p>理解应用需求解决什么样的问题。</p>
</li>
<li><p>掌握 JVM 和 GC 状态，通过 jstat 查看 GC 状态；追踪 GC 日志等。</p>
</li>
<li><p>选择的 GC 类型 是否符合应用特征。</p>
</li>
<li><p>通过分析确定具体调整参数或软硬件配置。</p>
</li>
<li><p>验证是否达到调优目标。</p>
</li>
</ul>
<h2 id="G1-内部结构和主要机制"><a href="#G1-内部结构和主要机制" class="headerlink" title="G1 内部结构和主要机制"></a>G1 内部结构和主要机制</h2><p>从内存区域的角度，G1 同样存在着年代的概念，但是与我前面介绍的内存结构很不一样，其内 部是类似棋盘状的一个个 region 组成，请参考下面的示意图。</p>
<p><img src="/2019/04/07/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%AF%87/G1内部结构.png" alt="G1内部结构"></p>
<p>region 大小一致，数值在 1M 到 32M 字节之间的一个 2 的幂数值，JVM 尽量划分 2048 个区域，该数字是可以手动调整， G1 会根据堆大下自动进行调整。</p>
<p>G1 实现中，年代是个逻辑概念，体现在一部分 region 作为 Eden，一部分作为 Survivor，除了意料之中的 Old region ，G1 会将超过 region 50% 大小的对象（在应用中通常是 byte 或 char 数组）归类为 Humongous 对象，并放置在相应的 region 中，算是老年代的一部分。因为复制大对象是很昂贵的操作，并不适合新生代GC 的复制算法。</p>
<h3 id="region-设计的副作用"><a href="#region-设计的副作用" class="headerlink" title="region 设计的副作用"></a>region 设计的副作用</h3><p>region 大小和大对象很难保证一致，这会导致空间浪费。</p>
<p>从上图看出 Humongous 标记出来的颜色却没有 H 标志，是为了表示特别大的对象是可能超过占用一个 region ，并且 region 太小也不合适，会令你在分配大对象时更难找到连续空间。解决办法就是直接设置 region 的大小，参数如下：</p>
<p><code>-XX:G1HeapRegionSize=&lt;N, 例如 16&gt;M</code></p>
<h3 id="G1-采用复合算法"><a href="#G1-采用复合算法" class="headerlink" title="G1 采用复合算法"></a>G1 采用复合算法</h3><ul>
<li><p>新生代，G1 采用并行的复制算法，同样会发生 Stop-The-World 的暂停。</p>
</li>
<li><p>老年代，多数情况采用并发标记，而整理则和新生代 GC 时捎带进行，并且不是整体性的整理，而是增量进行。</p>
</li>
</ul>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>定位 Full GC 发生的原因，有哪些方式？</p>
<ul>
<li><p>首先通过 printgcdetail 查看 fullgc 频率以及时长</p>
</li>
<li><p>通过 dump 查看内存中哪些对象多，这些可能是引起 fullgc 的原因，看是否能优化</p>
</li>
<li><p>如果堆大或者是生产环境，可以开启 jmc 飞行一段时间，查看这期间的相关数据来定位问题</p>
</li>
</ul>
<h1 id="Java-内存模型（JMM）中的-happen-before？"><a href="#Java-内存模型（JMM）中的-happen-before？" class="headerlink" title="Java 内存模型（JMM）中的 happen-before？"></a>Java 内存模型（JMM）中的 happen-before？</h1><p>happen-before 关系，是 Java 内存模型种保证多线程操作可见性的一种机制。</p>
<p>Java 内存模型（Java Memory model , JMM）</p>
<ul>
<li><p>什么是 Java 内存模型，为什么需要它。</p>
</li>
<li><p>Java 内存模型如何解决可见性等各种问题？类似 volatile 体现在具体用例中有什么效果？</p>
</li>
</ul>
<h2 id="平台的内存模型"><a href="#平台的内存模型" class="headerlink" title="平台的内存模型"></a>平台的内存模型</h2><p>在共享内存的多处理器体系架构中，每个处理器都有自己的缓存，并且定期与主内存进行协调。在不同的处理器架构中提供了不同级别的缓存一致性（Cache Coherence）,其中一部分提供最小的保证，即允许不同的处理器在任意时刻从同一个存储位置看到不同的值。操作系统、编译器以及运行时（甚至包括应用程序）需要弥合这种在硬件能力与线程安全需求之间的差异。</p>
<p>要想确保每个处理器都能在任意时刻知道其他处理器正在进行的工作，将需要非常大的开销。因此处理器会适当放宽存储一致性保证，以换取性能的提升。在架构定义的内存模型中将告诉应用程序可以从内存系统中获得怎样的保证，此外还定义了额外的特殊指令（称为内存屏障），当需要共享数据时，这些指令就能实现额外的存储协调保证。为了使 Java 开发人员无需关心不同架构上内存模型之间的差异，Java 提供了自己的内存模型，并且 JVM 通过在适当的位置上插入 <strong>内存屏障</strong> 来屏蔽 JMM 与底层平台内存模型之间的差异。</p>
<h2 id="Java-内存模型简介"><a href="#Java-内存模型简介" class="headerlink" title="Java 内存模型简介"></a>Java 内存模型简介</h2><p>Java 内存模型是通过各种操作来定义的，包括对变量的读写操作，监视器的加锁和释放操作，以及线程的启动和合并操作。JMM 为程序中所有的操作定义了一个偏序关系，称为 Happens-Before。要想保证执行操作 B 的线程看到操作 A 的结果（无论 A 和 B 是否在同一个线程执行）那么 A 和 B 之间必须满足 Happens-Before 关系。如果操作之间缺乏 Happens-Before 关系，那么 JVM 可以对它们任意的重排序。</p>
<p>当一个变量被多个线程读取并且至少被一个线程写入时，如果在读操作和写操作之间没有依照 Happens-Before 来排序，就会产生数据竞争问题。在正确同步的程序中部存在数据竞争，并会表现出串行一致性，这意味着程序中的所有操作都会按照一种固定的和全局的顺序执行。</p>
<blockquote>
<p>偏序关系 π 是集合上的一种关系，具有反对称性、自反和传递属性，但对于任意两个元素 x ，y 来说，并不需要一定满足 x π y 或 y π x 的关系。</p>
</blockquote>
<p>Happens- Before 的规则如下：</p>
<ul>
<li><p>程序顺序规则，如果程序中操作 A 在操作 B 之前，那么在线程中 A 操作将在 B 操作之前执行。</p>
</li>
<li><p>监视器锁规则，在监视器锁上的解锁操作必须在同一个监视器锁上的加锁操作之前执行。</p>
</li>
<li><p>volatile 变量规则，对 volatile 变量的写入操作必须在对该变量的读操作之前执行。</p>
</li>
<li><p>线程启动规则，在线程上对 Thread.Start() 的调用必须在该线程中执行任何操作之前执行。</p>
</li>
<li><p>线程结束规则，线程中的任何操作都必须在其他线程检测到该线程已经结束之前执行，或者从 Thread.join 中成功返回，或者在调用 Thread.isAlive 时返回 false。</p>
</li>
<li><p>中断规则，当一个线程在另一个线程上调用 interrupt 时，必须在被中断线程检测到 interrupt 调用之前执行（通过 抛出 InterruptedException，或者调用 isInterrupted 和 interrupted）</p>
</li>
<li><p>终结器规则，对象的构造函数必须在启动该对象的终结器之前执行完成。</p>
</li>
<li><p>传递性，如果 A 操作在操作 B 之前执行，并且操作 B 在 操作 C 之前执行，那么操作 A 必须在操作 C 之前执行。</p>
</li>
</ul>
<p><img src="/2019/04/07/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%AF%87/JMM.png" alt="JMM"></p>
<p>在编译器中生成的指令顺序，可以与源代码中的顺序不同，此外编译器还会把变量保存在寄存器而不是内存中；处理器可以采用乱序或并行等方式执行指令；缓存可能会改变将写入变量提交到主内存的次序；而且，保存在处理器本地缓存中的值，对其他处理器是不可见的。这些因素都会导致一个线程无法看到变量的最新值，并且会导致其他线程中的内存操作似乎在乱序执行。</p>
<p>JMM 内部的实现通常依赖于“内存屏障”，通过禁止重排序的方式，提供内存可见性保证，也就是 实现各种 Happens-Before 规则。</p>
<h3 id="如何利用内存屏障实现-JMM-定义的可见性"><a href="#如何利用内存屏障实现-JMM-定义的可见性" class="headerlink" title="如何利用内存屏障实现 JMM 定义的可见性"></a>如何利用内存屏障实现 JMM 定义的可见性</h3><p>对于一个 volatile 变量：</p>
<ul>
<li><p>对该变量的写操作之后，编译器会插入一个写屏障。</p>
</li>
<li><p>对该变量的读操作之前，编译器会插入一个读屏障。</p>
</li>
</ul>
<p>线程写入，写屏障会通过类是强制刷出处理器缓存的方式，让其他线程得到最新值。</p>
<h2 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h2><p>给定一段代码，如何验证所有符合 JMM 执行可能？有什么工具可以辅助吗？</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>《深入理解 Java 虚拟机》</p>
<p>《Java 并发编程》</p>
<h1 id="Java-程序运行在Docker-容器环境有那些新问题？"><a href="#Java-程序运行在Docker-容器环境有那些新问题？" class="headerlink" title="Java 程序运行在Docker 容器环境有那些新问题？"></a>Java 程序运行在Docker 容器环境有那些新问题？</h1><blockquote>
<p><a href="[https://medium.freecodecamp.org/a-beginner-friendly-introduction-to-containers-vms-and-docker-79a9e3e119b](https://medium.freecodecamp.org/a-beginner-friendly-introduction-to-containers-vms-and-docker-79a9e3e119b">Docker、VM 入门介绍</a></p>
</blockquote>
<p>Docker 使用 CGroup 来管理 CPU、内存等资源限制，早起版本的 JDK 并不能识别这些这些限制，就会导致以下问题：</p>
<ul>
<li><p>如果未配置合适的 JVM 堆和元数据区、直接内存等参数，Java 就有可能试图使用超过容器限制的内存，最终被容器 OOM kill，或者自身发生 OOM。</p>
</li>
<li><p>错误判断了可获取的 CPU 资源，例如，Docker 限制了 CPU 的核数，JVM 就可能设置不合适的 GC 并行线程数等。</p>
</li>
</ul>
<p><img src="/2019/04/07/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%AF%87/Docker.png" alt="Docker"></p>
<p>上面的示意图，展示了 Docker 与虚拟机的区别。从技术角度，基于 namespace，Docker 为每个容器提供了单独的命名空间，对网络、PID、用户、IPC 通信、文件系统挂载点等实现了隔离。对于 CPU、内存、磁盘 IO 等计算资源，则是通过 CGroup 进行管理。</p>
<h1 id="Java-应用开发中的注入攻击？"><a href="#Java-应用开发中的注入攻击？" class="headerlink" title="Java 应用开发中的注入攻击？"></a>Java 应用开发中的注入攻击？</h1><h2 id="什么是注入攻击？"><a href="#什么是注入攻击？" class="headerlink" title="什么是注入攻击？"></a>什么是注入攻击？</h2><p>注入攻击主要特征是程序允许攻击者将恶意内容注入到程序中，在运行过程中会改变最初的执行过程并带来恶意效果。</p>
<h2 id="常见注入攻击"><a href="#常见注入攻击" class="headerlink" title="常见注入攻击"></a>常见注入攻击</h2><ul>
<li><p>SQL 注入攻击</p>
</li>
<li><p>操作系统命令注入，Java 语言提供了类似 Runtime.exec()  的API。</p>
</li>
<li><p>XML 注入攻击，XML 自身可以包含动态内容，例如：XPATH，使用不当，可能导致范文恶意内容。 </p>
</li>
</ul>
<h2 id="重点掌握"><a href="#重点掌握" class="headerlink" title="重点掌握"></a>重点掌握</h2><ul>
<li><p>Java 应用安全，主要涉及那些安全机制。</p>
</li>
<li><p>什么是安全漏洞？</p>
</li>
</ul>
<h2 id="Java-API-和-工具构成-Java-安全基础"><a href="#Java-API-和-工具构成-Java-安全基础" class="headerlink" title="Java API 和 工具构成 Java 安全基础"></a>Java API 和 工具构成 Java 安全基础</h2><ul>
<li><p>运行时安全机制，限制 Java 运行时的行为，不做越权或者不靠谱的事情。</p>
<ul>
<li><p>类加载过程中，进行字节码验证，防止不符合规范的代码影响 JVM 运行或者再入其他恶意代码。</p>
</li>
<li><p>利用 SecurityManager 机制和相关组件，限制代码运行时行为能力，可以定制 policy 文件和各种粒度的权限定义，限制代码的作用域和权限。</p>
</li>
</ul>
</li>
<li><p>Java 提供的安全框架 API，这是构建安全通信应用的基础。</p>
<ul>
<li><p>加密、解密 API</p>
</li>
<li><p>授权、鉴权 API</p>
</li>
<li><p>安全通信相关类库，比如基于 HTTPS 通信协议相关标准实现。</p>
</li>
</ul>
</li>
<li><p>JDK 集成的安全工具</p>
<ul>
<li><p>keytool，管理安全场景中密钥、证书等，并且可以管理 Java 程序使用的 keystore 文件。</p>
</li>
<li><p>jarsinger，用于 jar 文件进行签名或者验证。</p>
</li>
</ul>
</li>
</ul>
<p>安全倾向于：“明显没有漏洞”，而不是“没有明显漏洞”·</p>
<h3 id="Man-In-The-Middle（MITM）-攻击"><a href="#Man-In-The-Middle（MITM）-攻击" class="headerlink" title="Man-In-The-Middle（MITM） 攻击"></a>Man-In-The-Middle（MITM） 攻击</h3><p>MITM 攻击可以理解为中间人攻击。</p>
<h1 id="如何写出安全的-Java-代码？"><a href="#如何写出安全的-Java-代码？" class="headerlink" title="如何写出安全的 Java 代码？"></a>如何写出安全的 Java 代码？</h1><ul>
<li><p>对系统内存和存储的上限进行控制，类似上传文件或者其他接受输入的服务。</p>
</li>
<li><p>保证 Java 程序中的资源释放，如数据库连接、文件描述符、各种锁。</p>
</li>
</ul>
<h2 id="知识延伸"><a href="#知识延伸" class="headerlink" title="知识延伸"></a>知识延伸</h2><p>安全问题也就是软件的缺陷不是单方面的，这中间包括软件设计、架构中的风险分析、编码、测试等。</p>
<ul>
<li>溢出，数值类型溢出，数组越界等。</li>
<li>言多必失，防止暴露敏感数据信息。</li>
<li>序列化，针对序列化，通常建议：<ul>
<li>敏感信息不要被序列化，编码中建议使用 Transient 关键字将其保护起来。</li>
<li>反序列化中，建议 readObject 中实现与对象构建过程相同的安全检查和数据检查。</li>
</ul>
</li>
</ul>
<h2 id="开发和测试阶段"><a href="#开发和测试阶段" class="headerlink" title="开发和测试阶段"></a>开发和测试阶段</h2><ul>
<li><p>早期设计阶段，由安全专家组对新特性进行风险评估。</p>
</li>
<li><p>开发过程中，code review 阶段，应用 OpenJDK 自身定制的代码规范。</p>
</li>
<li><p>利用静态分析工具：<a href="http://findbugs.sourceforge.net/" target="_blank" rel="noopener">FindBugs</a>、<a href="https://labs.oracle.com/pls/apex/f?p=labs:49:::::P49_PROJECT_ID:13" target="_blank" rel="noopener">Parfait</a> 等，帮组早期发现潜在安全风险。</p>
</li>
<li><p>在代码 check-in 等关键环节，利用 hook 机制去调用规则检查工具，保证不合规范代码不进入代码库。</p>
</li>
</ul>
<h2 id="部署阶段"><a href="#部署阶段" class="headerlink" title="部署阶段"></a>部署阶段</h2><p>及时更新 JDK 安全漏洞补丁</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>推荐阅读《阿里巴巴 Java 开发手册》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mofei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫非的技术笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/" class="post-title-link" itemprop="url">Java 核心技术-应用开发篇</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-31 16:40:00" itemprop="dateCreated datePublished" datetime="2019-03-31T16:40:00+08:00">2019-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-10 19:58:30" itemprop="dateModified" datetime="2019-12-10T19:58:30+08:00">2019-12-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">后端笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="请介绍类加载过程，什么是双亲委派模型？"><a href="#请介绍类加载过程，什么是双亲委派模型？" class="headerlink" title="请介绍类加载过程，什么是双亲委派模型？"></a>请介绍类加载过程，什么是双亲委派模型？</h1><p>Java 类加载过程主要分为三个阶段：加载、链接、初始化。</p>
<ul>
<li><p>加载（Loading），将 Java 字节码数据从不同的数据源读取到 JVM 中并映射为 JVM 认可的数据结构（Class 对象）。数据源可能的形态包括 jar 文件、class 文件、网络数据源等；如果输入数据不是 ClassFile 结构则抛出 ClassFormatError 错误。加载阶段是用户可参与的阶段，也就是说我们可以自定义类加载器，去实现自己的类加载过程。</p>
</li>
<li><p>链接（Linking），核心步骤，将原始的类定义信息平滑的转化入 JVM 运行的过程中。</p>
<ul>
<li><p>验证（Verification）这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规的信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。</p>
</li>
<li><p>准备（Preparation）创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令。</p>
</li>
<li><p>解析（Resolution）在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。在<a href="[https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3"> Java 虚拟机</a>规范中，详细介绍了类、接口、方法和字段等各个方面的解析。</p>
</li>
</ul>
</li>
<li><p>初始化（Initialization）执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。</p>
</li>
</ul>
<h2 id="Java-8-之前的类加载器"><a href="#Java-8-之前的类加载器" class="headerlink" title="Java 8 之前的类加载器"></a>Java 8 之前的类加载器</h2><p>双亲委派模型，当类加载器（Class-Loader）试图加载某个类型的时候，先是委托给父加载器去完成，除非父加载器找不到相应类型，子加载器才会去加载。使用委派模型的目的是避免重复加载 Java 类型。</p>
<p><img src="/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/类加载器.png" alt="类加载器"></p>
<ul>
<li><p>启动类加载器（BootStrap Class-Loader）负责加载 jre/lib 目录下的 jar 文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"># 指定新的 bootclasspath，替换 java.* 包的内部实现</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath:&lt;your_boot_classpath&gt; your_App</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"># a 意味着 append，将指定目录添加到 bootclasspath 后面</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath/a:&lt;your_dir&gt; your_App</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"># p 意味着 prepend，将指定目录添加到 bootclasspath 前面</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath/p:&lt;your_dir&gt; your_App</span></pre></td></tr></table></figure>
</li>
<li><p>扩展类加载器（Extension or Ext Class-Loader）负责加载 jre/lib/ext 目录下的 jar 文件，所谓的 extension 机制，该目录可通过设置<code>javax.ext.dirs</code> 覆盖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">java -Djava.ext.dirs=your_ext_dir HelloWorld</span></pre></td></tr></table></figure>
</li>
<li><p>应用类加载器（Application or App Class-Loader）负责加载 classpath 中内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">java -Djava.system<span class="class">.<span class="keyword">class</span>.<span class="title">loader</span></span>=com.yourcorp.YourClassLoader HelloWorld</span></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="类加载机制的三个基本特征"><a href="#类加载机制的三个基本特征" class="headerlink" title="类加载机制的三个基本特征"></a>类加载机制的三个基本特征</h3><ul>
<li><p>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型， 是可能要加载用户代码的，比如 JDK 内部的 ServiceProvider/ServiceLoader机制，用户可以在标准 API 框架上，提供自己的实现，JDK 也需要提供些默认的参考实现。 例如，Java 中 JNDI、JDBC、文件系统、Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的<strong>上下文加载器</strong>。</p>
</li>
<li><p>可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑</p>
</li>
<li><p>单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</p>
</li>
</ul>
<h3 id="Java-9-平台模块化系统后的类加载器"><a href="#Java-9-平台模块化系统后的类加载器" class="headerlink" title="Java 9 平台模块化系统后的类加载器"></a>Java 9 平台模块化系统后的类加载器</h3><p>Java 9 ，由于 jigsaw 项目引入 Java 平台模块化系统（JPMS）,Java SE 源代码被划分为一系列模块。</p>
<p><img src="/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/java9模块.png" alt="Java平台模块化系统"></p>
<p>所以很多类加载器，类文件容器都发生了重大变化。</p>
<ul>
<li><p>前面提到的 -Xbootclasspath 参数不可用了。API 已经被划分到具体的模块，所以上文中，利 用“-Xbootclasspath/p”替换某个 Java 核心类型代码，实际上变成了对相应的模块进行的修补，可以采用下面的解决方案：</p>
<p>首先，确认要修改的类文件已经编译好，并按照对应模块（假设是 java.base）结构存放， 然后，给模块打补丁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">java --patch-<span class="keyword">module</span> java.base=your_patch yourApp</span></pre></td></tr></table></figure>
</li>
<li><p>扩展类加载器被重命名为平台类加载器（Platform Class-Loader），而且 extension 机制则被移除。也就意味着，如果我们指定 java.ext.dirs 环境变量，或者 lib/ext 目录存在，JVM 将直接返回.</p>
</li>
<li><p>部分不需要 AllPermission 的 Java 基础模块，被降级到平台类加载器中，相应的权限也被更精细粒度地限制起来。</p>
</li>
<li><p>rt.jar 和 tools.jar 同样是被移除了！JDK 的核心类库以及相关资源，被存储在 jimage 文件 中，并通过新的 JRT 文件系统访问，而不是原有的 JAR 文件系统。虽然看起来很惊人，但幸好对于大部分软件的兼容性影响，其实是有限的，更直接地影响是 IDE 等软件，通常只要升级到新版本就可以了。</p>
</li>
<li><p>增加了 Layer 的抽象， JVM 启动默认创建 BootLayer，开发者也可以自己去定义和实例化 Layer，可以更加方便的实现类似容器一般的逻辑抽象。</p>
</li>
</ul>
<p>结合了 Layer，目前的 JVM 内部结构就变成了下面的层次，内建类加载器都在 BootLayer 中， 其他 Layer 内部有自定义的类加载器，不同版本模块可以同时工作在不同的 Layer。</p>
<p><img src="/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/java9模块化.png" alt="Java9模块化"></p>
<h2 id="降低类加载的开销？"><a href="#降低类加载的开销？" class="headerlink" title="降低类加载的开销？"></a>降低类加载的开销？</h2><p>Java 需要类加载和解释、编译，这些都导致 Java 启动变慢。有没有通用办法，不需要代码和其他工作量，就能降低类加载的开销呢？</p>
<ul>
<li><p>AOT（Aheadof-Time Compilation）直接编译成机器码，降低解释和编译开销。但还在试验阶段，支持平台有限。</p>
</li>
<li><p>AppCDS（Application Class-Data Sharing），Java 5 中引进，但仅限于 Bootstrap Class-Loader。</p>
</li>
</ul>
<h3 id="AppCDS-基本原理和工作过程"><a href="#AppCDS-基本原理和工作过程" class="headerlink" title="AppCDS 基本原理和工作过程"></a>AppCDS 基本原理和工作过程</h3><p>首先，JVM 将类信息加载， 解析成为元数据，并根据是否需要修改，将其分类为 Read-Only 部分和 Read-Write 部分。然后，将这些元数据直接存储在文件系统中，作为所谓的 Shared Archive。命令很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Java -Xshare:dump -XX:+UseAppCDS -XX:SharedArchiveFile=&lt;jsa&gt;  \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">         -XX:SharedClassListFile=&lt;classlist&gt; -XX:SharedArchiveConfigFile=&lt;config_file&gt;</span></pre></td></tr></table></figure>

<p>第二，在应用程序启动时，指定归档文件，并开启 AppCDS。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Java -Xshare:on -XX:+UseAppCDS -XX:SharedArchiveFile=&lt;jsa&gt; yourApp</span></pre></td></tr></table></figure>

<p>通过上面的命令，JVM 会通过内存映射技术，直接映射到相应的地址空间，免除了类加载、解析等各种开销。</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><ul>
<li><p>什么是双亲委派模型，首先要知道什么是类加载器？</p>
<p>当某个类加载器要加载某个类型时，先是将加载任务委托给父加载器去完成，依次递归，只有当父加载器找不到指定类时（ClassNotFoundException）,子加载器才会尝试自己加载。</p>
</li>
<li><p>为什么需要双亲委派模型？</p>
<ul>
<li><p>避免重复加载。</p>
</li>
<li><p>避免恶意类的加载。</p>
</li>
<li><p>使用双亲委派模型的好处在于Java 类随着他的类加载器一起具备了优先级的层次关系</p>
</li>
</ul>
</li>
</ul>
<h1 id="有哪些方法可以在运行时动态生成一个Java类？"><a href="#有哪些方法可以在运行时动态生成一个Java类？" class="headerlink" title="有哪些方法可以在运行时动态生成一个Java类？"></a>有哪些方法可以在运行时动态生成一个Java类？</h1><ol>
<li><p>生成一段 Java 源代码，利用 ProcessBuilder 之类启动 javac 进程，指定 Java 源文件进行编译，最后利用类加载器，运行时加载即可。</p>
</li>
<li><p>借助<a href="https://docs.oracle.com/javase/8/docs/api/javax/tools/package-summary.html" target="_blank" rel="noopener"> Java Compiler API</a>  来实现，里面提供了与 javac 对等的编译功能。</p>
</li>
</ol>
<h2 id="重点掌握"><a href="#重点掌握" class="headerlink" title="重点掌握"></a>重点掌握</h2><ul>
<li><p>字节码和类加载到底是怎么无缝进行转换的？发生在整个类加载过程的哪一步？</p>
</li>
<li><p>如何利用字节码操纵技术，实现基本的动态代理逻辑？</p>
</li>
<li><p>除了动态代理，字节码操纵技术还有那些应用场景？</p>
</li>
</ul>
<h2 id="字节码转换为-Class-对象"><a href="#字节码转换为-Class-对象" class="headerlink" title="字节码转换为 Class 对象"></a>字节码转换为 Class 对象</h2><p>类从字节码到 Class 对象的转换，在类加载过程中是通过下面的方法提供的功能。</p>
<p>java.lang.ClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span>                   off, <span class="keyword">int</span> len,ProtectionDomain protectionDomain)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, java.nio.ByteBuffer b,ProtectionDomain protectionDomain)</span></pre></td></tr></table></figure>

<p>这里选取了最基础的两个典型的 defineClass 实现，Java 重载了几个不同的方法。</p>
<p>可以看出，只要能够生成出规范的字节码，不管是作为 byte 数组的形式，还是放到 ByteBuffer 里，都可以平滑地完成字节码到 Java 对象的转换过程。</p>
<p>JDK 提供的 defineClass 方法，最终都是本地代码实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass0(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len, ProtectionDomain pd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass1(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len, ProtectionDomain pd, String source);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass2(String name, java.nio.ByteBuffer b, <span class="keyword">int</span> off, <span class="keyword">int</span> len, ProtectionDomain pd,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">String source);</span></pre></td></tr></table></figure>

<h3 id="JDK-dynamic-proxy-的实现"><a href="#JDK-dynamic-proxy-的实现" class="headerlink" title="JDK dynamic proxy 的实现"></a>JDK dynamic proxy 的实现</h3><p><a href="http://hg.openjdk.java.net/jdk/jdk/file/29169633327c/src/java.base/share/classes/java/lang/reflect/Proxy.java" target="_blank" rel="noopener">jdk dynamic proxy </a> 来自 Java 9 ，对应逻辑是实现在 ProxyBuilder 这个静态内部类中，ProxyGenerator 生成字节码，并以 byte 数组的形式保存， 然后通过调用 Unsafe 提供的 defineClass 入口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Generate the specified proxy class.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    proxyName, interfaces.toArray(EMPTY_CLASS_ARRAY), accessFlags);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    Class&lt;?&gt; pc = UNSAFE.defineClass(proxyName, proxyClassFile,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                                    <span class="number">0</span>, proxyClassFile.length,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                                    loader, <span class="keyword">null</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    reverseProxyCache.sub(pc).putIfAbsent(loader, Boolean.TRUE);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> pc;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    * A ClassFormatError here means that (barring bugs in the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    * proxy class generation code) there was some other</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    * invalid aspect of the arguments supplied to the proxy</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    * class creation (such as virtual machine limitations</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    * exceeded).</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="Jdk-动态代理实现过程"><a href="#Jdk-动态代理实现过程" class="headerlink" title="Jdk 动态代理实现过程"></a>Jdk 动态代理实现过程</h3><ul>
<li><p>提供一个基础接口，作为被调用类型和代理类之间的统一入口。</p>
</li>
<li><p>实现 InvocationHandler，对代理对象方法的调用，会被分配到其 invoke 方法来真正实现动作。</p>
</li>
<li><p>通过 Proxy 类，调用器 newProxyInstance 方法，生成一个实现了相应基础接口的代理类实例。</p>
</li>
</ul>
<h2 id="字节码操纵逻辑"><a href="#字节码操纵逻辑" class="headerlink" title="字节码操纵逻辑"></a>字节码操纵逻辑</h2><p>JDK 内部动态代理的逻辑，可以参考java.lang.reflect.ProxyGenerator的内部实现。可以认为这是种另类的字节码操纵技术，其利用了 DataOutputStrem 提供的能力，配合 hard-coded 的各种 JVM 指令实现方法，生成所需的字节码数组。你可以参考下面的示例代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">codeLocalLoadStore</span><span class="params">(<span class="keyword">int</span> lvar, <span class="keyword">int</span> opcode, <span class="keyword">int</span> opcode_0,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                                DataOutputStream out)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">assert</span> lvar &gt;= <span class="number">0</span> &amp;&amp; lvar &lt;= <span class="number">0xFFFF</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 根据变量数值，以不同格式，dump 操作码</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (lvar &lt;= <span class="number">3</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        out.writeByte(opcode_0 + lvar);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lvar &lt;= <span class="number">0xFF</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        out.writeByte(opcode);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        out.writeByte(lvar &amp; <span class="number">0xFF</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 使用宽指令修饰符，如果变量索引不能用无符号 byte</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        out.writeByte(opc_wide);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        out.writeByte(opcode);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        out.writeShort(lvar &amp; <span class="number">0xFFFF</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="动态代码的生成发生在那个阶段？"><a href="#动态代码的生成发生在那个阶段？" class="headerlink" title="动态代码的生成发生在那个阶段？"></a>动态代码的生成发生在那个阶段？</h2><p>newProxyInstance 生成代理类实例的时候。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节有关动态代理技术及实现细节，常用的字节码操纵工具如 ASM、Javassit、cglib、JDK Proxy</p>
<p>Java 标准库也提供了与 javac 对等的编译器功能。</p>
<p>字节码操纵技术不仅仅用在动态代理，还应用在常见的ORM框架（MyBatis 用的javassit）、IOC容器、Mock 框架等；</p>
<h1 id="谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError"><a href="#谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError" class="headerlink" title="谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError?"></a>谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError?</h1><blockquote>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.5" target="_blank" rel="noopener">Java 虚拟机规范</a></p>
</blockquote>
<h2 id="运行时数据区-Run-Time-Data-Areas"><a href="#运行时数据区-Run-Time-Data-Areas" class="headerlink" title="运行时数据区(Run-Time Data Areas)"></a>运行时数据区(Run-Time Data Areas)</h2><ul>
<li><p>程序计数器（Program Counter Register）每个线程都有自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，即该线程的当前方法。在 JVM 规范中规定，如果线程执行的是非 native 方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是 native 方法，则程序计数器中的值是 undefined。</p>
</li>
<li><p>Java 虚拟机栈（Java Virtual Machine Stack）也叫 Java 栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用。在一个时间点，对应的只会有一个活动的栈帧，通常叫作当前帧，方法所在的类叫作当前类。如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，成为新的当前帧，一直到它返回结果或者执行结束<strong>。JVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈。</strong>栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。</p>
</li>
<li><p>堆（Heap）<strong>Java 内存管理的核心区域，用来存放对象实例和数组。</strong>被所有线程共享，虚拟机启动时创建可以指定“Xmx”之类参数指定堆空间大小。堆也是垃圾收集器重点照顾的区域，所以堆内空间还会被不同的垃圾收集器进行进一步的细分，最有名的就是新生代、老年代的划分。</p>
</li>
<li><p>方法区（Method Area）<strong>用来存储元数据信息，类结构、运行时产量池、字段、方法代码等。</strong>被所有线程共享，虚拟机启动时创建。方法区逻辑上是堆的一部分，但是可以通过简单实现让垃圾收集器不碰它。由于早期的 Hotspot JVM 实现，很多人习惯于将方法区称为永久代（Permanent Generation）。Oracle JDK 8 中将永久代移除，同时增加了元数据区（Metaspace）。</p>
</li>
<li><p>运行时常量池（Run-Time Constant Pool）是方法区的一部分，每个运行时常量池都是从 Java 虚拟机的方法区域中分配的。当Java虚拟机创建类或接口时，将构造类或接口的运行时常量池。</p>
</li>
<li><p>本地方法栈（Native Method Stack）和 Java 虚拟机栈是非常相似的，支持对本地方法的调用，也是每个线程都会创建一个。在 Oracle Hotspot JVM 中，本地方法栈和 Java 虚拟机栈是在同一块儿区域，这完全取决于技术实现的决定，并未在规范中强制。</p>
</li>
</ul>
<p><img src="/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/JVM内存区域.png" alt="JVM内存区域"></p>
<h2 id="哪些区域可能发生OutOfMemoryError"><a href="#哪些区域可能发生OutOfMemoryError" class="headerlink" title="哪些区域可能发生OutOfMemoryError?"></a>哪些区域可能发生OutOfMemoryError?</h2><p>除了程序计数器以外，其他区域都可能发生 OutOfMemoryError。</p>
<ul>
<li><p>堆内存不足，抛出错误信息是“java.lang.OutOfMemoryError:Java heap space”</p>
</li>
<li><p>Java 虚拟机栈和本地方法栈，这里要稍微复杂一点。如果我们写一段程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。类似这种情况，JVM 实际会抛出 StackOverFlowError；当然，如果 JVM 试图去扩展栈空间的时候失败，则会抛出 OutOfMemoryError。</p>
</li>
<li><p>对于老版本的 Oracle JDK，因为永久代的大小是有限的，并且 JVM 对永久代垃圾回收（如， 常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OutOfMemoryError 也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似 Intern 字符串缓存占用太多空间，也会导致 OOM 问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError: PermGen space”。</p>
</li>
<li><p>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的 OOM 有所改观，出现 OOM，异常信息则变成了：“java.lang.OutOfMemoryError: Metaspace”。</p>
</li>
<li><p>直接内存不足，也会导致 OOM</p>
</li>
</ul>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>在试图分配一个 100M bytes 大数组的时候发生了 OOME，但是 GC 日志显示，明明堆上还有远不止 100M 的空间， 你觉得可能问题的原因是什么？想要弄清楚这个问题，还需要什么信息呢？</p>
<ul>
<li><p>从 JVM 的角度来看：</p>
<p>要看下新生代和老年代的垃圾回收机制是什么。如果新生代是 serial，会默认使用 copying 算法，利用两块 eden 和survivor 来进行处理。但是默认当遇到超大对象时，会直接将超大对象放置到老年代中，而不用走正常对象的存活次数记录。因为要放置的是一个 byte 数组，那么必然需要申请连续的空间，当空间不足时，会进行 gc 操作。这里又需要看老年代的 gc 机制是哪一种。如果是 serial old，那么会采用 mark compat，会进行整理，从而整理出连续空间，如果还不够，说明是老年代的空间不够，所谓的堆内存大于 100m 是新+老共同的结果。如果采用的是cms(concurrent mark sweep)，那么只会标记清理，并不会压缩，所以内存会碎片化，同时可能出现浮游垃圾。如果是 cms 的话，即使老年代的空间大于100m，也会出现没有连续的空间供该对象使用。</p>
</li>
<li><p>从垃圾收集器角度来看：  首先，数组的分配是需要连续的内存空间的（据说，有个别非主流JVM支持大数组用不连续的内存空间分配🤔）。所以：  </p>
<ul>
<li><p>对于使用年轻代和老年代来管理内存的垃圾收集器，堆大于 100M，表示的是新生代和老年代加起来总和大于100M，而新生代和老年代各自并没有大于 100M 的连续内存空间。  进一步，又由于大数组一般直接进入老年代（会跳过对对象的年龄的判断），所以，是否可以认为老年代中没有连续大于 100M 的空间呢。  </p>
</li>
<li><p>对于 G1 这种按 region 来管理内存的垃圾收集器，可能的情况是没有多个连续的 region，它们的内存总和大于 100M。  当然，不管是哪种垃圾收集器以及收集算法，当内存空间不足时，都会触发 GC，只不过，可能 GC 之后，还是没有连续大于 100M 的内存空间，于是 OOM了。</p>
</li>
</ul>
</li>
</ul>
<h1 id="如何监控和诊断JVM堆内和堆外内存使用？"><a href="#如何监控和诊断JVM堆内和堆外内存使用？" class="headerlink" title="如何监控和诊断JVM堆内和堆外内存使用？"></a>如何监控和诊断JVM堆内和堆外内存使用？</h1><p>了解 JVM 内存的方法很多，具体能力范围也有区别：</p>
<ul>
<li><p>图形化工具：JConsole、JMC、 VisualVM（Oracle JDK 9 不再包含） ，其中 JMC 和 JConsole 统计部分非堆内存。</p>
</li>
<li><p>命令行工具：jstat 、 jmap，可查看堆、方法区等使用数据。</p>
</li>
<li><p>JavaEE 服务器也提供内存管理功能，如 Tomcat 、 WebLogic</p>
</li>
<li><p>GC 日志的输出也同样包含丰富的内存信息。</p>
</li>
<li><p>NMT（Native Memory Tracking）监控堆外内存中的直接内存。</p>
</li>
</ul>
<h2 id="重点掌握-1"><a href="#重点掌握-1" class="headerlink" title="重点掌握"></a>重点掌握</h2><ul>
<li><p>细化对各部分内存区域的理解，堆内结构是怎样的？如何通过参数调整。</p>
</li>
<li><p>堆外内存到底包括那些部分？具体大小受那些因素影响？</p>
</li>
</ul>
<h2 id="堆内部结构"><a href="#堆内部结构" class="headerlink" title="堆内部结构"></a>堆内部结构</h2><p>对于堆内存，我在上一讲介绍了最常见的新生代和老年代的划分，其内部结构随着 JVM 的发展和新 GC 方式的引入，可以有不同角度的理解，下图就是以年代视角的堆结构示意图。</p>
<p><img src="/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/堆内结构.png" alt="堆内结构"></p>
<p>关于 Virtual 区域：在 JVM 内部，如果 Xms 小于 Xmx，堆的大小并不会直接扩展到其上限，也就是说保留的空间（reserved）大于实际能够使用的空间（committed）。当内存需求不断增长的时候，JVM 会逐渐扩展新生代等区域的大小，所以 Virtual 区域代表的就是暂时不可用（uncommitted）的空间。</p>
<p>按照通常的 GC 年代方式划分，Java 堆内分为：</p>
<ul>
<li><p>新生代</p>
<p><strong>大部分对象的创建和销毁都在新生代区域，绝大多数对象生命周期是很短暂的</strong>。其内部有分为 Eden 区域，作为对象初始化分配的区域；两个 Survivor，也叫 from、to 区域，被用来放置 Minor GC 中保留下来的对象。</p>
<ul>
<li><p>JVM 会随意选一个 Survivor 区域作为“to”，然后会在 GC 过程中进行区域间拷贝，也就是将 Eden 和 from 区域中存活下来的的对象，拷贝到这个 to 区域。这种设计主要是为了防止内存的碎片化，并进一步清理无用对象。</p>
</li>
<li><p>从内存模型的角度，又对 Eden 区域继续进行划分，Hotspot JVM 还有一个概念叫做 Thread Local Allocation Buffer（TLAB）。这是 JVM 为每个线程分配的一个私有缓存区域，否则，多线程同时分配内存时，为避免操作同一地址，可能需要使用加锁等机制，进而影响分配速度，你可以参考下面的示意图。从图中可以看出，TLAB 仍然在堆上，它是分配在 Eden 区域内的。其内部结构比较直观易懂，start、end 就是起始地址，top（指针）则表示已经分配到哪里了。所以我们分配新对象，JVM 就会移动 top，当 top 和 end 相遇时，即表示该缓存已满，JVM 会试图再从 Eden 里分配一块儿。</p>
<p><img src="/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/Eden区域.png" alt="Eden区域"></p>
</li>
</ul>
</li>
<li><p>老年代</p>
<p><strong>用来存放生命周期比较长的对象，也就是从 Survivor 区域拷贝过来的对象</strong>。特殊情况下，如果对象较大 JVM 会试图直接分配在 Eden 其他位置；如果对象太大，在新生代找不到足够长的连续空间，JVM 就会直接分配到老年代。</p>
</li>
<li><p>永久代</p>
<p>早期 Hotspot JVM 的方法去实现方式，用来储存 Java 类元数据、常量池、Intern 字符串池，JDK 8 之后就不存在了。</p>
</li>
</ul>
<h3 id="利用-JVM-参数影响堆和内部区域大小。"><a href="#利用-JVM-参数影响堆和内部区域大小。" class="headerlink" title="利用 JVM 参数影响堆和内部区域大小。"></a>利用 JVM 参数影响堆和内部区域大小。</h3><ul>
<li><p>最大堆体积 ，<code>-Xmx value</code></p>
</li>
<li><p>初始最小的堆体积，<code>-Xms value</code></p>
</li>
<li><p>老年代和新生代的比例，<code>-XX:NewRatio=value</code>，默认数值是 2 ，意味着老年代是新生代的 2 倍大；</p>
</li>
<li><p>指定具体的内存大小数值，<code>-XX:NewSize=value</code> 代替用比例的方式调整新生代的大小。</p>
</li>
<li><p>Eden 和 Survivor 的大小是按照比例设置的，如果 SurvivorRatio 是 8，那么 Survivor 区域就是 Eden 的 1/8 大小，也就是新生代的 1/10，因为 YoungGen=Eden + 2*Survivor，JVM 参数格式是，<code>-XX:SurvivorRatio=value</code></p>
</li>
<li><p>TLAB 也可以调整，参考<a href="https://blogs.oracle.com/jonthecollector/the-real-thing" target="_blank" rel="noopener">资料</a></p>
</li>
</ul>
<h2 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h2><p>Java 分配堆外内存的两种方式如下：</p>
<ul>
<li><p><code>java.nio.ByteBuffer.allocateDirect</code> 获得DirectByteBuffer 对象实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Primary constructor</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//1. 调用基类构造为字段赋值。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> ps = Bits.pageSize();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//2. 预先分配内存</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        Bits.reserveMemory(size, cap);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//3. unsafe 分配内存。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">long</span> base = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            base = unsafe.allocateMemory(size);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            Bits.unreserveMemory(size, cap);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">throw</span> x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//4. 为已分配内存初始值为0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Round up to page boundary</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            address = base;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//5. 创建Cleaner 对象，用来释放堆外内存。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        att = <span class="keyword">null</span>;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
</li>
<li><p><code>sun.misc.Unsafe.allocateMemory</code> 分配内存。</p>
</li>
</ul>
<h3 id="堆外内存适用场景"><a href="#堆外内存适用场景" class="headerlink" title="堆外内存适用场景"></a>堆外内存适用场景</h3><ul>
<li><p>适合长生命周期存在的对象。</p>
</li>
<li><p>适合网络 IO 或外部文件读写。</p>
</li>
<li><p>堆外内存能有效避免因 GC 导致的暂停问题。</p>
</li>
</ul>
<h2 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h2><p>除了使用工具对 Java 内存进行监控外，还有哪些方式能做到呢？</p>
<p>java.lang.Runtime 类中包含如下方法可以监控 Java 内存的使用情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回 Java 虚拟机可用的内存容量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">freeMemory</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回 Java 虚拟机内存总容量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">totalMemory</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回Java虚拟机将占用的最大内存</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">maxMemory</span><span class="params">()</span></span>;</span></pre></td></tr></table></figure>

<p>为什么在标记垃圾的时候，需要stop the world？</p>
<p>以 cms 为例，它有不同的 mark： initial mark，conc mark， remark；conc 时候不需要 stw；其他需要短暂 stw，这样引用关系才不变，另外效率也高</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html" target="_blank" rel="noopener">JConsole 文档</a></p>
<p><a href="https://docs.oracle.com/cd/E15289_01/JRMCI/toc.htm" target="_blank" rel="noopener">JRockit Mission Control 文档</a></p>
<p>补充一些关于Eden、两个 Survivor 的细节。</p>
<ul>
<li><p>大部分对象创建都是在 Eden 的，除了个别大对象。</p>
</li>
<li><p>Minor GC 开始前，to-survivor 是空的，from-survivor 是有对象的。</p>
</li>
<li><p>Minor GC 后，Eden 的存活对象都 copy 到 to-survivor 中，from-survivor 的存活对象也复制 to-survivor 中。其中所有对象的年龄+1</p>
</li>
<li><p>from-survivor 清空，成为新的 to-survivor，带有对象的 to-survivor 变成新的 from-survivor。重复回到步骤2</p>
</li>
</ul>
<h1 id="Java常见的垃圾收集器有哪些？"><a href="#Java常见的垃圾收集器有哪些？" class="headerlink" title="Java常见的垃圾收集器有哪些？"></a>Java常见的垃圾收集器有哪些？</h1><p>垃圾收集器（GC，Garbage Collector）和 JVM 紧密相关，不同厂商有不同版本的 JVM 存在较大的差异性。</p>
<ul>
<li><p>垃圾收集算法？如何判断一个对象是否可以回收？</p>
</li>
<li><p>垃圾收集器的工作流程？</p>
</li>
</ul>
<h2 id="多维度分析垃圾收集"><a href="#多维度分析垃圾收集" class="headerlink" title="多维度分析垃圾收集"></a>多维度分析垃圾收集</h2><ul>
<li><p>按线程数目，可分为串行和并行垃圾收集器。在并行能力较强的 CPU 使用并行垃圾收集器可缩短应用程序停顿时间。</p>
</li>
<li><p>按工作模式，可分为并发式和独占式垃圾收集器。并发式垃圾收集器与应用程序交替工作，尽量减少应用停顿时间，独占式垃圾收集器（Stop-the-world）一旦运行，就停止应用程序中所有线程，直到垃圾收集工作完成。</p>
</li>
<li><p>按碎片处理方式，可分为压缩式和非压缩式垃圾收集器。压缩式垃圾收集器在工作完成之后，对存活对象进行压缩整理，消除收集后的碎片。</p>
</li>
<li><p>按工作的内存区域，可分为老年代和新生代垃圾收集器。</p>
</li>
</ul>
<h2 id="常见的垃圾收集器"><a href="#常见的垃圾收集器" class="headerlink" title="常见的垃圾收集器"></a>常见的垃圾收集器</h2><ul>
<li><p>Serial GC，两个显著特点：第一，使用单线程进行垃圾收集；第二，它以独占的垃圾收集；进行垃圾收集工作时 Java 应用程序中的线程需要暂停，直到垃圾收集工作完成，也就是常说的（Stop-The-World）</p>
<p><code>-XX:+UseSerialGC</code></p>
<ul>
<li><p>新生代串行收集器，采用复制（Copying）算法。</p>
</li>
<li><p>老年代串行收集器，标记 - 压缩（Mark-Compact）算法；垃圾收集需要比新生代垃圾收集更长的时间。</p>
</li>
</ul>
</li>
<li><p>ParNew GC，新生代 GC 的实现，是 Serial GC 的多线程版本，常见的应用场景是配合老年代的 CMS GC 工作。</p>
<p><code>-XX:+UseConcMarkSweepGC -XX:+UseParNewGC</code></p>
</li>
<li><p>CMS（Concurrent Mark Sweep），<strong>关注减少系统停顿时间（对响应时间的 Web 等应用非常重要），采用标记-清除（Makr - Sweep）算法（缺点是存在内存碎片化），使用多线程并发回收的垃圾收集器。</strong>CMS 主要工作步骤：初始标记、并发标记、重新标记、清除并发和并发重置。初始标记和重新标记是独占系统资源，并发标记和并发重置是可以和用户线程一起执行。采用标记-清除算法，将会产生大量内存碎片。由于CMS 和应用程序线程并发执行，也就意味着相互抢占 CPU ，工作期间对应用程序吞吐量造成影响。</p>
</li>
<li><p>Parrallel GC，作为早期 JDK8 等版本，server 模式 JVM 的默认 GC， 吞吐量优先的 GC。并行收集器和串行收集器差不多一样，主要的区别在于多线程。在并发能力较强的 CPU 上产生的停顿时间更短，反之不如串行收集器。</p>
<p><code>-XX:+UseParallelGC</code> 开启并行回收器；<code>XX:ParallelGCThreads</code>指定并行收集器工作的线程数目，建议与 CPU 数量相当，避免过多的线程数影响垃圾收集性能。</p>
<ul>
<li><p>新生代并行收集器，采用复制算法</p>
</li>
<li><p>老年代并行收集器，采用标记-压缩算法</p>
</li>
</ul>
</li>
<li><p>G1 GC，作为 JDK 9 中默认的 GC，同时 CMS 并标记为废弃（deprecated）。<strong>G1 作为一款服务器的垃圾收集器，重点关注吞吐量和停顿。</strong>G1 GC 仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一 个个 region。Region 之间是复制算法，但整体上实际可看作是标记 - 整理（MarkCompact）算法，可以有效地避免内存碎片，尤其是当 Java 堆非常大的时候，G1 的优势更加明显。使用参数 <code>-XX:+UnlockExperimentalVMOptions –XX:+UseG1GC</code>来启用 G1 回收器，设置 G1 回收器的目标停顿时间：<code>-XX:MaxGCPauseMills=20,-XX:GCPauseIntervalMills=200</code>。</p>
</li>
</ul>
<h2 id="垃圾收集原理和基础概念"><a href="#垃圾收集原理和基础概念" class="headerlink" title="垃圾收集原理和基础概念"></a>垃圾收集原理和基础概念</h2><p>自动垃圾收集前需要明确哪些内存可以被释放，内存结构和类加载。</p>
<p>主要有两方面，存放在堆上的  Java 对象实例；方法区中的元数据信息。</p>
<ul>
<li><p><strong>引用计数</strong>，引用计数的难题在于处理“循环引用”关系，所以 Java 垃圾收集器没有采用这种算法。</p>
<p>引用计数器的实现很简单，对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1，当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，则对象 A 就不可能再被使用。</p>
<p>所谓<strong>循环引用</strong>，对象 A 和对象 B，对象 A 中含有对象 B 的引用，对象 B 中含有对象 A 的引用。此时，对象 A 和对象 B 的引用计数器都不为 0。但是在系统中却不存在任何第 3 个对象引用了 A 或 B。也就是说，A 和 B 是应该被回收的垃圾对象，但由于垃圾对象间相互引用，从而使垃圾回收器无法识别，引起内存泄漏。</p>
</li>
<li><p><strong>可达性分析</strong>，将对象及其引用关系看作一个图，选定活动的对象作为 GC Roots，然后跟踪引用链条，若一个对象和 GC Roots 之间不可达，也就是不存在引用链条，就可以认为是可回收的对象。JVM 会把虚拟机栈中和本地方法栈中长在引用的对象、静态属性引用的对象和常量，作为 GC Roots。</p>
</li>
<li><p>复制（Copying）将内存分为两块区域，每次只使用其中一块区域，进行垃圾回收时将活着的对象复制到另一块区域，复制过程将对象顺序放置（<strong>避免内存碎片化</strong>），然后清除正在使用的内存块中的所有对象，交换两个内存角色，完成垃圾回收。<strong>其缺陷是在进行复制需要提前预留内存空间；对于 G1这种大量拆分成多个 region 的 GC ，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，这种开销也不小，无论是内存占用还是时间开销。</strong></p>
<p>Java 的新生代串行垃圾回收器中使用了复制算法的思想。新生代分为 eden 空间、from 空间、to 空间 3 个部分。其中 from 空间和 to 空间可以视为用于复制的两块大小相同、地位相等，且可进行角色互换的空间块。from 和 to 空间也称为 survivor 空间，即幸存者空间，用于存放未被回收的对象。</p>
<p>在垃圾回收时，eden 空间中的存活对象会被复制到未使用的 survivor 空间中（假设是 to），正在使用的 survivor 空间 （假设是 from)）中的年轻对象也会被复制到 to 空间中 （大对象，或者老年对象会直接进入老年代，如果 to 空间已满，则对象也会直接进入老年代）。此时，eden 空间和 from 空间中的剩余对象就是垃圾对象，可以直接清空，to 空间则存放此次回收后的存活对象。这种改进的复制算法既保证了空间的连续性，又避免了大量的内存空间浪费。</p>
<p>新生代 GC 都是基于复制算法。</p>
</li>
<li><p>标记 - 清除（Mark-Sweep）在标记阶段首先通过根节点，标记所有从根节点开始的较大对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。<strong>该算法最大的问题是存在大量的空间碎片，因为回收后的空间是不连续的。</strong>在对象的堆空间分配过程中，尤其是大对象的内存分配，不连续的内存空间的工作效率要低于连续的空间。</p>
</li>
<li><p>标记 - 压缩 （Mark - Compact）和标记-清除算法类似，在此基础上做了些优化。首先从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。</p>
</li>
<li><p>增量算法（Incremental Collecting）为了减少系统的停顿时间，让垃圾收集和应用线程交替执行。每次，垃圾收集线程收集一小片区域的内存空间，接着切换到应用程序线程。但是线程切换和上下文转换的消耗，造成垃圾回收总成本上升，系统吞吐量下降。</p>
</li>
<li><p>分代（Generational Collecting）<strong>根据垃圾回收对象的特点，选择合适的回收算法。</strong>它将内存区间根据对象的特点分成几块，根据每块内存区间的特点，使用不同的回收算法，以提高垃圾回收的效率。以 Hot Spot 虚拟机为例，它将所有的新建对象都放入称为新生代的内存区域，<strong>新生代的特点是对象会很快回收，因此，新生代选择效率较高的复制算法</strong>。当一个对象经过几次回收后依然存活，对象就会被放入称为老年代的内存空间。在老年代中，几乎所有的对象都是经过几次垃圾回收后依然得以幸存的。因此，可以认为这些对象在一段时期内，甚至在应用程序的整个生命周期中，将是常驻内存的。如果依然使用复制算法回收老生代，将需要复制大量对象。再加上老生代的回收性价比也要低于新生代，因此这种做法也是不可取的。根据分代的思想，<strong>可以对老年代的回收使用与新生代不同的标记-压缩算法，以提高垃圾回收效率。</strong></p>
</li>
</ul>
<h2 id="垃圾收集过程"><a href="#垃圾收集过程" class="headerlink" title="垃圾收集过程"></a>垃圾收集过程</h2><p>第一，Java 应用不断创建对象，通常都是分配在 Eden 区域，当其空间占用达到一定阈值时，触发 minor GC。仍然被引用的对象（绿色方块）存活下来，被复制到 JVM 选择的 Survivor 区域，而没有被引用的对象（黄色方块）则被回收。注意，我给存活对象标记了“数字 1”，这是为了表明对象的存活时间。</p>
<p><img src="/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/Eden1.png" alt="Eden1"></p>
<p>第二， 经过一次 Minor GC，Eden 就会空闲下来，直到再次达到 Minor GC 触发条件，这时候，另外一个 Survivor 区域则会成为 to 区域，Eden 区域的存活对象和 From 区域对象，都会被复制到 to 区域，并且存活的年龄计数会被加 1。</p>
<p><img src="/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/Eden2.png" alt="Eden2"></p>
<p>第三， 类似第二步的过程会发生很多次，直到有对象年龄计数达到阈值，这时候就会发生所谓的晋升（Promotion）过程，如下图所示，超过阈值的对象会被晋升到老年代。这个阈值是可以通过参数指定：<code>-XX:MaxTenuringThreshold=&lt;N&gt;</code></p>
<p><img src="/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/Eden3.png" alt="Eden3"></p>
<p>后面就是老年代 GC，具体取决于选择的 GC 选项，对应不同的算法。下面是一个简单标记 - 压缩算法过程示意图，老年代中的无用对象被清除后， GC 会将对象进行整理，以防止内存碎片化。</p>
<p><img src="/2019/03/31/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AF%87/老年代标记-压缩.png" alt="老年代标记-压缩"></p>
<h2 id="GC-新的发展"><a href="#GC-新的发展" class="headerlink" title="GC 新的发展"></a>GC 新的发展</h2><p>JDK 11 中有新增了 2 中 GC 方式。</p>
<ul>
<li><p>Epsilon GC，控制内存分配，不做垃圾收集。一旦 Java 堆空间被耗尽，JVM 直接关闭。</p>
</li>
<li><p>ZGC ，Oracle 开源产品，支持 T bytes 级别的堆大小，大部分情况下延迟不会超过 10 ms，目前处于试验阶段，仅支持 Linux 64 位平台。</p>
</li>
</ul>
<h2 id="思考题-2"><a href="#思考题-2" class="headerlink" title="思考题"></a>思考题</h2><p>通常使用什么参数去打开 GC 日志呢？还会额外添加哪些选项？</p>
<p><a href="https://dzone.com/articles/disruptive-changes-to-gc-logging-in-java-9" target="_blank" rel="noopener">参考资料</a></p>
<p><a href="http://openjdk.java.net/jeps/158" target="_blank" rel="noopener">JEP 158: Unified JVM Logging</a></p>
<p>Enable Java 8 GC Logs:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails -Xloggc:&lt;gc-log-file-path&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC -Xloggc:&lt;gc-log-file-path&gt;</span></pre></td></tr></table></figure>

<p>Enable Java 9 GC Logs：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">-Xlog:gc*:file=&lt;gc-log-file-path&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">-Xlog:gc:file=&lt;gc-log-file-path&gt;</span></pre></td></tr></table></figure>

<h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><p><a href="https://www.cnblogs.com/cxxjohnson/p/8625713.html" target="_blank" rel="noopener">Java虚拟机垃圾回收(三) 7种垃圾收集器</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-JVMGarbageCollection/index.html" target="_blank" rel="noopener"> JVM 垃圾回收器分类</a></p>
<p><a href="http://www.importnew.com/23752.html" target="_blank" rel="noopener"> Java GC算法 垃圾收集器</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/24/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mofei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫非的技术笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/24/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87%E4%BA%8C/" class="post-title-link" itemprop="url">Java 核心技术-进阶篇二</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-24 21:10:00" itemprop="dateCreated datePublished" datetime="2019-03-24T21:10:00+08:00">2019-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-10 19:58:41" itemprop="dateModified" datetime="2019-12-10T19:58:41+08:00">2019-12-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">后端笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么情况下Java程序会产生死锁？如何定位、修复？"><a href="#什么情况下Java程序会产生死锁？如何定位、修复？" class="headerlink" title="什么情况下Java程序会产生死锁？如何定位、修复？"></a>什么情况下Java程序会产生死锁？如何定位、修复？</h1><p><img src="/2019/03/24/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87%E4%BA%8C/死锁.png" alt="死锁"></p>
<p>synchronized 关键字用于类或方法线程安全，同一时刻有且只有一个线程竞争到锁执行同步方法，其他线程必须等待该线程释放锁之后其中的一个线程才能竞争到锁。</p>
<ul>
<li><p>死锁反生在多线程环境，由于循环依赖导致彼此一直处于等待状态。</p>
</li>
<li><p>死锁不只发生在线程之间，资源独占的进程也会发生死锁情况。</p>
</li>
</ul>
<h2 id="重点掌握"><a href="#重点掌握" class="headerlink" title="重点掌握"></a>重点掌握</h2><ul>
<li><p>编写死锁案例，考察基本的线程编程？</p>
</li>
<li><p>诊断死锁有哪些工具，如果是分布式环境，可能更关心能否用 API 实现吗？</p>
</li>
<li><p>如何在编程中尽量避免一些典型场景的死锁，有其他工具辅助吗？</p>
</li>
</ul>
<h2 id="死锁案例"><a href="#死锁案例" class="headerlink" title="死锁案例"></a>死锁案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Utils</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> minllis)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            Thread.sleep(minllis);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shared</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(Shared shared2)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">       System.out.println(<span class="string">"test1-begin"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">       Utils.sleep(<span class="number">1000</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">       shared2.test2(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">       System.out.println(<span class="string">"test1-end"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(Shared shared1)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">       System.out.println(<span class="string">"test2-begin"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">       Utils.sleep(<span class="number">1000</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">       shared1.test1(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">       System.out.println(<span class="string">"test2-end"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> Shared s1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> Shared s2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread1</span><span class="params">(Shared s1,Shared s2)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.s1 = s1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.s2 = s2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        s1.test1(s2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> Shared s1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> Shared s2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread2</span><span class="params">(Shared s1,Shared s2)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.s1 = s1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.s2 = s2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        s2.test2(s1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">        Shared s1 = <span class="keyword">new</span> Shared();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">        Shared s2 = <span class="keyword">new</span> Shared();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">        Thread1 t1 = <span class="keyword">new</span> Thread1(s1,s2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">        Thread2 t2 = <span class="keyword">new</span> Thread2(s1,s2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">        t1.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">        t2.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">        t1.join();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">        t2.join();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如上代码，编译运行后打印结果:</p>
<p>Thread2obtained:lockB</p>
<p>Thread1obtained:lockA</p>
<h2 id="定位死锁"><a href="#定位死锁" class="headerlink" title="定位死锁"></a>定位死锁</h2><h3 id="方法一：使用-jstack-命令"><a href="#方法一：使用-jstack-命令" class="headerlink" title="方法一：使用 jstack 命令"></a>方法一：使用 jstack 命令</h3><p><strong>区别线程状态 》 查看等待目标 》 对比 Monitor 等持有状态</strong></p>
<ol>
<li><p>使用 jps 命令定位 Java 进程 PID</p>
</li>
<li><p>使用 jstack 定位，jstack 1760</p>
</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">PS E:\&gt; jps</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="number">17412</span> org.eclipse.equinox.launcher_1.<span class="number">5.300</span>.v20190213-<span class="number">1655</span>.jar</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="number">22524</span> DeadLock</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="number">24476</span> Jps</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="number">3052</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">PS E:\&gt; jstack <span class="number">22524</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">49</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">Full thread dump Java HotSpot(TM) <span class="number">64</span>-Bit Server VM (<span class="number">25.72</span>-b05 mixed mode):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="string">"Thread-1"</span> <span class="comment">#12 prio=5 os_prio=0 tid=0x000000001e66b800 nid=0x4040 waiting for monitor entry [0x000000001f41f000]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        at Shared.test1(DeadLock.java:<span class="number">14</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        - waiting to lock &lt;<span class="number">0</span>x000000076b3e1f50&gt; (a Shared)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        at Shared.test2(DeadLock.java:<span class="number">23</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        - locked &lt;<span class="number">0</span>x000000076b3e1f60&gt; (a Shared)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        at Thread2.run(DeadLock.java:<span class="number">48</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="string">"Thread-0"</span> <span class="comment">#11 prio=5 os_prio=0 tid=0x000000001e66a800 nid=0x69e0 waiting for monitor entry [0x000000001f31f000]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        at Shared.test2(DeadLock.java:<span class="number">21</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        - waiting to lock &lt;<span class="number">0</span>x000000076b3e1f60&gt; (a Shared)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        at Shared.test1(DeadLock.java:<span class="number">16</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        - locked &lt;<span class="number">0</span>x000000076b3e1f50&gt; (a Shared)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        at Thread1.run(DeadLock.java:<span class="number">36</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="string">"Service Thread"</span> <span class="comment">#10 daemon prio=9 os_prio=0 tid=0x000000001e5e2800 nid=0xa30 runnable [0x0000000000000000]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">   java.lang.Thread.State: RUNNABLE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="string">"C1 CompilerThread3"</span> <span class="comment">#9 daemon prio=9 os_prio=2 tid=0x000000001e564000 nid=0x4a50 waiting on condition [0x0000000000000000]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">   java.lang.Thread.State: RUNNABLE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="string">"C2 CompilerThread2"</span> <span class="comment">#8 daemon prio=9 os_prio=2 tid=0x000000001e55a800 nid=0x3de8 waiting on condition [0x0000000000000000]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">   java.lang.Thread.State: RUNNABLE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="string">"C2 CompilerThread1"</span> <span class="comment">#7 daemon prio=9 os_prio=2 tid=0x000000001e54d800 nid=0x3148 waiting on condition [0x0000000000000000]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">   java.lang.Thread.State: RUNNABLE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="string">"C2 CompilerThread0"</span> <span class="comment">#6 daemon prio=9 os_prio=2 tid=0x000000001e54b000 nid=0x6b60 waiting on condition [0x0000000000000000]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">   java.lang.Thread.State: RUNNABLE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="string">"Attach Listener"</span> <span class="comment">#5 daemon prio=5 os_prio=2 tid=0x000000001e543800 nid=0x5d7c waiting on condition [0x0000000000000000]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">   java.lang.Thread.State: RUNNABLE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"><span class="string">"Signal Dispatcher"</span> <span class="comment">#4 daemon prio=9 os_prio=2 tid=0x000000001e4f7000 nid=0x43e8 runnable [0x0000000000000000]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">   java.lang.Thread.State: RUNNABLE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line"><span class="string">"Finalizer"</span> <span class="comment">#3 daemon prio=8 os_prio=1 tid=0x000000001e4e1000 nid=0x4aa8 in Object.wait() [0x000000001e9be000]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        at java.lang.Object.wait(Native Method)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">        - waiting on &lt;<span class="number">0</span>x000000076b308e88&gt; (a java.lang.ref.ReferenceQueue<span class="variable">$Lock</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:<span class="number">143</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">        - locked &lt;<span class="number">0</span>x000000076b308e88&gt; (a java.lang.ref.ReferenceQueue<span class="variable">$Lock</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:<span class="number">164</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">        at java.lang.ref.Finalizer<span class="variable">$FinalizerThread</span>.run(Finalizer.java:<span class="number">209</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line"><span class="string">"Reference Handler"</span> <span class="comment">#2 daemon prio=10 os_prio=2 tid=0x0000000002ba8800 nid=0x5104 in Object.wait()</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>x000000001e4be000]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">        at java.lang.Object.wait(Native Method)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">        - waiting on &lt;<span class="number">0</span>x000000076b306af8&gt; (a java.lang.ref.Reference<span class="variable">$Lock</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">        at java.lang.Object.wait(Object.java:<span class="number">502</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">        at java.lang.ref.Reference.tryHandlePending(Reference.java:<span class="number">191</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">        - locked &lt;<span class="number">0</span>x000000076b306af8&gt; (a java.lang.ref.Reference<span class="variable">$Lock</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">        at java.lang.ref.Reference<span class="variable">$ReferenceHandler</span>.run(Reference.java:<span class="number">153</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00000000029ae000 nid=0x6020 in Object.wait() [0x0000000002aaf000]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">        at java.lang.Object.wait(Native Method)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">        - waiting on &lt;<span class="number">0</span>x000000076b3e2ef8&gt; (a Thread1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">        at java.lang.Thread.join(Thread.java:<span class="number">1245</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">        - locked &lt;<span class="number">0</span>x000000076b3e2ef8&gt; (a Thread1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">        at java.lang.Thread.join(Thread.java:<span class="number">1319</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">        at DeadLock.main(DeadLock.java:<span class="number">61</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line"><span class="string">"VM Thread"</span> os_prio=<span class="number">2</span> tid=<span class="number">0</span>x000000001c5e8000 nid=<span class="number">0</span>x4478 runnable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line"><span class="string">"GC task thread#0 (ParallelGC)"</span> os_prio=<span class="number">0</span> tid=<span class="number">0</span>x0000000002ac6000 nid=<span class="number">0</span>x523c runnable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line"><span class="string">"GC task thread#1 (ParallelGC)"</span> os_prio=<span class="number">0</span> tid=<span class="number">0</span>x0000000002ac7800 nid=<span class="number">0</span>x3f00 runnable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line"><span class="string">"GC task thread#2 (ParallelGC)"</span> os_prio=<span class="number">0</span> tid=<span class="number">0</span>x0000000002ac9000 nid=<span class="number">0</span>x5fd0 runnable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line"><span class="string">"GC task thread#3 (ParallelGC)"</span> os_prio=<span class="number">0</span> tid=<span class="number">0</span>x0000000002acb000 nid=<span class="number">0</span>x3c90 runnable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line"><span class="string">"GC task thread#4 (ParallelGC)"</span> os_prio=<span class="number">0</span> tid=<span class="number">0</span>x0000000002acd800 nid=<span class="number">0</span>x4584 runnable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line"><span class="string">"GC task thread#5 (ParallelGC)"</span> os_prio=<span class="number">0</span> tid=<span class="number">0</span>x0000000002acf800 nid=<span class="number">0</span>x19f0 runnable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line"><span class="string">"GC task thread#6 (ParallelGC)"</span> os_prio=<span class="number">0</span> tid=<span class="number">0</span>x0000000002ad2800 nid=<span class="number">0</span>x6d00 runnable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line"><span class="string">"GC task thread#7 (ParallelGC)"</span> os_prio=<span class="number">0</span> tid=<span class="number">0</span>x0000000002ad4000 nid=<span class="number">0</span>x274c runnable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line"><span class="string">"VM Periodic Task Thread"</span> os_prio=<span class="number">2</span> tid=<span class="number">0</span>x000000001e65f000 nid=<span class="number">0</span>x5b48 waiting on condition</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line">JNI global references: <span class="number">6</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">99</span></pre></td><td class="code"><pre><span class="line">=============================</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">100</span></pre></td><td class="code"><pre><span class="line"><span class="string">"Thread-1"</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">101</span></pre></td><td class="code"><pre><span class="line">  waiting to lock monitor <span class="number">0</span>x000000001c5f0d78 (object <span class="number">0</span>x000000076b3e1f50, a Shared),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">102</span></pre></td><td class="code"><pre><span class="line">  which is held by <span class="string">"Thread-0"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">103</span></pre></td><td class="code"><pre><span class="line"><span class="string">"Thread-0"</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">104</span></pre></td><td class="code"><pre><span class="line">  waiting to lock monitor <span class="number">0</span>x000000001c5f0a08 (object <span class="number">0</span>x000000076b3e1f60, a Shared),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">105</span></pre></td><td class="code"><pre><span class="line">  which is held by <span class="string">"Thread-1"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">106</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">107</span></pre></td><td class="code"><pre><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">108</span></pre></td><td class="code"><pre><span class="line">===================================================</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">109</span></pre></td><td class="code"><pre><span class="line"><span class="string">"Thread-1"</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">110</span></pre></td><td class="code"><pre><span class="line">        at Shared.test1(DeadLock.java:<span class="number">14</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">111</span></pre></td><td class="code"><pre><span class="line">        - waiting to lock &lt;<span class="number">0</span>x000000076b3e1f50&gt; (a Shared)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">112</span></pre></td><td class="code"><pre><span class="line">        at Shared.test2(DeadLock.java:<span class="number">23</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">113</span></pre></td><td class="code"><pre><span class="line">        - locked &lt;<span class="number">0</span>x000000076b3e1f60&gt; (a Shared)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">114</span></pre></td><td class="code"><pre><span class="line">        at Thread2.run(DeadLock.java:<span class="number">48</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">115</span></pre></td><td class="code"><pre><span class="line"><span class="string">"Thread-0"</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">116</span></pre></td><td class="code"><pre><span class="line">        at Shared.test2(DeadLock.java:<span class="number">21</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">117</span></pre></td><td class="code"><pre><span class="line">        - waiting to lock &lt;<span class="number">0</span>x000000076b3e1f60&gt; (a Shared)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">118</span></pre></td><td class="code"><pre><span class="line">        at Shared.test1(DeadLock.java:<span class="number">16</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">119</span></pre></td><td class="code"><pre><span class="line">        - locked &lt;<span class="number">0</span>x000000076b3e1f50&gt; (a Shared)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">120</span></pre></td><td class="code"><pre><span class="line">        at Thread1.run(DeadLock.java:<span class="number">36</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">121</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">122</span></pre></td><td class="code"><pre><span class="line">Found <span class="number">1</span> deadlock.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">123</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">124</span></pre></td><td class="code"><pre><span class="line">PS E:\&gt;</span></pre></td></tr></table></figure>

<h3 id="方法二：使用-Java-API，ThreadMXBean-提供的-findDeadThreads"><a href="#方法二：使用-Java-API，ThreadMXBean-提供的-findDeadThreads" class="headerlink" title="方法二：使用 Java API，ThreadMXBean 提供的 findDeadThreads()"></a>方法二：使用 Java API，ThreadMXBean 提供的 findDeadThreads()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">       ThreadMXBean mxBean = ManagementFactory.getThreadMXBean();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">       Runnable dlCheck = <span class="keyword">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">           <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">               <span class="keyword">long</span>[] threads = mxBean.findDeadlockedThreads();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">               <span class="keyword">if</span>(threads!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                   ThreadInfo[] threadInfos = mxBean.getThreadInfo(threads);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                   System.out.println(<span class="string">"Dectected deadlock threads:"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                   <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                       System.out.println(threadInfo.getThreadName());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">               &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">           &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">       &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">       ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">       scheduledExecutorService.scheduleAtFixedRate(dlCheck,<span class="number">5L</span>,<span class="number">10L</span>, TimeUnit.SECONDS);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr></table></figure>

<h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><h3 id="产生死锁的基本元素"><a href="#产生死锁的基本元素" class="headerlink" title="产生死锁的基本元素"></a>产生死锁的基本元素</h3><ul>
<li><p>互斥条件，类似 Java 中 Monitor 都是独占的。</p>
</li>
<li><p>互斥条件是长期持有的，在使用结束之前，自己不会释放，也不能被其他线程抢占。</p>
</li>
<li><p>循环依赖关系，多个个体之间出现了锁的链条环。</p>
</li>
</ul>
<h3 id="编程中如何避免死锁"><a href="#编程中如何避免死锁" class="headerlink" title="编程中如何避免死锁"></a>编程中如何避免死锁</h3><ul>
<li><p>避免嵌套锁，避免锁定多个线程，尽量避免使用多个锁，只有需要的时候才持有锁。</p>
<p>从程序设计的角度反思，如果我们赋予一段程序太多的职责，出现“既要…又要…”的情 况时，可能就需要我们审视下设计思路或目的是否合理了。</p>
</li>
<li><p>如要要使用多个锁，尽量设计好锁的获取顺序。</p>
<ul>
<li><p>将对象（方法）和锁之间的关系，用图形化的方式表示分别抽取出来，以今天最初讲的死锁为例，因为是调用了同一个线程所以更加简单。</p>
<p><img src="/2019/03/24/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87%E4%BA%8C/对象和锁关系.png" alt="对象和锁关系"></p>
</li>
<li><p>然后根据对象之间组合、调用的关系对比组合，考虑可能调用时序。</p>
<p><img src="/2019/03/24/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87%E4%BA%8C/调用时序.png" alt="调用时序"></p>
</li>
<li><p>按照可能时序合并，发现死锁场景</p>
<p><img src="/2019/03/24/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87%E4%BA%8C/时序合并发现死锁场景.png" alt="时序合并发现死锁场景"></p>
</li>
</ul>
</li>
<li><p>使用超时的方法，为程序带来更多可控性</p>
<p>类似 Object.wait(…) 或者 CountDownLatch.await(…)，都支持所谓的 timed_wait，我们完全可以就不假定该锁一定会获得，指定超时时间，并为无法得到锁时准备退出逻辑。 并发 Lock 实现，如 ReentrantLock 还支持非阻塞式的获取锁操作 tryLock()，这是一个插队行为（barging），并不在乎等待的公平性，如果执行时对象恰好没有被独占，则直接获取锁。有时，我们希望条件允许就尝试插队，不然就按照现有公平性规则等待，一般采用下面的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock() || lock.tryLock(timeout, unit)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>有时候并不是阻塞导致的死锁，只是某个线程进入了死循环，导致其他线程一直等待，这种问题如何诊断呢？</p>
<p>某个线程进入死循环导致其他线程一直等待，可以看作是自旋锁的表现。</p>
<p>如何诊断？当死循环引起的其他线程阻塞，会导致 CPU 使用率飙升，在 Linux 系统中使用 top 命令配合 grep Java 之类，找到忙的 PID；再使用 jstack 命令查看线程具体情况；最后定位代码。</p>
<h1 id="Java并发包提供了哪些并发工具类？"><a href="#Java并发包提供了哪些并发工具类？" class="headerlink" title="Java并发包提供了哪些并发工具类？"></a>Java并发包提供了哪些并发工具类？</h1><p>在 java.util.concurrent 及其子包下提供了 Java 并发的各种基础工具类。</p>
<ul>
<li><p>高级的同步结构，包括 CountDownLatch、CycliBarrier、Semaphore 等，可以实现更加丰富的多线程操作。比如：利用 Semaphore 作为资源调度器，限制同时进行工作的线程数量。</p>
</li>
<li><p>线程安全容器，ConcurrentHashMap、有序的 ConcurrentSkipListMap 或者通过类似快照机制实现线程安全的动态数组 CopyOnWriteArrayList 等。</p>
</li>
<li><p>并发队列实现，比如各种 BlockedQueue 实现，比较典型的 ArrayBlockingQueue、SynchorousQueue 或针对特殊场景的 PriorityBlockingQueue.</p>
</li>
<li><p>Eexcutor 框架，可创建不同类型的线程池，调度任务运行。</p>
</li>
</ul>
<p><img src="/2019/03/24/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87%E4%BA%8C/java.util.concurrent.png" alt="concurrent"></p>
<h2 id="重点掌握-1"><a href="#重点掌握-1" class="headerlink" title="重点掌握"></a>重点掌握</h2><ul>
<li><p>利用多线程提高程序的扩展能力，以达到业务对吞吐量的要求。</p>
</li>
<li><p>协调线程间调度、交互，以完成业务逻辑。</p>
</li>
<li><p>线程间传递数据和状态，这同样是实现业务逻辑的需要。</p>
</li>
</ul>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="同步结构"><a href="#同步结构" class="headerlink" title="同步结构"></a>同步结构</h3><ul>
<li><p>CountDownLatch，允许一个或多个线程等待某个操作完成。</p>
</li>
<li><p>CycliBarrier，辅助型同步结构，允许多个线程等待达到某个屏障。</p>
</li>
<li><p>Semaphore，Java 版本的信号量实现，通过控制一定数量允许（permit）的方 式，来限制共享资源的访问。</p>
<p>生活例子：在车站，当空车就位时，为了避免过度拥挤，调度员指挥乘客排队等待乘车，一个批次允许10 名乘客上车，等这 10 名乘客上车后，再放下一批次乘车。</p>
</li>
</ul>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsualSemaphoreSample</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Action...Go!"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SemaphoreWorker(semaphore));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            thread.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SemaphoreWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> String name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SemaphoreWorker</span><span class="params">(Semaphore semaphore)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.semaphore = semaphore;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            log(<span class="string">"is waiting for a permit!"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            semaphore.acquire();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            log(<span class="string">"acquired a permit!"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            log(<span class="string">"executed!"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">            log(<span class="string">"released a permit"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">            semaphore.release();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(name==<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">            name = Thread.currentThread().getName();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        System.out.println(name+<span class="string">"\t"</span>+msg);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbnormalSemaphoreSample</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  InterruptedException</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyWorker(semaphore));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            thread.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Action...Go!"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        semaphore.release(<span class="number">5</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Wait for permits off"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> (semaphore.availablePermits()!=<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            Thread.sleep(<span class="number">100L</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Action...Go again"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        semaphore.release(<span class="number">5</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyWorker</span><span class="params">(Semaphore semaphore)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.semaphore = semaphore;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            semaphore.acquire();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            System.out.println(<span class="string">"Executed"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="CountDownLatch-amp-CyclicBarrier"><a href="#CountDownLatch-amp-CyclicBarrier" class="headerlink" title="CountDownLatch &amp; CyclicBarrier"></a>CountDownLatch &amp; CyclicBarrier</h3><ul>
<li><p>CountDownLatch 是不可重置的，无法重用；而 CyclicBarrier 没有这种限制，可以重用。</p>
</li>
<li><p>CountDownLatch 的基本操作组合是 countDown / await。调用 await 的线程阻塞等待 countDown 足够的次数，不论你是在一个线程还是多个线程里 countDown ，只要次数足够即可。CountDownLatch 操作的是事件。</p>
</li>
<li><p>CyclicBarrier 的基本操作组合，则就是 await，当所有的伙伴（parties）都调用了 await，才会继续进行任务，并自动进行重置。<strong>注意，正常情况下，CyclicBarrier 的重置都是自动发生的</strong>，如果我们调用 reset 方法，但还有线程在等待，就会导致等待线程被打扰，抛出 BrokenBarrierException 异常。<strong>CyclicBarrier 侧重点是线程</strong>，而不是调用事件，它的典型应用场景是用来等待并发线程结束。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatchSample</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FirstBatchWorker(latch));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            thread.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SecondBatchWorker(latch));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            thread.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> (latch.getCount() !=<span class="number">1</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            Thread.sleep(<span class="number">100L</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Wait for first batch finish"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        latch.countDown();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstBatchWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FirstBatchWorker</span><span class="params">(CountDownLatch latch)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.latch = latch;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"First batch executed!"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        latch.countDown();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondBatchWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> CountDownLatch latch ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecondBatchWorker</span><span class="params">(CountDownLatch latch)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.latch = latch;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">            latch.await();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">            System.out.println(<span class="string">"Second batch executed!"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierSample</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, <span class="keyword">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                System.out.println(<span class="string">"Action...Go again!"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> CyclicBarrierWorker(cyclicBarrier));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            thread.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrierWorker</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                System.out.println(<span class="string">"Executed"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">                cyclicBarrier.await();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        &#125;<span class="keyword">catch</span> (BrokenBarrierException e)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><img src="/2019/03/24/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87%E4%BA%8C/并发包提供的线程安全集合.png" alt="并发包提供的线程安全集合"></p>
<p>关于两个 CopyOnWrite 容器，其实 CopyOnWriteArraySet 是通过包装了 CopyOnWriteArrayList 来实现的，所以在学习时，我们可以专注于理解一种。 首先，<strong>CopyOnWrite 到底是什么意思呢？它的原理是，任何修改操作，如 add、set、 remove，都会拷贝原数组，修改后替换原来的数组，通过这种防御性的方式，实现另类的线程 安全。</strong>请看下面的代码片段，我进行注释的地方，可以清晰地理解其逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        Object[] elements = getArray();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> len = elements.length;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">           <span class="comment">// 拷贝</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        newElements[len] = e;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">           <span class="comment">// 替换</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        setArray(newElements);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    array = a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>所以这种数据结构，<strong>相对比较适合读多写少的操作</strong>，不然修改的开销还是非常明显的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>CountDownLatch 和 CyclicBarrier 都能实现线程之间的等待，主要的区别如下：</p>
<ul>
<li><p>CountDownLatch 用于某个线程等待其他线程执行完任务之后，它才执行；不可重用</p>
</li>
<li><p>CyclicBarrier 用于一组线程相互等待至某个状态，然后这一组线程在同时执行；可重用</p>
</li>
</ul>
<h1 id="ConcurrentLinkedQueue-和-LinkedBlockingQueue区别？"><a href="#ConcurrentLinkedQueue-和-LinkedBlockingQueue区别？" class="headerlink" title="ConcurrentLinkedQueue 和 LinkedBlockingQueue区别？"></a>ConcurrentLinkedQueue 和 LinkedBlockingQueue区别？</h1><p>线程安全队列</p>
<p><a href="[https://www.cnblogs.com/gaochundong/p/lock_free_programming.html](https://www.cnblogs.com/gaochundong/p/lock_free_programming.html">Lock-Free</a></p>
<ul>
<li><p>Concurrent 类型基于 lock-free ，多线程访问场景中多有应用，一般可以提高吞吐量。</p>
</li>
<li><p>LinkdBlockingQueue 内部是基于锁，并提供 BlockingQueue 的等待特性方法。LinkedBlockingQueue 改进了锁操作的粒度，头、尾操作使用不同的锁，通用场景下，吞吐能力相对更好些。</p>
</li>
</ul>
<p>java.util.concurrent 包提供的容器 Queue、List、Set、Map，从命名上可以区分为 Concurrent*、CopyOnWrite 、Blocking 等三类，同样的线程安全容器，可以简单的认为：</p>
<ul>
<li><p>Concurrent 类型没有类似 CopyOnWrite 之类容器相对较重的修改开销。</p>
</li>
<li><p>Concurrent 提供了比较低的遍历一致性（弱一致性），比如，利用迭代器遍历时，如果容器发生修改，迭代器任然可以继续进行遍历。</p>
</li>
<li><p>与弱一致性相对应的，就是同步容器常见的行为 “fail-fast”，也就是监测到容器在遍历过程中发生了修改，则抛出 ConcurrentModificationException ，不再继续遍历。</p>
</li>
<li><p>弱一致性的另一个体现是，size 等操作准确性是有限的，未必 100% 正确。</p>
</li>
<li><p>读取的性能也具有一定的不确定性。</p>
</li>
</ul>
<h2 id="重点掌握-2"><a href="#重点掌握-2" class="headerlink" title="重点掌握"></a>重点掌握</h2><ul>
<li><p>哪些队列是有界（Bounded），哪些队列是无界的（Unbounded）？</p>
</li>
<li><p>如何选择合适的队列实现？</p>
</li>
<li><p>常见的线程安全队列如何实现的，并进行了哪些改进提高性能表现？</p>
</li>
</ul>
<h2 id="知识扩展-1"><a href="#知识扩展-1" class="headerlink" title="知识扩展"></a>知识扩展</h2><p><img src="/2019/03/24/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87%E4%BA%8C/线程安全队列.png" alt="线程安全队列"></p>
<p>Deque 的两个实现 ConcurrentLinkedDeque 和 LinkedBlockingDeque，<strong>Deque 侧重点是支持队列头尾都进行插入和删除</strong>，所以提供了特定的方法：</p>
<ul>
<li><p>尾部插入需要 addLast(e)、offerLast(e)</p>
</li>
<li><p>尾部删除需要 removeLast()、pollLast()</p>
</li>
</ul>
<p>大部分 Queue 都实现了 BlockingQueue 接口，在常规队列操作基础上，<strong>Blocking 意味着其提供了特定的等待性操作</strong>，获取时 take 等待元素进入队列，或者插入是 put 等待队列出现空位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 获取并移除队列头结点，如果必要，其会等待直到队列出现元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 插入元素，如果队列已满，则等待直到队列出现空闲空间</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span></pre></td></tr></table></figure>

<h3 id="BlockingQueue-是否有界（Bounded，UnBouded）"><a href="#BlockingQueue-是否有界（Bounded，UnBouded）" class="headerlink" title="BlockingQueue 是否有界（Bounded，UnBouded）?"></a>BlockingQueue 是否有界（Bounded，UnBouded）?</h3><ul>
<li><p>ArrayBlockingQueue 典型的有界队列，内部以 final 数组保存数据，数组大小决定了队列的边界，在创建 ArrayBlockingQueue 时，要指定容量大小。</p>
</li>
<li><p>LinkedBlockingQueue，容易被误解为无边界，其行为和内部代码都是基于有界的逻辑实现的，如果在创建队列时没有指定容量，那容量限制将自动被设置为 Integer.MAX_VALUE，成为了无界队列。</p>
</li>
<li><p>SynchronousQueue，说是非常奇葩的队列实现，每个操作都要等待插入操作，反之每个插入操作也要等待删除动作。其内部容量是（0）</p>
</li>
<li><p>PriorityBlockingQueue 无边界的优先队列，严格意义上讲，其大小总归是要受到系统资源的影响。</p>
</li>
<li><p>DelayedQueue 和 LinkedTransformQueue 同样是无边界队列。对于无边界的队列，有个自然结果，就是 put 操作永远不会发生其他 BlockingQueue 那种等待情况。</p>
</li>
</ul>
<h3 id="队列使用场景和典型用例"><a href="#队列使用场景和典型用例" class="headerlink" title="队列使用场景和典型用例"></a>队列使用场景和典型用例</h3><p>Queue 被广泛用在生产者-消费者场景，比如利用 BlockingQueue 的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sample.queue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerProducerBlockingQueue</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT_MSG = <span class="string">"Good Bye!"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        Producer producer = <span class="keyword">new</span> Producer(queue);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(queue);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">new</span> Thread(producer).start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">this</span>.queue = queue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">                    Thread.sleep(<span class="number">5L</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                    String msg = <span class="string">"Message"</span>+i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                    System.out.println(<span class="string">"Producer new item\t"</span>+msg);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                    queue.put(msg);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">                    e.printStackTrace();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">                System.out.println(<span class="string">"Time to say good by!"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">                queue.put(EXIT_MSG);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">                e.printStackTrace();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">this</span>.queue = queue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">        <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">                String msg;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">while</span> (!EXIT_MSG.equalsIgnoreCase((msg= queue.take())))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">                    System.out.println(<span class="string">"Consumed item\t"</span>+msg);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">                    Thread.sleep(<span class="number">10L</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">                System.out.println(<span class="string">"Got exit message bye!"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">                e.printStackTrace();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="日常开发中如何选择？"><a href="#日常开发中如何选择？" class="headerlink" title="日常开发中如何选择？"></a>日常开发中如何选择？</h3><p>以 LinkedBlockingQueue 、 ArrayBlockingQueue、SynchronousQueue 为例。</p>
<ul>
<li><p>队列边界的需求，ArrayBlockingQueue 有明确的容量限制；LinkedBlockingQueue 则取决于创建时是否指定容量；SynchronousQueue 则干脆不能缓存任何元素。</p>
</li>
<li><p>空间利用角度，数组结构的 ArrayBlockingQueue 比 LinkedBlockingQueue 紧凑，因为不需要创建所谓的节点，但是其初始分配阶段就需要一段连续的空间，所以初始内存需求更大。</p>
</li>
<li><p>通用场景中，LinkedBlockingQueue 吞吐量优于 ArrayBlockingQueue ，因为它实现了更加细粒度的锁操作。</p>
</li>
<li><p>ArrayBlockingQueue 实现简单，性能更好预测。</p>
</li>
<li><p>如果需要实现两个线程间接力行（handoff）的场景，可以选择 CountDownLatch，但是 SynchronousQueue 也是完美符合这种场景的，而且线程协调和数据传输统一起来，代码更加规范。</p>
</li>
<li><p>也许是意外，很多时候 SynchronousQueue 的性能表现，大大超过了其他实现，尤其是在队列元素较小的场景。</p>
</li>
</ul>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>有界（Bouded）</p>
<ul>
<li><p>ArrayBlockingQueue</p>
</li>
<li><p>LinkedBlockingQueue</p>
</li>
<li><p>SynchronousQueue</p>
</li>
</ul>
</li>
<li><p>无界（UnBouded）</p>
<ul>
<li><p>PriorityBlockingQueue</p>
</li>
<li><p>DelayedQueue</p>
</li>
<li><p>LinkedTransferQueue</p>
</li>
<li><p>ConcurrentLinkedQueue</p>
</li>
</ul>
</li>
</ul>
<p>BlockingQueue 基本都是基于锁实现。</p>
<p>Concurrent 类型基于 lock-free 实现。</p>
<p>LinkedBlockingQueue 改进了锁操作的粒度，头、尾操作使用了不同的锁，通用场景下，吞吐量相对更好一些。</p>
<h1 id="Java并发类库提供的线程池有哪几种？有什么特点？"><a href="#Java并发类库提供的线程池有哪几种？有什么特点？" class="headerlink" title="Java并发类库提供的线程池有哪几种？有什么特点？"></a>Java并发类库提供的线程池有哪几种？有什么特点？</h1><p>一个线程不能调用两次 start() 方法，也就是说线程不能够重复启动，线程的创建和销毁存在一定的性能开销。</p>
<p>线程池技术用来提供系统资源利用效率，简化线程管理。</p>
<p>通常我们都是利用 Executors 提供的通用线程池创建方法，去创建不同配置的线程池，主要区别在于不同的 ExecutorService 类型或者不同的初始参数。</p>
<p>Executors 目前提供了 5 种不同的线程池创建配置：</p>
<ul>
<li><p>newCachedThreadPool() ,它是一种用来处理大量短时间工作任务的线程池，主要特点：试图缓存线程并重用，当无缓存线程可用时就会创建新的工作线程；若线程闲置 60 秒，则被移除缓存；长时间闲置，这种线程池不会消耗什么资源。内部使用 SynchronousQueue 作为工作队列。</p>
</li>
<li><p>newFixedThreadPool(int nThreads)，重用指定数量（nThreads） 的线程，其背后使用无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。如果任务数量大于活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数量的 nThreads。</p>
</li>
<li><p>newSingleThreadExecutor()，将线程数据被限制为 1 ，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处理活动状态，并且不允许使用者改动线程池实例，因此可避免其改变线程数目。</p>
</li>
<li><p>newSingleThreadScheduledExecutor() 和 newSingleScheduledThreadPool(int corePoolSize)，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。</p>
</li>
<li><p>newWorkStealingPool(int parallelism（Java 8 新增方法）内部会构建 ForkJoinPool 利用 Work-Stealing 算法，并行处理任务，不保证处理顺序。</p>
</li>
</ul>
<h2 id="重点掌握-3"><a href="#重点掌握-3" class="headerlink" title="重点掌握"></a>重点掌握</h2><ul>
<li><p>掌握 Executor 框架主要内容，组成与职责，掌握基本开发用例中的使用。</p>
</li>
<li><p>对线程池和相关并发工具类型的理解，甚至是源码层面的掌握。</p>
</li>
<li><p>实践中有哪些常见问题，基本诊断思路。</p>
</li>
<li><p>如何根据自身应用特点合理使用线程池。</p>
</li>
</ul>
<h2 id="Executor-框架主要内容"><a href="#Executor-框架主要内容" class="headerlink" title="Executor 框架主要内容"></a>Executor 框架主要内容</h2><p><img src="/2019/03/24/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87%E4%BA%8C/Executor框架基本组成.png" alt="Java核心技术进阶篇二\Executor 框架基本组成"></p>
<ul>
<li><p>Executor 作为基础接口，其初衷是将任务提交和任务执行细节解耦。</p>
</li>
<li><p>ExecutorService 不仅提供 service 的管理功能，比如 shutdown 等方法，也提供更加全面的任务机制，如 Future 而不是 void 的 submit 方法。</p>
</li>
<li><p>Java 标准类库提供几种基础实现，比如 ThreadPollExecutor、ScheduledThreadPoolExecutor、ForkJoinPool，这些线程池的设计特点在于其高度可调节行和灵活性。</p>
</li>
<li><p>Executors 则从简化使用的角度，提供各种快捷方便的静态工厂方法。</p>
</li>
</ul>
<p><img src="/2019/03/24/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87%E4%BA%8C/应用与线程池交互和内部工作过程.png" alt="应用与线程池交互和内部工作过程"></p>
<ul>
<li><p>工作队列，负责存储用户提交的各个任务，这个工作队列，可以是容量为 0 的 SynchronousQueue（使用 newCachedThreadPool），也可以是固定大小线程池（newFixedThreadPool）那样使用 LinkedBlockingQueue。</p>
<p><code>private final BlockingQueue&lt;Runnable&gt; workQueue;</code></p>
</li>
<li><p>内部的“线程池”，这是指保持工作线程的集合，线程池需要在运行过程中管理线程创建、销毁。例如，对于带缓存的线程池，当任务压力较大时，线程池会创建新的工作线程；当业务压力退去，线程池会在闲置一段时间（默认 60 秒）后结束线程。</p>
<p><code>private final HashSet&lt;Worker&gt; workers = new HashSet&lt;&gt;();</code></p>
</li>
</ul>
<p>线程池的工作线程被抽象为静态内部类 Worker ,基于 AQS 实现。</p>
<ul>
<li><p>ThreadFactory 提供上面所需要的创建线程逻辑。</p>
</li>
<li><p>如果任务提交时被拒绝，比如线程池已经处于 SHUTDOWN 状态，需要为其提供处理逻辑，Java 标准库提供了类似ThreadPoolExecutor.AbortPolicy 等默认实现，也可以按照实际需求自定义。</p>
</li>
</ul>
<h3 id="线程池基本组成"><a href="#线程池基本组成" class="headerlink" title="线程池基本组成"></a>线程池基本组成</h3><p>java.util.concurrent.ThreadPoolExecutor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory)</span></span></span></pre></td></tr></table></figure>

<ul>
<li><p>corePoolSize ，核心线程数（长期驻留线程数，除非设置 allowCoreThreadTimeOut）。对于不同的线程池，该值的区别可能会很大，比如 newFixedThreadPool 会将其设置为 nThreads ，而对于 newCacheThreadPool 则是 0 。</p>
</li>
<li><p>maximumPoolSize，当线程不够时能够创建的最大线程数。同样进行对比，对于 newFixedThreadPool，当然就是 nThreads，因为其要求是固定大小，而 newCachedThreadPool 则是 Integer.MAX_VALUE。</p>
</li>
<li><p>keepAliveTime 和 TimeUnit，这两个参数指定了额外的线程能够闲置多久，显然有些线程池不需要它。</p>
</li>
<li><p>workQueue，工作队列，必须是 BlockingQueue。</p>
</li>
</ul>
<h3 id="线程池的生命周期，他的状态是如何表征的呢？"><a href="#线程池的生命周期，他的状态是如何表征的呢？" class="headerlink" title="线程池的生命周期，他的状态是如何表征的呢？"></a>线程池的生命周期，他的状态是如何表征的呢？</h3><p><img src="/2019/03/24/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87%E4%BA%8C/线程生命周期.png" alt="线程生命周期"></p>
<h3 id="线程池大小选择策略"><a href="#线程池大小选择策略" class="headerlink" title="线程池大小选择策略"></a>线程池大小选择策略</h3><ul>
<li><p>如果我们的任务主要是进行计算，那么就意味着 CPU 的处理能力是稀缺的资源，我们能够通过大量增加线程数提高计算能力吗？往往是不能的，如果线程太多，反倒可能导致大量的上下文切换开销。所以，这种情况下，通常建议按照 CPU 核的数目 N 或者 N+1。</p>
</li>
<li><p>如果是需要较多等待的任务，例如 I/O 操作比较多，可以参考 Brain Goetz 推荐的计算方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">线程数 &#x3D; CPU 核数 × 目标 CPU 利用率 ×（1 + 平均等待时间 &#x2F; 平均工作时间）</span></pre></td></tr></table></figure>
</li>
<li><p>上面是仅仅考虑了 CPU 等限制，实际还可能受各种系统资源限制影响，例如我最近就在 Mac OS X 上遇到了大负载时ephemeral 端口受限的情况。当然，我是通过扩大可用端口范围解决的，如果我们不能调整资源的容量，那么就只能限制工作线程的数目了。这里的资源可以是文件句柄、内存等。</p>
</li>
</ul>
<h2 id><a href="#" class="headerlink" title></a></h2><h1 id="AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？"><a href="#AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？" class="headerlink" title="AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？"></a>AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</h1><p>AtomicInteger 是对 int 类型的一个封装，提供原子性的访问和更新操作，其原子性性操作的实现是基于 CAS（compare-and-swap）</p>
<p>CAS 是一系列操作的集合，获取当前数值，进行一些运算，利用 CAS 指令试图进行更新。如果当前值未改变，代表没有其他线程进行并发修改，则成功更新。否则，可能出现不同的选择，要么进行重试，要么返回一个成功或失败的结果。</p>
<p>AtomicInteger 依赖 Unsafe 提供的一些底层能力，进行底层操作；以 volatile 的 value 字段，记录数值，保证可见性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, "value");</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span></pre></td></tr></table></figure>

<p>Unsafe 会利用 value 字段的内存地址偏移，直接完成操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>, VALUE, <span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>因为 getAndIncrement 需要返归数值，所以需要添加失败重试逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> v;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">do</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        v = getIntVolatile(o, offset);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> v;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>而类似 compareAndSet 这种返回 boolean 类型的函数，因为其返回值表现的就是成功与否，所以不需要重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span></span></span></pre></td></tr></table></figure>

<p><a href="[https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/atomic/package-summary.html](https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/atomic/package-summary.html">java.util.concurrent.atomic</a> 提供了常用的原子性数据类型、甚至是引用、数组等相关原子类型和更新操作工具，是很多线程安全程序的首选。</p>
<h2 id="重点掌握-4"><a href="#重点掌握-4" class="headerlink" title="重点掌握"></a>重点掌握</h2><ul>
<li><p>在什么场景下，可以采用 CAS 技术，调用 Unsafe 毕竟不是大多数场景的最好选择，有没有更加推荐的方式呢？</p>
</li>
<li><p>对 ReentrantLock、CyclicBarrier 等并发结构底层的实现技术的理解。</p>
</li>
</ul>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="$CAS$"></a>$CAS$</h3><blockquote>
<p>compare-and-swap（比较并替换）是一个原子指令中所用多线程实现同步，将内存地址中的内容与给定的值进行比较，如果相同就将内存地址中的内容修改为新的给定值。该操作作为单个原子操作完成没。原子性保证了新值是根据最新信息计算得出的，如果在此期间被另一个线程更新，则写入失败。——维基百科</p>
</blockquote>
<p>CAS 是 Java 并发中所谓 lock-free 机制的基础。</p>
<p>CAS 需要 3 个操作数：内存地址 V，旧的预期值 A，即将要更新的目标值 B。</p>
<p>CAS 指令执行时，当且仅当内存地址 V  的值与预期值相等时，将内存地址 V 的值修改为 B，否则什么都不做。整个 CAS 操作是个原子操作。</p>
<p><strong>CAS 底层是如何实现的？</strong>这依赖于 CPU 提供的特定指令，具体根据体系结构的不同存在明显的区别。</p>
<h4 id="CAS-相关问题"><a href="#CAS-相关问题" class="headerlink" title="CAS 相关问题"></a>CAS 相关问题</h4><ul>
<li><p>试想，其常用的失败重试机制，隐含着一个假设，即竞争情况是短暂 的。大多数应用场景中，确实大部分重试只会发生一次就获得了成功，但是总是有意外情况，所 以在有需要的时候，还是要考虑限制自旋的次数，以免过度消耗 CPU。</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/ABA_problem" target="_blank" rel="noopener">ABA</a> 问题，CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。比如说一个线程T1从内存位置V中取出A，这时候另一个线程T2也从内存中取出A，并且T2进行了一些操作变成了B，然后T2又将V位置的数据变成A，这时候线程T1进行CAS操作发现内存中仍然是A，然后T1操作成功。</p>
</li>
</ul>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="$AQS$"></a>$AQS$</h3><p><a href="http://ifeve.com/introduce-abstractqueuedsynchronizer/" target="_blank" rel="noopener">AbstractQueuedSynchronizer的介绍和原理分析</a></p>
<p><strong>$AQS 中 Node 的 waitStatus 有什么作用？$</strong></p>
<p>表示节点的状态。其中包含的状态有：</p>
<ol>
<li>CANCELLED  = 1，表示当前的线程被取消；</li>
<li>SIGNAL = -1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；</li>
<li>CONDITION = -2，表示当前节点在等待condition，也就是在condition队列中；</li>
<li>PROPAGATE = -3，表示当前场景下后续的acquireShared能够得以执行；</li>
<li>0，表示当前节点在sync队列中，等待着获取锁</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/17/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mofei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫非的技术笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/17/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87/" class="post-title-link" itemprop="url">Java 核心技术-进阶篇一</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-17 22:00:00" itemprop="dateCreated datePublished" datetime="2019-03-17T22:00:00+08:00">2019-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-10 19:58:50" itemprop="dateModified" datetime="2019-12-10T19:58:50+08:00">2019-12-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">后端笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="如何保证集合是线程安全的-ConcurrentHashMap如何实现高效地线程安全？"><a href="#如何保证集合是线程安全的-ConcurrentHashMap如何实现高效地线程安全？" class="headerlink" title="如何保证集合是线程安全的?ConcurrentHashMap如何实现高效地线程安全？"></a>如何保证集合是线程安全的?ConcurrentHashMap如何实现高效地线程安全？</h1><ul>
<li><p>同步包装器（Collections.synchronizedMap &amp; Collections.synchronizedMap ），通过 Collections 工具类提供的包装方法来获取。</p>
</li>
<li><p>同步容器</p>
<ul>
<li><p>Vector</p>
</li>
<li><p>HashTable</p>
</li>
</ul>
</li>
</ul>
<p>并发包（java.util.concurrent）提供的线程安全容器类：</p>
<ul>
<li><p>并发容器</p>
<ul>
<li><p>ConcurrentHashMap ，分段 Segment</p>
</li>
<li><p>CopyOnWriteArrayList，写入时复制容器</p>
</li>
<li><p>CopyOnWriteArraySet，写入时复制容器</p>
</li>
</ul>
</li>
<li><p>安全队列（Queue &amp; Deque）Deque 双向队列允许在队列头和尾部进行入队出队操作</p>
<ul>
<li><p>ConcurrentLinkedQueue，使用非阻塞的方式实现的基于链接节点的无界的线程安全队列，性能非常好。</p>
</li>
<li><p>ArrayBlockingQueue，基于数组的有界阻塞队列</p>
</li>
<li><p>LinkedBlockingQueue，基于链表的有界阻塞队列。</p>
</li>
<li><p>PriorityBlockingQueue，支持优先级的无界阻塞队列，即该阻塞队列中的元素可自动排序。默认情况下，元素采取自然升序排列</p>
</li>
<li><p>DelayQueue，一种延时获取元素的无界阻塞队列。</p>
</li>
<li><p>SynchronousQueue，不存储元素的阻塞队列。每个 put 操作必须等待一个 take 操作，否则不能继续添加元素。内部其实没有任何一个元素，容量是 0</p>
</li>
<li><p>ArrayDeque，基于数组的双向非阻塞队列。</p>
</li>
<li><p>LinkedBlockingDeque，基于链表的双向阻塞队列</p>
</li>
</ul>
</li>
<li><p>有序线程安全容器</p>
<ul>
<li><p>ConcurrentSkipListMap，TreeMap 的线程安全版本</p>
</li>
<li><p>ConcurrentSkipListSet，TreeSet 的线程安全版本</p>
</li>
</ul>
</li>
</ul>
<h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><ul>
<li><p>理解基本的线程安全工具。</p>
</li>
<li><p>理解传统集合框架并发编程中 Map 存在的问题，清楚简单同步方式的不足。</p>
</li>
<li><p>梳理并发包内，尤其是 ConcurrentHashMap 采取了那些方式来提高并发表现。</p>
</li>
<li><p>掌握 ConcurrentHashMap 演进。</p>
</li>
</ul>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="为什么需要-ConcurrentHashMap？"><a href="#为什么需要-ConcurrentHashMap？" class="headerlink" title="为什么需要 ConcurrentHashMap？"></a>为什么需要 ConcurrentHashMap？</h3><p>HashTable 是线程同步安全的，其实现基本就是对 put、get、size 等方法加上 “synchronized” 关键字。如此一来就会导致所有的并发操作都要竞争同一把锁，一个线程进行同步操作时，其他线程只能等待。</p>
<p>HashMap 本身不是线程安全的，并发情况会导致 CPU 占用100% 等问题。</p>
<p>早期 ConcurrentHashMap 的实现：</p>
<ul>
<li><p>分离锁，内部进行分段（Segment），里面则是 HashEntry 的数组，和 HashMap 类似，哈希相同的条目也是以链表形式存放。</p>
</li>
<li><p>HashEntry 内部使用 volatile 的 value 字段保证可见性，同时也利用不可变对象的机制改进利用 Unsafe 提供的底层能力，比如 volatile access，去直接完成部分操作。以最优化性能，毕竟 Unsafe 中的很多操作都是 JVM intrinsic 优化过的。</p>
</li>
</ul>
<p><img src="/2019/03/17/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87/ConcurrentHashMap.png" alt="ConcurrentHashMap"></p>
<p>在构造的时候，Segment 的数量由所谓的 concurrentcyLevel 决定，默认是 16，也可以在相应构造函数直接指定。注意，Java 需要它是 2 的幂数值，如果输入是类似 15 这种非幂值，会被自动调整到 16 之类 2 的幂数值。</p>
<p>ConcurrentHashMap get() 操作保证可见性，没有同步逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">        Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        HashEntry&lt;K,V&gt;[] tab;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> h = hash(key.hashCode());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">       <span class="comment">// 利用位操作替换普通数学运算</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">       <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 以 Segment 为单位，进行定位</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 利用 Unsafe 直接进行 volatile access</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            (tab = s.table) != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">           <span class="comment">// 省略</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>

<p>ConcurrentHashMap put() 操作，显示通过二次哈希避免哈希冲突，然后用 Unsafe 调用方式，直接获取相应的 Segment，然后进行线程安全的 put 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">       Segment&lt;K,V&gt; s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">       <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">       <span class="comment">// 二次哈希，以保证数据的分散性，避免哈希冲突</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">       <span class="keyword">int</span> hash = hash(key.hashCode());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">       <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">       <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">           s = ensureSegment(j);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">       <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr></table></figure>

<p>核心逻辑实现如下的内部方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// scanAndLockForPut 会去查找是否有 key 相同 Node</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 无论如何，确保获取锁</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">                scanAndLockForPut(key, hash, value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            V oldValue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                        K k;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                        <span class="comment">// 更新已有 value...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                        <span class="comment">// 放置 HashEntry 到特定位置，如果超过阈值，进行 rehash</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                        <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                unlock();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> oldValue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr></table></figure>

<p>源码分析结论：</p>
<ul>
<li><p>ConcurrentHashMap 会获取再入锁，保证数据一致性，Segment 本来就是基于 ReentrantLock 的扩展实现，所以在并发修改期间，相应 Segment 是被锁定的。</p>
</li>
<li><p>在最初阶段，进行重复性的扫描，以确定相应 key 值是否已经在数组里面，进而决定是更新还是放置操作，你可以在代码里看到相应的注释。重复扫描、检测冲突是 ConcurrentHashMap 的常见技巧。</p>
</li>
<li><p>ConcurrentHashMap 是对单独的 Segment 进行扩容。</p>
</li>
</ul>
<h2 id="在-Java-8-和之后的版本中，ConcurrentHashMap-的变化"><a href="#在-Java-8-和之后的版本中，ConcurrentHashMap-的变化" class="headerlink" title="在 Java 8 和之后的版本中，ConcurrentHashMap 的变化"></a>在 Java 8 和之后的版本中，ConcurrentHashMap 的变化</h2><ul>
<li><p>总体结构上，其内部存储结构和 HashMap 结构非常相似，同样是大桶（bucket）数组，然后内部也是一个个所谓的链表结构（bin），不同的粒度要更细致。</p>
</li>
<li><p>内部仍然有 Segment 定义，仅仅是为了序列化时的兼容性考虑。</p>
</li>
<li><p>不再使用 Segment ，初始化操作简化，修改为 lazy-load 形式，这样可有效避免初始化开销。</p>
</li>
<li><p>数据存储利用 volatile 保证可见性。</p>
</li>
<li><p>使用 CAS 等操作，在特定场景进行无锁并发操作。</p>
</li>
<li><p>使用 Unsafe、LongAdder 之类底层手段，进行极端情况优化。</p>
</li>
</ul>
<h1 id="Java提供了哪些IO方式？NIO如何实现多路复用？"><a href="#Java提供了哪些IO方式？NIO如何实现多路复用？" class="headerlink" title="Java提供了哪些IO方式？NIO如何实现多路复用？"></a>Java提供了哪些IO方式？NIO如何实现多路复用？</h1><ul>
<li><p>java.io（BIO），基于流模型实现，同步阻塞 IO 方式。一个线程处理一个连接，发起和处理IO请求都是同步的</p>
</li>
<li><p>java.nio（NIO），Java 1.4 引入，提供 Channel、Selector、Buffer 等，可构建多路复用，同步非阻塞 IO 方式。一个线程处理多个连接，发起 IO 请求是非阻塞的但处理 IO 请求是同步的</p>
</li>
<li><p>java.nio 2（NIO2 或 AIO）Asynchronous IO，Java 7 中的改进，引入异步非阻塞 IO 方式，基于事件回调机制。一个有效请求一个线程，发起和处理 IO 请求都是异步的</p>
</li>
</ul>
<h2 id="深入理解-1"><a href="#深入理解-1" class="headerlink" title="深入理解"></a>深入理解</h2><ul>
<li><p>基础 API 功能与设计， InputStream/OutputStream 和 Reader/Writer 的关系和区别。 </p>
</li>
<li><p>NIO、NIO 2 的基本组成。 给定场景，分别用不同模型实现，分析 BIO、NIO 等模式的设计和实现原理。</p>
</li>
<li><p>NIO 提供的高性能数据操作方式是基于什么原理，如何使用？ </p>
</li>
<li><p>或者，从开发者的角度来看，你觉得 NIO 自身实现存在哪些问题？有什么改进的想法吗？</p>
</li>
</ul>
<h2 id="知识扩展-1"><a href="#知识扩展-1" class="headerlink" title="知识扩展"></a>知识扩展</h2><ul>
<li><p>区分同步或异步（synchronous / asynchronous），同步是一种可靠有序运行机制，在进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系。</p>
</li>
<li><p>区分阻塞与非阻塞（blocking / non-blocking），在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续。非阻塞则不管 IO 操作是否结束，直接返回，相应操作在后台继续处理。</p>
</li>
</ul>
<p>多路复用：IO 多路复用，就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p>
<h3 id="java-io"><a href="#java-io" class="headerlink" title="java.io"></a>java.io</h3><ul>
<li><p>IO 不只是对文件的操作。适用场景：Socket 通信等；</p>
</li>
<li><p>InputStream / OutputStream （输入、输出流）用于读写字节。适用场景：资源文件；</p>
</li>
<li><p>Read / Writer 则是用于操作字符流，增加了字符编解码功能。适用场景：从文件中读取或写入文本信息。</p>
</li>
<li><p>BufferedOutputStream 利用缓冲区，将批量数据进行一次操作，别忘了 flush，避免频繁的磁盘读写，提高 IO 处理效率。</p>
</li>
<li><p>IO 工具类都实现 Closeable 接口来进行资源释放。比如：打开 FileInputStream 它就会获取相应的文件描述符（FileDescriptor），利用 try-with-resources、try-finally 机制保证 FileInputStream 明确关闭，然后 文件描述符也会随之是笑，否则将导致资源无法释放。</p>
<p><img src="/2019/03/17/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87/java.io.png" alt="io"></p>
</li>
</ul>
<h3 id="java-NIO-主要组成部分"><a href="#java-NIO-主要组成部分" class="headerlink" title="java NIO 主要组成部分"></a>java NIO 主要组成部分</h3><ul>
<li><p>Buffer（缓冲区），高效的数据容器，是个抽象类，除了布尔类型，所有原始类型都有相应的 Buffer 实现。</p>
</li>
<li><p>Channel（通道），Channel 表示与诸如硬件设备，文件，网络套接字或能够执行一个或多个不同IO操作（例如读取或写入）的程序组件实体的开放连接。类似在 Linux 之类操作系统上看到的<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6" target="_blank" rel="noopener">文件描述符</a>，是 NIO 中被用来支持批量式 IO 操作的一种抽象。File 或者 Socket 通常被认为是比较高层次的抽象，Channel 则是更加操作系统底层的一种抽象，使得 NIO 得以充分利用现代操作系统底层机制，获得特定场景的性能优化。</p>
</li>
<li><p>Selector（多路复用器），是 NIO 实现多路复用的基础，提供一种高效的机制，可以检测到注册在 Selector 上的多个 Channel 中，是否有 Channel 处于就绪状态，进而实现单线程多 Channel 的高效管理。Selector 同样是基于底层操作系统机制，不同模式、不同版本都存在区别。</p>
</li>
<li><p>ChartSet，提供 Unicode 字符串定义，NIO 也提供相应的编解码器。<code>Charset.defaultCharset().encode(&quot;Hello world!&quot;));</code></p>
</li>
</ul>
<h3 id="NIO-能解决什么问题？"><a href="#NIO-能解决什么问题？" class="headerlink" title="NIO 能解决什么问题？"></a>NIO 能解决什么问题？</h3><p>为什么需要NIO？为什么需要多路复用？</p>
<p>设想，我们需要实现一个服务器应用，只简单要求能够同时服务多个客户端请求即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span>  serverSocket.getLocalPort();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                Socket socket = serverSocket.accept();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                RequestHandler requestHandler = <span class="keyword">new</span> RequestHandler(socket);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                requestHandler.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                    serverSocket.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">                    e.printStackTrace();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        DemoServer server = <span class="keyword">new</span> DemoServer();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        server.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> (Socket client = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), server.getPort())) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span>                   InputStreamReader(client.getInputStream()));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            bufferedReader.lines().forEach(s -&gt; System.out.println(s));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化实现，不做读取，直接发送字符串</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> Socket socket;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    RequestHandler(Socket socket) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.socket = socket;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> (PrintWriter out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">            out.println(<span class="string">"Hello world!"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">            out.flush();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr></table></figure>

<p>引入线程池机制避免浪费</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">executor = Executors.newFixedThreadPool(<span class="number">8</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    Socket socket = serverSocket.accept();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    RequestHandler requestHandler = <span class="keyword">new</span> RequestHandler(socket);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    executor.execute(requestHandler);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><img src="/2019/03/17/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87/bio.png" alt="bio"></p>
<p>通过固定大小的线程池，负责管理工作线程，避免平凡创建和销毁；</p>
<p>如果客户端连接数量不是很多，这种方式能工作的很好；但如果客户端连接数量随着增加越来越多，线程上下文切换开销会在高并发时很严重，这就是同步阻塞方式的低扩展劣势。</p>
<p>NIO 引入多路复制机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> (Selector selector = Selector.open();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">             ServerSocketChannel serverSocket = ServerSocketChannel.open();) &#123;<span class="comment">// 创建 Selector 和 Channel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(), <span class="number">8888</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            serverSocket.configureBlocking(<span class="keyword">false</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 注册到 Selector，并说明关注点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                selector.select();<span class="comment">// 阻塞等待就绪的 Channel，这是关键点之一</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                    SelectionKey key = iter.next();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                   <span class="comment">// 生产系统中一般会额外进行就绪状态检查</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                    sayHelloWorld((ServerSocketChannel) key.channel());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                    iter.remove();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            e.printStackTrace();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHelloWorld</span><span class="params">(ServerSocketChannel server)</span> <span class="keyword">throws</span> IOException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> (SocketChannel client = server.accept();) &#123;          client.write(Charset.defaultCharset().encode(<span class="string">"Hello world!"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 省略了与前面类似的 main</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li><p>首先，通过 Selector.open() 创建一个 Selector，作为类似调度员的角色。</p>
</li>
<li><p>然后，创建一个 ServerSocketChannel，并且向 Selector 注册，通过指定 SelectionKey.OP_ACCEPT，告诉调度员，它关注的是新的连接请求。 注意，为什么我们要明确配置非阻塞模式呢？这是因为阻塞模式下，注册操作是不允许的，会 抛出 IllegalBlockingModeException 异常。</p>
</li>
<li><p>Selector 阻塞在 select 操作，当有 Channel 发生接入请求，就会被唤醒。</p>
</li>
<li><p>在 sayHelloWorld 方法中，通过 SocketChannel 和 Buffer 进行数据操作，在本例中是发送 了一段字符串。</p>
</li>
</ul>
<p><strong>NIO 利用单线程轮训事件机制，定位就绪的 Channel 来决定做什么，仅 select 阶段是阻塞的，可以避免大量客户端连接时，频繁的线程切换带来的问题。</strong></p>
<p>NIO2 异步 IO 模式，利用事件和回调，处理 Accept、Read等操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">AsynchronousServerSocketChannel serverSock =        AsynchronousServerSocketChannel.open().bind(sockAddr);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">serverSock.accept(serverSock, <span class="keyword">new</span> CompletionHandler&lt;&gt;() &#123; <span class="comment">// 为异步操作指定 CompletionHandler 回调函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel sockChannel, AsynchronousServerSocketChannel serverSock)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        serverSock.accept(serverSock, <span class="keyword">this</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 另外一个 write（sock，CompletionHandler&#123;&#125;）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        sayHelloWorld(sockChannel, Charset.defaultCharset().encode</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                (<span class="string">"Hello World!"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 省略其他路径处理方法...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><p>IO 多路复用通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p>
<p><a href="[https://www.cnblogs.com/diegodu/p/6823855.html](https://www.cnblogs.com/diegodu/p/6823855.html">了解Unix网络编程5种I/O模型</a></p>
<h1 id="Java-有几种文件拷贝方式？哪一种最高效？"><a href="#Java-有几种文件拷贝方式？哪一种最高效？" class="headerlink" title="Java 有几种文件拷贝方式？哪一种最高效？"></a>Java 有几种文件拷贝方式？哪一种最高效？</h1><ul>
<li>java.io 为源文件构建一个 FileInputStream 读取，再为目标文件构建一个 FileOutputStrean 完成写入。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFileByStream</span><span class="params">(File source, File dest)</span> <span class="keyword">throws</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">     IOException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"> <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> FileInputStream(source);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">      OutputStream os = <span class="keyword">new</span> FileOutputStream(dest);)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">     <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">     <span class="keyword">int</span> length;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">     <span class="keyword">while</span> ((length = is.read(buffer)) &gt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">         os.write(buffer, <span class="number">0</span>, length);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li>java.nio 提供的 transferTo 或 transferFrom 方法实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFileByChannel</span><span class="params">(File source, File dest)</span> <span class="keyword">throws</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">        IOException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> (FileChannel sourceChannel = <span class="keyword">new</span> FileInputStream(source)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            .getChannel();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">         FileChannel targetChannel = <span class="keyword">new</span> FileOutputStream(dest).getChannel</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                 ();)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> count = sourceChannel.size() ;count&gt;<span class="number">0</span> ;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">long</span> transferred = sourceChannel.transferTo(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                    sourceChannel.position(), count, targetChannel);            sourceChannel.position(sourceChannel.position() + transferred);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            count -= transferred;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr></table></figure>

<ul>
<li><p>java 标准类库也提供了几种 Files.copy() 的实现。</p>
<p>  java.nio.file.Files</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title">copy</span><span class="params">(Path source, Path target, CopyOption... options)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">copy</span><span class="params">(InputStream in, Path target, CopyOption... options)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">copy</span><span class="params">(Path source, OutputStream out)</span></span></span></pre></td></tr></table></figure>

<p>对于 Copy 的效率，这个其实与操作系统和配置情况相关，NIO transferTo/From 方式可能更快，因为它利用现代操作系统底层机制，避免不必要拷贝和上下文切换。</p>
<h2 id="深入理解-2"><a href="#深入理解-2" class="headerlink" title="深入理解"></a>深入理解</h2><ul>
<li><p>不同的 copy 方式，底层机制有什么区别？</p>
</li>
<li><p>为什么零拷贝（zero-copy）性能优势？</p>
</li>
<li><p>Buffer 分类使用？</p>
</li>
<li><p>Direct Buffer 对垃圾收集等方面影响与实践选择？</p>
</li>
</ul>
<h2 id="知识扩展-2"><a href="#知识扩展-2" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="什么是零拷贝？"><a href="#什么是零拷贝？" class="headerlink" title="什么是零拷贝？"></a>什么是零拷贝？</h3><p>简单的说零拷贝技术就是一种避免 CPU 将数据从一块存储拷贝到另一块存储的技术。</p>
<h3 id="为什么需要零拷贝？"><a href="#为什么需要零拷贝？" class="headerlink" title="为什么需要零拷贝？"></a>为什么需要零拷贝？</h3><p>操作系统将数据从应用程序地址空间的缓冲区拷贝到内核空间的缓冲区，站在操作系统层面这样子接口简单，但是以牺牲系统性能为代价的。原因是数据拷贝操作不单单是占用 CPU 时间片，还占用一定的内存带宽。</p>
<h3 id="拷贝实现机制分析"><a href="#拷贝实现机制分析" class="headerlink" title="拷贝实现机制分析"></a>拷贝实现机制分析</h3><p>现代计算机操作系统通常将虚拟内存分离为内核空间和用户空间。这种分离主要用于提供内存保护和硬件保护，防止恶意或错误的软件行为。</p>
<p>用户态空间（User Space），是应用软件和一些驱动程序执行的存储区域。</p>
<p>内核态空间（Kernel Space），内核空间严格保留用于运行特权操作系统内核，内核扩展和大多数设备驱动程序。</p>
<p><img src="/2019/03/17/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87/copy.png" alt="I/O 读写操作"></p>
<p>应用读取数据是先从内核态将数据从磁盘读取到内核缓存，在切换到用户态将数据从内核缓存读取到用户缓存，这种操作进行了多次上下文切换，带来一定额外开销，可能会降低 I/O 效率。</p>
<p>基于 NIO transferTo 实现方式，在 Linux 和 Unix 上，则会使用到零拷贝技术，数据传输不需要用户态参与，省去了上下文切换的开销和不必要的内存拷贝，进而可能提高应用拷贝性能。</p>
<p>TransferTo 传输过程：</p>
<p><img src="/2019/03/17/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87/transferTo.png" alt="transferTo"></p>
<h3 id="Java-IO-NIO-源码结构"><a href="#Java-IO-NIO-源码结构" class="headerlink" title="Java IO/NIO 源码结构"></a>Java IO/NIO 源码结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title">copy</span><span class="params">(Path source, Path target, CopyOption... options)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">copy</span><span class="params">(InputStream in, Path target, CopyOption... options)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">copy</span><span class="params">(Path source, OutputStream out)</span> </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span></pre></td></tr></table></figure>

<p>专栏中提到“后面两种 copy 实现，能够在方法实现里直接看到使用的是 InputStream.transferTo()，你可以直接看源码，其内部实现其实是 stream 在用户态的读写；” 在 jdk8 版本中确实没找到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title">copy</span><span class="params">(Path source, Path target, CopyOption... options)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    FileSystemProvider provider = provider(source);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (provider(target) == provider) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// same provider</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        provider.copy(source, target, options);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// different providers</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        CopyMoveHelper.copyToForeignTarget(source, target, options);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> target;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我把源码分析过程简单记录如下，JDK 的源代码中，内部实现和公共 API 定义也不是可以能够简单关联上的，NIO 部分代码甚至是定义为模板而不是 Java 源文件，在 build 过程自动生成源码，下面顺便介绍一下部分 JDK 代码机制和如何绕过隐藏障碍。</p>
<ul>
<li><p>首先，直接跟踪，发现 FileSystemProvider 只是个抽象类，阅读它的源码能够理解到，原来文件系统实际逻辑存在于 JDK 内部实现里，公共 API 其实是通过 ServiceLoader 机制加载一系列文件系统实现，然后提供服务。</p>
</li>
<li><p>我们可以在 JDK 源码里搜索 FileSystemProvider 和 nio，可以定位到 sun/nio/fs，我们知道 NIO 底层是和操作系统紧密相关的，所以每个平台都有自己的部分特有文件系统逻辑。</p>
</li>
</ul>
<p><img src="/2019/03/17/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87/Provider.png" alt="Provider"></p>
<ul>
<li><p>省略掉一些细节，最后我们一步步定位到 UnixFileSystemProvider → UnixCopyFile.Transfer，发现这是个本地方法。</p>
</li>
<li><p>最后，明确定位到 UnixCopyFile.c ，其内部实现清楚说明竟然只是简单的用户态空间拷贝！</p>
</li>
</ul>
<p>到这里得出一个结论，<strong>常见的 copy 方法不是利用 transTo，而是利用本地技术实现的用户空间拷贝。</strong></p>
<p>如何提高类似拷贝等 IO 操作的性能，有一些宽泛的原则：</p>
<ul>
<li><p>在程序中，使用缓存等机制，合理减少 IO 次数（在网络通信中，如 TCP 传输，window 大小也可以看作是类似思路）。</p>
</li>
<li><p>使用 transferTo 等机制，减少上下文切换和额外 IO 操作。</p>
</li>
<li><p>尽量减少不必要的转换过程，比如编解码；对象序列化和反序列化，比如操作文本文件或者网络通信，如果不是过程中需要使用文本信息，可以考虑不要将二进制信息转换成字符串，直接传输二进制信息。</p>
</li>
</ul>
<h3 id="掌握-NIO-Buffer"><a href="#掌握-NIO-Buffer" class="headerlink" title="掌握 NIO Buffer"></a>掌握 NIO Buffer</h3><p>Buffer 是 NIO 操作数据的基本工具，Java 为每个原始数据类型提供了相应的 Buffer 实现（布尔除外），尤其是涉及 Direct Buffer 等使用，因为其在垃圾收集等方面特殊性，更要重点掌握。</p>
<p><img src="/2019/03/17/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87/buffer.png" alt="Buffer"></p>
<p>Buffer 的基本属性：</p>
<ul>
<li><p>capcity，表示 Buffer 的缓冲区大小，也就是数组长度。</p>
</li>
<li><p>position，要操作数据起始位置。</p>
</li>
<li><p>limit，操作限额，默认是 capcity 大小。</p>
</li>
<li><p>mark，记录上次 position 的位置，默认是0</p>
</li>
</ul>
<p>Buffer 的基本操作：</p>
<ul>
<li><p>我们创建了一个 ByteBuffer，准备放入数据，capcity 当然就是缓冲区大小，而 position 就是 0，limit 默认就是 capcity 的大小。</p>
</li>
<li><p>当我们写入几个字节的数据时，position 就会跟着水涨船高，但是它不可能超过 limit 的大小。</p>
</li>
<li><p>如果我们想把前面写入的数据读出来，需要调用 flip 方法，将 position 设置为 0，limit 设置为以前的 position 那里。</p>
</li>
<li><p>如果还想从头再读一遍，可以调用 rewind，让 limit 不变，position 再次设置为 0。</p>
</li>
</ul>
<h3 id="Direct-Buffer-和垃圾收集"><a href="#Direct-Buffer-和垃圾收集" class="headerlink" title="Direct Buffer 和垃圾收集"></a>Direct Buffer 和垃圾收集</h3><p>使用 Direct Buffer 开辟的是堆外内存，需要清楚它对内存和 JVM 参数的影响。</p>
<ul>
<li><p>Direct Buffer，如果我们看 Buffer 的方法定义，你会发现它定义了 isDirect() 方法，返回当前 Buffer 是否是 Direct 类型。这是因为 Java 提供了堆内和堆外（Direct）Buffer，我们可以以它的 allocate 或者 allocateDirect 方法直接创建。</p>
</li>
<li><p>MappedByteBuffer，它将文件按照指定大小直接映射为内存区域，当程序访问这个内存区域时将直接操作这块儿文件数据，省去了将数据从内核空间向用户空间传输的损耗。我们可以使用<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/channels/FileChannel.html#map-java.nio.channels.FileChannel.MapMode-long-long-" target="_blank" rel="noopener"> FileChannel.map </a>创建 MappedByteBuffer，它本质上也是种 Direct Buffer。</p>
</li>
</ul>
<p>在实际使用中，Java 会尽量对 Direct Buffer 仅做本地 IO 操作，对于很多大数据量的 IO 密集操作，可能会带来非常大的性能优势，因为：</p>
<ul>
<li><p>Direct Buffer 生命周期内内存地址都不会再发生更改，进而内核可以安全地对其进行访问，很多 IO 操作会很高效。</p>
</li>
<li><p>减少了堆内对象存储的可能额外维护工作，所以访问效率可能有所提高。</p>
</li>
</ul>
<p><strong>但是请注意，Direct Buffer 创建和销毁过程中，都会比一般的堆内 Buffer 增加部分开销，所以通常都建议用于长期使用、数据较大的场景。</strong></p>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="http://tutorials.jenkov.com/java-nio/buffers.html" target="_blank" rel="noopener">Java NIO Buffer</a></p>
<p><a href="https://www.linuxjournal.com/article/6345" target="_blank" rel="noopener">Zero-Copy</a></p>
<h1 id="谈谈接口和抽象类有什么区别？"><a href="#谈谈接口和抽象类有什么区别？" class="headerlink" title="谈谈接口和抽象类有什么区别？"></a>谈谈接口和抽象类有什么区别？</h1><ul>
<li><p>接口类，用 interface 关键字修饰，由抽象方法和全局常量组成；不能包含非常量成员，意味着所有的 field 都是 public static final 修饰，没有任何非静态方法（要么是抽象方法和静态方法）；利用接口可以达到 API 定义与实现的分离；接口对象利用子类（实现类）对象的向上转型完成实例化操作。</p>
</li>
<li><p>抽象类，用 abstract 关键字修饰类和方法（抽象方法没有方法体），主要实现代码重用的目的，除了不能单独实例化，与普通 Java 类没有区别。抽象类用于抽取 Java 类的共用方法或者是共同的成员变量，通过集成的方式达到代码复用的目的。抽象类不能用 final 修饰；抽象类中定义的内部子类一定是 static ；继承抽象类的子类必须覆写抽象方法。</p>
</li>
</ul>
<h2 id="深入理解-3"><a href="#深入理解-3" class="headerlink" title="深入理解"></a>深入理解</h2><ul>
<li><p>对于 Java 的基本元素的语法是否理解准确。能否定义出语法基本正确的接口、抽象类或者相关继承实现，涉及重载（Overload）、重写（Override）更是有各种不同的题目。 </p>
</li>
<li><p>在软件设计开发中妥善地使用接口和抽象类。你至少知道典型应用场景，掌握基础类库重要接口的使用；掌握设计方法，能够在审查代码的时候看出明显的不利于未来维护的设计。 </p>
</li>
<li><p>掌握 Java 语言特性演进。现在非常多的框架已经是基于 Java 8，并逐渐支持更新版本，掌握相关语法，理解设计目的是很有必要的。</p>
</li>
</ul>
<h2 id="知识扩展-3"><a href="#知识扩展-3" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>Java 不支持多继承（接口可以实现多继承），但可以实现多个 Java 接口，弥补了单根继承缺陷。</p>
<p>Java 8 增加了函数式编程支持（function interface），也就是说只有一个抽象方法的接口。使用@FunctionInterface 标记。</p>
<p>Java 8 对接口增加对 default method 的支持。Java 9 之后甚至可以定义 private default method。Java 8 中添加的一系列 default method，主要是正价 Lambda、Stream 相关功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">     <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * Returns a sequential Stream with this collection as its source </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     **/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">         <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr></table></figure>

<p>面向对象基本要素：封装、继承、多态</p>
<p>封装：隐藏内部事务实现细节，提高应用安全性和简化编程。</p>
<p>继承：代码复用的基础机制，但继承可以看做是非常紧耦合的关系。</p>
<p>多态：涉及重写（override）、重载（overload）、向上转型，重写是父子类相同名称和参数的方法，不同的实现；重载是相同名称的方法，但参数不同，本质上方法签名是不一样的；</p>
<p>方法名称 和 参数一致，但返回值不同，这不算重载，编译会报错的如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入参数不同，意味着方法签名不同，重载的体现</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(List&lt;String&gt; strs)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// return 类型不一样，编译不能通过</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>S.O.L.I.D 原则：</p>
<ul>
<li><p>单一职责（Single Responsibility）</p>
</li>
<li><p>开关原则（Open-Close，Open for extension, Close for modification），设计要对扩展开放，关闭修改。</p>
</li>
<li><p>里氏替换（Liskov Substitution），凡是可以用父类的地方，都可以用子类替换。</p>
</li>
<li><p>接口分离（Interface Segregation），若一个接口定义太多方法，子类很可能面临两难，只有部分方法对它是有意义的，就破坏了程序的内聚性。</p>
</li>
<li><p>依赖反转（Dependency Inversion），解耦合。实体应该依赖于抽象而非实现。也就是所高层次模块，不应该依赖低层次模块，而是应该基于抽象。</p>
</li>
</ul>
<h2 id="开关原则实践"><a href="#开关原则实践" class="headerlink" title="开关原则实践"></a>开关原则实践</h2><p>案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VIPCenter</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">serviceVIP</span><span class="params">(T extend User user&gt;)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">     <span class="keyword">if</span> (user <span class="keyword">instanceof</span> SlumDogVIP) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 穷 X VIP，活动抢的那种</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// do somthing</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(user <span class="keyword">instanceof</span> RealVIP) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// do somthing</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr></table></figure>

<p>改造后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VIPCenter</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> Map&lt;User.TYPE, ServiceProvider&gt; providers;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">serviceVIP</span><span class="params">(T extend User user） &#123;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">      providers.get(user.getType()</span>).<span class="title">service</span><span class="params">(user)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceProvider</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(T extend User user)</span> </span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">SlumDogVIPServiceProvider</span> <span class="keyword">implements</span> <span class="title">ServiceProvider</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(T extend User user)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">     <span class="comment">// do somthing</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">RealVIPServiceProvider</span> <span class="keyword">implements</span> <span class="title">ServiceProvider</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(T extend User user)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">     <span class="comment">// do something</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr></table></figure>

<p>按应用目标分类：</p>
<ul>
<li><p>创建型模式，是对对象创建过程的各种问题和解决方案的总结，包括工厂模式（Factory、Abastract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）</p>
</li>
<li><p>结构型模式，是对软件设计结构的总结，关注类、对象继承、组合方式的实践经验。包括：桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）。</p>
</li>
<li><p>行为型模式，是从类或对象之间交互、职责划分等角度总结的模式，常见的策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Oberver）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）</p>
</li>
</ul>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><img src="/2019/03/17/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87/设计模式.png" alt="设计模式"></p>
<h2 id="深入理解-4"><a href="#深入理解-4" class="headerlink" title="深入理解"></a>深入理解</h2><ul>
<li><p>手写一个典型的设计模式实现。</p>
</li>
<li><p>典型的设计模式使用，结合标准库和主流开源框架。</p>
</li>
</ul>
<h2 id="Spring-中的设计模式"><a href="#Spring-中的设计模式" class="headerlink" title="Spring 中的设计模式"></a>Spring 中的设计模式</h2><ul>
<li><p>BeanFactory 和 ApplicationContext 应用了工厂模式。</p>
</li>
<li><p>Bean 创建中，Spring 为不同 scope 定义的对象，提供了单例模式和原型模式实现。</p>
</li>
<li><p>Spring AOP ，使用了代理模式、装饰器模式、适配器模式。</p>
</li>
<li><p>监听器则是典型的观察者模式</p>
</li>
<li><p>Spring 中 JdbcTemplate 则使用了模板方法模式。</p>
</li>
</ul>
<h2 id="Java-中的设计模式"><a href="#Java-中的设计模式" class="headerlink" title="Java 中的设计模式"></a>Java 中的设计模式</h2><p>IO 框架，InputStream 是一个抽象类，标准类库中提供了 FileInputStream、ByteArrayInputStream 等各种不同的子类，分别从不同角度对 InputStream 进行了功能扩展，这是典型的装饰器模式应用案例。</p>
<p><img src="/2019/03/17/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87/装饰器模式.png" alt="装饰器模式"></p>
<h3 id="如何识别装饰器模式呢？"><a href="#如何识别装饰器模式呢？" class="headerlink" title="如何识别装饰器模式呢？"></a>如何识别装饰器模式呢？</h3><p>只需要关注类的构造函数以<strong>相同的抽象类或接口</strong>作为输入参数。</p>
<p>装饰器模式本质上是包装同类型实例，我们对目标对象的调用，往往会通过<strong>包装类</strong>覆盖过的方法，迂回调用被包装的实例，这就可以很自然地实现增加额外逻辑的目的，也就是所谓的“装饰”。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单线程环境</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            instance = <span class="keyword">new</span> Singleton();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> instance;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>

<p>多线程环境</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123; <span class="comment">// 尽量避免重复进入同步块</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123; <span class="comment">// 同步.class，意味着对同步类方法调用</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> singleton;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h1 id="synchronized和ReentrantLock有什么区别呢？"><a href="#synchronized和ReentrantLock有什么区别呢？" class="headerlink" title="synchronized和ReentrantLock有什么区别呢？"></a>synchronized和ReentrantLock有什么区别呢？</h1><p>Java 实现线程同步传统的方式是采用 synchronized 关键字来实现，当某个线程获取当前锁时，其他线程试图获取只能处于等待或阻塞，直到同步块内的线程退出块。synchronized 代码块是由一对儿 monitorenter/monitorexit  指令实现的，Monitor 对象是同步的基本实现单元，使用 <code>javap -c xxx.class</code> 反编译查看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通同步方法，锁住当前类的实例对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//dosomething</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态同步方法，锁住当前类的 class 对象。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="title">void</span><span class="params">(String msg)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//dosomething</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"> <span class="comment">//同步代码块，锁是括号内的对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span></span>&#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">//dosomething</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  &#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>从以上同步代码中，线程有两种类型的锁：</p>
<ul>
<li><p>对象级锁，Java 中的每个对象都有一个唯一的锁，只有使用 synchronize 关键字的时候，才有锁的概念。如果一个线程想要对指定对象执行 synchronized 方法。首先，它必须锁定该对象。一旦线程获得锁定，就允许它对该对象执行任何同步方法。一旦方法执行完成，线程就会释放锁。JVM负责内部获取和释放锁定。</p>
</li>
<li><p>类级锁，Java中的每个类都有一个唯一的锁，它只是类级锁。如果线程想要执行静态同步方法，则线程需要类级别锁定。一旦线程获得类级别锁定，则允许执行该类的任何静态同步方法。一旦方法执行完成，线程就会释放锁。</p>
</li>
</ul>
<p>synchronize 的缺陷，一个线程只能锁一次。同步块不提供等待队列的任何机制，并且在一个线程退出后，任何线程都可以获取锁定。这可能导致很长一段时间内某些其他线程的资源匮乏。</p>
<p>ReentrantLock 可看做是 synchronized 的增强，它实现了 Lock 接口，并在访问共享资源时为方法提供同步。操作共享资源的代码被 lock() 和 unlock() 方法调用所包围。这会锁定当前工作线程并阻止尝试锁定共享资源的所有其他线程</p>
<p> ReentrantLock 允许线程不止一次地锁定资源。当线程首次进入 lock 状态时，保持计数设置为1。在 unlock 之前，线程可以再次重新进入 lock 状态，并且每次保持计数增加1。对于每个解锁请求，保持计数减1，当保持计数为0时，资源解锁。</p>
<p>Reentrant Locks 还提供了一个公平参数，通过该参数，锁将遵守锁请求的顺序，即在线程解锁资源之后，锁将转到已经等待最长时间的线程。通过将true传递给锁的构造函数来设置此公平模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">some_method</span><span class="params">()</span> </span>&#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">        reentrantlock.lock(); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span>&#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//dosomething</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        &#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">catch</span>(Exception e)&#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            e.printStackTrace(); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">finally</span>&#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 即便抛出异常也要保证锁的释放</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            reentrantlock.unlock(); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        &#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="RanntrantLock-Method"><a href="#RanntrantLock-Method" class="headerlink" title="RanntrantLock Method"></a>RanntrantLock Method</h2><ul>
<li><p>lock()，调用 lock() 方法将保持计数增加1，如果共享资源最初是空闲的，则给予线程锁定</p>
</li>
<li><p>unlock()，调用 unlock() 方法将保持计数减1.当此计数达到零时，资源被释放。</p>
</li>
<li><p>tryLock()，如果资源未被任何其他线程持有，则调用tryLock（）将返回true，并且保持计数将增加1。如果资源不是空闲的，则该方法返回false并且线程未被阻止但它将退出。</p>
</li>
<li><p>tryLock(long timeout, TimeUnit unit)，根据方法，线程等待方法的参数定义的特定时间段，以在退出之前获取资源上的锁。</p>
</li>
<li><p>lockInterruptibly()，如果资源是空闲的，则此方法获取锁定，同时允许线程在获取资源时被某个其他线程中断。这意味着如果当前线程正在等待锁定但其他线程请求锁定，则当前线程将被中断并立即返回而不获取锁定。</p>
</li>
<li><p>getHoldCount()，返回资源上保留的锁数的计数。</p>
</li>
<li><p>isHeldByCurrentThread()，如果当前线程持有资源上的锁，则返回true。</p>
</li>
</ul>
<h2 id="重点掌握"><a href="#重点掌握" class="headerlink" title="重点掌握"></a>重点掌握</h2><ul>
<li><p>理解线程安全。</p>
</li>
<li><p>synchronized 和 ReentrantLock 等机制的基本使用与案例。</p>
</li>
<li><p>掌握 synchronized 、ReentrantLock 底层实现；理解锁膨胀、降级；理解偏斜锁、自旋锁、轻量级锁、重量级锁</p>
</li>
<li><p>掌握并发包 java.util.concurrent.lock 各种不同实现和案例分析。</p>
</li>
</ul>
<h2 id="知识扩展-4"><a href="#知识扩展-4" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><p>线程安全是一个多线程环境下正确性的概念，也就是保证多线程环境下共享资源的正确性。</p>
<h3 id="如何保证线程安全"><a href="#如何保证线程安全" class="headerlink" title="如何保证线程安全"></a>如何保证线程安全</h3><ul>
<li><p>封装，将对象内部状态隐藏保护起来。</p>
</li>
<li><p>不可变，final 和 immutable，目前还没有原生的不可变。</p>
</li>
</ul>
<h3 id="线程安全的基本特征"><a href="#线程安全的基本特征" class="headerlink" title="线程安全的基本特征"></a>线程安全的基本特征</h3><ul>
<li><p>原子性，操作过程中不会被其他线程干扰，一般通过同步机制实现。</p>
</li>
<li><p>可见性，当一个线程修改了一个共享变量，其状态能够立刻被其他线程知道。volatile 保证了可见性。</p>
</li>
<li><p>有序性，避免指令重排序。</p>
</li>
</ul>
<h3 id="RenntrantLock"><a href="#RenntrantLock" class="headerlink" title="RenntrantLock"></a>RenntrantLock</h3><p>什么是再入？就是对锁获取粒度的概念，也就是所一个线程试图获取一个它已经获取过的锁时，这个获取动作就自动成功。锁的持有是以线程为单位而不是基于调用次数。Java 锁实现强调再入性是为了和并行线程（pthread）的行为进行区分。</p>
<p>再入锁可以设置公平性（fairness）<code>ReentrantLock fairLock = new ReentrantLock(true);</code></p>
<h3 id="关于再入锁的公平性"><a href="#关于再入锁的公平性" class="headerlink" title="关于再入锁的公平性"></a>关于再入锁的公平性</h3><p>公平性是指竞争场景中，当公平性设置为真时，会倾向于将锁赋予等待时间最久的线程。</p>
<p>目的是为了减少线程“饥饿”，也就是解决个别线程长期等待锁，但始终无法获取的情况。</p>
<p><strong>Java 默认的调度策略很少导致“饥饿”发生，若要保证公平性则会引入额外开销，自然会导致吞吐量下降。</strong> 建议在只有在程序确实有公平性需要的时候，才有必要指定它。</p>
<h3 id="ReentrantLock-比Synchronized-提供的精细化操作。"><a href="#ReentrantLock-比Synchronized-提供的精细化操作。" class="headerlink" title="ReentrantLock 比Synchronized 提供的精细化操作。"></a>ReentrantLock 比Synchronized 提供的精细化操作。</h3><ul>
<li><p>带超时的获取锁尝试。</p>
</li>
<li><p>可判断是否有线程，或某个特定线程，在排队等待获取锁。</p>
</li>
<li><p>可以响应中断请求。</p>
</li>
</ul>
<h1 id="synchronized-底层实现？什么是锁的升级、降级？"><a href="#synchronized-底层实现？什么是锁的升级、降级？" class="headerlink" title="synchronized 底层实现？什么是锁的升级、降级？"></a>synchronized 底层实现？什么是锁的升级、降级？</h1><p>synchronized 代码块是由一对 monitorenter / monitorexit 指令实现，Monitor 对象是同步的基本实现单元。</p>
<p>Java 6 之前，Monitor 依赖 OS 的内部<a href="https://baike.baidu.com/item/%E4%BA%92%E6%96%A5%E9%94%81/841823?fr=aladdin" target="_blank" rel="noopener">互斥锁</a>来实现，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。</p>
<p>Java 6 之后，JVM 提供了三种不同的 Monitor 实现来提升性能，也就是我们常说的：偏斜锁、轻量级锁、重量级锁。</p>
<p>锁的升级和降级，其实就是 JVM 对 synchronized 运行机制进行优化，JVM 根据监测到不同的竞争状况自动切换到合适的锁实现，整个切换过程也就是锁的升级和降级。</p>
<p>当没有竞争时，默认会使用偏斜锁。JVM 会利用 CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。</p>
<p>如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。</p>
<h2 id="深入理解-5"><a href="#深入理解-5" class="headerlink" title="深入理解"></a>深入理解</h2><ul>
<li><p>从源码层面，稍微展开一些 synchronized 的底层实现。</p>
</li>
<li><p>理解并发包中 java.util.concurrent.lock 提供的其他锁实现。</p>
</li>
</ul>
<h2 id="偏向锁-Biased-Locking"><a href="#偏向锁-Biased-Locking" class="headerlink" title="偏向锁(Biased Locking)"></a>偏向锁(Biased Locking)</h2><p>大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。另外，JVM对那种会有多线程加锁，但不存在锁竞争的情况也做了优化，听起来比较拗口，但在现实应用中确实是可能出现这种情况，因为线程之前除了互斥之外也可能发生同步关系，被同步的两个线程（一前一后）对共享对象锁的竞争很可能是没有冲突的。对这种情况，JVM用一个epoch表示一个偏向锁的时间戳（真实地生成一个时间戳代价还是蛮大的，因此这里应当理解为一种类似时间戳的identifier）</p>
<h3 id="偏向锁的获取"><a href="#偏向锁的获取" class="headerlink" title="偏向锁的获取"></a>偏向锁的获取</h3><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录（Monitor Record）里存储<strong>锁偏向的线程ID</strong>，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<h3 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h3><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word，要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</p>
<h3 id="偏向锁的设置"><a href="#偏向锁的设置" class="headerlink" title="偏向锁的设置"></a>偏向锁的设置</h3><p>关闭偏向锁：偏向锁在 Java 6 和 Java 7 里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟<code>-XX:BiasedLockingStartupDelay = 0</code>。如果你确定自己应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁<code>-XX:-UseBiasedLocking=false</code>，那么默认会进入轻量级锁状态。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>为什么需要自旋锁？</p>
<p>线程的阻塞和唤醒需要CPU从用户态转为内核态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作。同时我们可以发现，很多对象锁的锁定状态只会持续很短的一段时间，例如整数的自加操作，在很短的时间内阻塞并唤醒线程显然不值得，为此引入了自旋锁。</p>
<p>什么是自旋锁？</p>
<p>所谓“自旋”，就是让线程去执行一个无意义的循环，循环结束后再去重新竞争锁，如果竞争不到继续循环，循环过程中线程会一直处于running状态，但是基于JVM的线程调度，会出让时间片，所以其他线程依旧有申请锁和释放锁的机会。</p>
<p>自旋锁省去了阻塞锁的时间空间（队列的维护等）开销，但是长时间自旋就变成了“忙式等待”，忙式等待显然还不如阻塞锁。所以自旋的次数一般控制在一个范围内，例如10,100等，在超出这个范围后，自旋锁会升级为阻塞锁。</p>
<h2 id="轻量级锁-Lightweight-Locking"><a href="#轻量级锁-Lightweight-Locking" class="headerlink" title="轻量级锁(Lightweight Locking)"></a>轻量级锁(Lightweight Locking)</h2><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。<strong>然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，则自旋获取锁，当自旋获取锁仍然失败时，表示存在其他线程竞争锁(两条或两条以上的线程竞争同一个锁)，则轻量级锁会膨胀成重量级锁。</strong></p>
<h2 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h2><p><strong>轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示同步过程已完成。</strong>如果失败，表示有其他线程尝试过获取该锁，则要在释放锁的同时唤醒被挂起的线程。</p>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>重量锁在 JVM 中又叫对象监视器（Monitor），它很像C中的Mutex，除了具备Mutex(0|1)互斥的功能，它还负责实现了Semaphore(信号量)的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait 队列），前者负责做互斥，后一个用于做线程同步。</p>
<h2 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h2><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到锁竞争的线程使用自旋会消耗CPU</td>
<td>追求响应时间,锁占用时间很短</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量,锁占用时间较长</td>
</tr>
</tbody></table>
<h2 id="知识扩展-5"><a href="#知识扩展-5" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h3><p>Hotspot 虚拟机的对象头包含两部分：</p>
<ul>
<li><p>Mark Word（标记字段）用于存储对象自身的运行时数据包括，hashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。</p>
</li>
<li><p>Klass Pointer（类型指针）对象指向它的类的元数据的指针，虚拟机通过该指针确定对象属于哪个类的实例。</p>
</li>
</ul>
<h3 id="Java-核心类库中的锁类型"><a href="#Java-核心类库中的锁类型" class="headerlink" title="Java 核心类库中的锁类型"></a>Java 核心类库中的锁类型</h3><p><img src="/2019/03/17/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87/lock.png" alt="lock"></p>
<p>为什么我们还需要读写锁（ReadWriteLock）等其他锁呢？</p>
<p>这是因为，虽然 ReentrantLock 和 synchronized 简单实用，但是行为上有一定局限性，通俗点 说就是“太霸道”，要么不占，要么独占。实际应用场景中，有的时候不需要大量竞争的写操 作，而是以并发读取为主，如何进一步优化并发操作的粒度呢？</p>
<p> Java 并发包提供的读写锁等扩展了锁的能力，它所基于的原理是多个读操作是不需要互斥的，因 为读操作并不会更改数据，所以不存在互相干扰。而写操作则会导致并发一致性的问题，所以写 线程之间、读写线程之间，需要精心设计的互斥逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RWSample</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; m = <span class="keyword">new</span> TreeMap&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock r = rwl.readLock();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock w = rwl.writeLock();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        r.lock();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"读锁锁定"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> m.get(key);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            r.unlock();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">pug</span><span class="params">(String key,String entry)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        w.lock();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"写锁定"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> m.put(key,entry);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            w.unlock();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在运行过程中，如果读锁试图锁定时，写锁是被某个线程持有，读锁将无法获得，而只好等待对方操作结束，这样就可以自动保证不会读取到有争议的数据.</p>
<h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>Java 8 引入 StampedLock，在提供类似读写锁的同时，还支持优化读模式。优化读基于假设，大多数情况下读操作并不会和写操作冲突，其逻辑是先试着读，然后通过 validate 方法确认是否进入了写模式，如果没有进入，就成功避免了开销；如果进入，则尝试获取读锁。</p>
<p>值得注意的事项：</p>
<ul>
<li><p>writeLock 和 unLockWrite 一定要保证成对调用。</p>
</li>
<li><p>StampledLock 不可再入，所以每次获取锁的调用都会返回一个新的 stamp 并阻塞，如果没有可用的锁，即使同一个线程已经持有锁，这可能会导致死锁。</p>
</li>
</ul>
<h3 id="自旋锁的补充"><a href="#自旋锁的补充" class="headerlink" title="自旋锁的补充"></a>自旋锁的补充</h3><p>自旋锁是尝试获取锁的线程不会立即阻塞，采用循环的方式去获取锁，好处是减少了上下文切换，缺点是消耗cpu。</p>
<p>为什么会提出自旋锁？因为互斥锁，在线程的睡眠和唤醒都是复杂而昂贵的操作，需要大量的CPU指令。如果互斥仅仅被锁住是一小段时间，  用来进行线程休眠和唤醒的操作时间比睡眠时间还长，更有可能比不上不断自旋锁上轮询的时间长。</p>
<p>自旋锁只有在多核CPU上有效果，单核毫无效果，只是浪费时间。</p>
<ol>
<li><p>基于乐观情况下推荐使用，即锁竞争不强，锁等待时间不长的情况下推荐使用  </p>
</li>
<li><p>单cpu无效，因为基于cas的轮询会占用cpu,导致无法做线程切换  </p>
</li>
<li><p>轮询不产生上下文切换，如果可估计到睡眠的时间很长，用互斥锁更好</p>
</li>
</ol>
<h2 id="相关资料-1"><a href="#相关资料-1" class="headerlink" title="相关资料"></a>相关资料</h2><p> <a href="http://cmsblogs.com/?p=2071" target="_blank" rel="noopener">深入分析synchronized的实现原理</a></p>
<p><a href="https://blog.csdn.net/u012465296/article/details/53022317" target="_blank" rel="noopener">Java中synchronized的实现原理与应用</a></p>
<p><a href="https://dzone.com/articles/a-look-at-stampedlock" target="_blank" rel="noopener">stampedlock</a></p>
<h1 id="一个线程两次调用start-方法会出现什么情况？"><a href="#一个线程两次调用start-方法会出现什么情况？" class="headerlink" title="一个线程两次调用start()方法会出现什么情况？"></a>一个线程两次调用start()方法会出现什么情况？</h1><p>两次调用 start() 方法，Java 的线程事不允许出现的，二次调用只能抛出 IllegalThreadStateException 异常。</p>
<p>线程生命周期的不同状态，Java 5 中线程状态被明确定义在其公共内部枚举类型，java.lang.Thread.State 中如下：</p>
<ul>
<li><p>NEW（新建），尚未启动的线程处于此状态。</p>
</li>
<li><p>RUNNABLE（就绪），JVM 中执行的线程处于此状态</p>
</li>
<li><p>BLOCKED（阻塞），阻塞表示线程在等待 Monitor lock。比如，线程试图通过 synchronized 去获取某个锁，但是其他线程已经独占 了，那么当前线程就会处于阻塞状态。</p>
</li>
<li><p>WATING（等待），正在等待另一个线程执行特定动作的线程。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准 备任务数据，然后通过类似 notify 等动作，通知消费线程可以继续工作了。Thread.join() 也 会令线程进入等待状态。等待线程的线程状态 由于调用以下方法之一，线程处于等待状态： </p>
<ul>
<li><p>Object.wait </p>
</li>
<li><p>Thread.join </p>
</li>
<li><p>LockSupport.park </p>
</li>
</ul>
</li>
<li><p>TIMED_WAITING（计时等待），正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。线程由于调用下列方法之一，并指定了正等待时间，因此处于计时等待状态:</p>
<ul>
<li><p>Thread.sleep </p>
</li>
<li><p>Object.wait</p>
</li>
<li><p>Thread.join</p>
</li>
<li><p>LockSupport.parkNanos </p>
</li>
<li><p>LockSupport.parkUntil </p>
</li>
</ul>
</li>
<li><p>TERMINATED（终止），已经退出的线程处于此状态，线程已经完成执行</p>
</li>
</ul>
<h2 id="重点掌握-1"><a href="#重点掌握-1" class="headerlink" title="重点掌握"></a>重点掌握</h2><ul>
<li><p>相对理论一些的面试官可以会问你线程到底是什么以及 Java 底层实现方式。 </p>
</li>
<li><p>线程状态的切换，以及和锁等并发工具类的互动。 </p>
</li>
<li><p>线程编程时容易踩的坑与建议等。</p>
</li>
</ul>
<h2 id="知识扩展-6"><a href="#知识扩展-6" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>站在操作系统层面，一个进程可包含多个线程，它们协同完成一件任务。作为任务真正的执行者，拥有自己的栈（stack）、寄存器（Register）、本地存储（ThreadLocal），和进程内其他线程共享文件描述符、虚拟地址空间等；</p>
<p>在具体视线中，线程还分为内核线程、用户线程，Java 线程的实现与虚拟机相关。</p>
<h3 id="线程的基本操作"><a href="#线程的基本操作" class="headerlink" title="线程的基本操作"></a>线程的基本操作</h3><h4 id="Runnable-和-Thread-比较？"><a href="#Runnable-和-Thread-比较？" class="headerlink" title="Runnable 和 Thread 比较？"></a>Runnable 和 Thread 比较？</h4><ul>
<li><p>Runnable 优势在于不受 Java 多重继承影响，重用代码实现。</p>
</li>
<li><p>能够很好的结合 Java 并发库中的 Executor 之类的框架使用。</p>
</li>
</ul>
<p>对比如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Runnable task = () -&gt; &#123;System.out.println(<span class="string">"Hello World!"</span>);&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Thread myThread = <span class="keyword">new</span> Thread(task);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">myThread.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">myThread.join();</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Future future = Executors.newFixedThreadPool(<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">.submit(task)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">.get();</span></pre></td></tr></table></figure>

<h3 id="影响线程的因素有哪些"><a href="#影响线程的因素有哪些" class="headerlink" title="影响线程的因素有哪些"></a>影响线程的因素有哪些</h3><ul>
<li><p>线程自身的方法，除了 start，还有多个 join 方法，等待线程结束；yield 是告诉调度器，主动 让出 CPU；另外，就是一些已经被标记为过时的 resume、stop、suspend 之类，据我所 知，在 JDK 最新版本中，destory/stop 方法将被直接移除。</p>
</li>
<li><p>基类 Object 提供了一些基础的 wait/notify/notifyAll 方法。如果我们持有某个对象的 Monitor 锁，调用 wait 会让当前线程处于等待状态，直到其他线程 notify 或者 notifyAll。所以，本质上是提供了 Monitor 的获取和释放的能力，是基本的线程间通信方式。</p>
</li>
<li><p>并发类库中的工具，比如 CountDownLatch.await() 会让当前线程进入等待状态，直到 latch 被基数为 0，这可以看作是线程间通信的 Signal。</p>
</li>
</ul>
<p><img src="/2019/03/17/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E8%BF%9B%E9%98%B6%E7%AF%87/状态和方法之间的对应图.png" alt="状态和方法之间的对应图"></p>
<h3 id="线程-API-使用"><a href="#线程-API-使用" class="headerlink" title="线程 API 使用"></a>线程 API 使用</h3><h4 id="守护线程（Daemon-Thread）"><a href="#守护线程（Daemon-Thread）" class="headerlink" title="守护线程（Daemon Thread）"></a>守护线程（Daemon Thread）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Thread daemonThread = <span class="keyword">new</span> Thread();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">daemonThread.setDaemon(<span class="keyword">true</span>);<span class="comment">//必须在线程启动之前设置。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">daemonThread.start();</span></pre></td></tr></table></figure>

<h4 id="虚假唤醒（Spurious-Weakup）"><a href="#虚假唤醒（Spurious-Weakup）" class="headerlink" title="虚假唤醒（Spurious Weakup）"></a>虚假唤醒（Spurious Weakup）</h4><p>参考知识扩展一节</p>
<h2 id="运行简单的-main-方法，Java-会创建多少个线程？"><a href="#运行简单的-main-方法，Java-会创建多少个线程？" class="headerlink" title="运行简单的 main 方法，Java 会创建多少个线程？"></a>运行简单的 main 方法，Java 会创建多少个线程？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTotalDemo</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        ThreadMXBean threadMXBean =ManagementFactory.getThreadMXBean();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        ThreadInfo[] threadInfos=threadMXBean.dumpAllThreads(<span class="keyword">false</span>,<span class="keyword">false</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            System.out.println(threadInfo.getThreadId()+<span class="string">"-"</span>+threadInfo.getThreadName());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>IDEA 打印结果：8-7-6 应该是和 IDEA 有关系。</p>
<p>8-JDWP Command Reader<br>7-JDWP Event Helper Thread<br>6-JDWP Transport Listener: dt_socket<br>5-Attach Listener<br>4-Signal Dispatcher<br>3-Finalizer<br>2-Reference Handler<br>1-main</p>
<p>javac 编译后执行打印结果只有1-5.</p>
<h2 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h2><h3 id="Spurious-Wakeup"><a href="#Spurious-Wakeup" class="headerlink" title="Spurious Wakeup"></a>Spurious Wakeup</h3><h4 id="什么是虚假唤醒"><a href="#什么是虚假唤醒" class="headerlink" title="什么是虚假唤醒"></a>什么是虚假唤醒</h4><p><a href="https://en.wikipedia.org/wiki/Spurious_wakeup" target="_blank" rel="noopener">Spurious Wakeup</a>（虚假唤醒）即使没有线程通知条件变量，线程也可能从其等待状态唤醒。为了正确，有必要在线程完成等待之后验证条件是否为真。由于虚假唤醒可能会重复发生，因此可以通过在条件为真时终止循环来实现。</p>
<p>先了解下调用 wait() 方法三步曲</p>
<ol>
<li><p>释放锁并阻塞</p>
</li>
<li><p>等待条件满足</p>
</li>
<li><p>获得通知 notify / notifyAll，进入 entry set 区域等待竞争锁。</p>
</li>
</ol>
<p>举个生产消费例子：</p>
<p>有线程A，C买票，线程 A 调用 wait() 进入等待队列，线程 C 买票时发现线程 B 在退票，获取锁失败，线程 C 阻塞，进入阻塞队列，线程 B 退票时，余票数量+1（满足条件2 等待条件发生），线程 B 调用 notify 方法后，线程 C 马上竞争获取到锁，购票成功后余票为0，而线程 A 此时正处于 wait() 醒来过程中的第三步（竞争获取锁获取锁），当线程 C 释放锁，线程 A 获取锁后，会执行购买的操作，而此时是没有余票的。</p>
<p>如果这个例子没看懂的话建议先了解下 Java 锁中的 Entry Set 和 Wait Set 区域。</p>
<h4 id="解决虚假唤醒"><a href="#解决虚假唤醒" class="headerlink" title="解决虚假唤醒"></a>解决虚假唤醒</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(conditions)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">try</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">       <span class="keyword">this</span>.wait();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">       e.printStackTrace();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.notifyAll();</span></pre></td></tr></table></figure>

<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><h4 id="什么是守护线程？"><a href="#什么是守护线程？" class="headerlink" title="什么是守护线程？"></a>什么是守护线程？</h4><p>守护线程（Daemon Thread）是一个低优先级线程，多用在后台执行垃圾回收等任务。</p>
<h4 id="守护线程-vs-用户线程"><a href="#守护线程-vs-用户线程" class="headerlink" title="守护线程 vs 用户线程"></a>守护线程 vs 用户线程</h4><ul>
<li><p>优先级，用户线程是一个高优先级线程，当进程中最后一个线程是守护程序线程时虚拟机退出。</p>
</li>
<li><p>用途，守护线程为用户线程提供后台服务。</p>
</li>
</ul>
<h2 id="相关资料-2"><a href="#相关资料-2" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://blog.csdn.net/qq_15784927/article/details/79809615" target="_blank" rel="noopener">虚假唤醒-案例</a></p>
<p><a href="https://www.jianshu.com/p/25e243850bd2" target="_blank" rel="noopener">wait、notify、notifyall</a></p>
<p><a href="https://blog.csdn.net/zhangzhaokun/article/details/6395557" target="_blank" rel="noopener">Java线程同步与信号量的奥秘</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">进程与线程的一个简单解释</a>，通俗易懂，关键词进程、线程、互斥锁（Mutex）、信号量（Seamphore）</p>
<p><a href="https://www.geeksforgeeks.org/daemon-thread-java/" target="_blank" rel="noopener">Deamon thread in Java</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/10/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%9F%BA%E7%A1%80%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mofei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫非的技术笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/10/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%9F%BA%E7%A1%80%E7%AF%87/" class="post-title-link" itemprop="url">Java 核心技术-基础篇</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-10 22:59:22" itemprop="dateCreated datePublished" datetime="2019-03-10T22:59:22+08:00">2019-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-10 19:58:54" itemprop="dateModified" datetime="2019-12-10T19:58:54+08:00">2019-12-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">后端笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>来自极客时间，《Java 核心技术36讲》整理笔记。</p>
</blockquote>
<h1 id="谈谈你对Java平台的理解？"><a href="#谈谈你对Java平台的理解？" class="headerlink" title="谈谈你对Java平台的理解？"></a>谈谈你对Java平台的理解？</h1><p>Java 是众多面向对象编程语言中多其中一种，其显著的两个特点就是<strong>“跨平台”</strong> 和<strong>“垃圾收集”</strong>。</p>
<p>跨平台是指<strong>“书写一次，到处执行”</strong> 与 JVM 的存在密不可分；垃圾收集是指 Java 通过垃圾收集器回收分配内存，大部分情况下，程序员无需关心内存的分配和回收，更多的关注到技术编程上面。</p>
<p> JRE（Java Runtime Enviroment）:  Java 运行环境，包含 JVM 和 Java 类库和模块等。</p>
<p> JDK（Java Development Kit）: JDK 是 JRE 的超级，包含很多工具，比如编译器、诊断工具等；</p>
<h2 id="Java-是解释执行吗？"><a href="#Java-是解释执行吗？" class="headerlink" title="Java 是解释执行吗？"></a>Java 是解释执行吗？</h2><p>Java 源代码（<em>.java）先是通过 javac 编译成为字节码（bytecode）然后在运行时通过 Java 虚拟机（JVM）内嵌的解释器将字节码转换成为对应的机器码。常见的 JVM 多数使用 Oracle JDK 提供的 Hotspot JVM，提供的 JIT（Just-In-Time）动态编译器，JIT 能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于*</em>“编译执行”**，而不是解释执行。</p>
<p>Java 分为编译期和运行时：编译期是将 Java 源代码通过 javac 编译成字节码；运行时 JVM 通过类加载器（Class-Loader）加载字节码，解释或者编译执行。Oracle Hotspot JVM 内置了两个不同的 JIT compiler， C1 对应 client 模式，适用于启动速度敏感的桌面应用；C2 对应 server 模式，为长时间运行的服务端应用设计。默认采用分层编译（TieredCompilation）。</p>
<p>Java 虚拟机启动时，可手动指定不同参数对运行模式选择。</p>
<p> “-Xint” 开启解释执行，关闭编译执行。</p>
<p>“-Xcomp” 表示开启编译执行，关闭解释执行。</p>
<p>参数 “-Xint”，抛弃了可能带来的性能优势（解释器（interpreter） 是逐条读入，逐条解释运行。）“-Xcomp” 会导致 JVM 启动缓慢；</p>
<p>JDK 9 引入新的编译方式即 AOT（Ahead-of-Time Compilation）直接将字节码编译成机器代码，避免了 JIT 预热等方面的开销。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Java 特性</p>
<p>平台无关性：依赖 JVM 完成二次编译，将 .class 编译成适合操作系统的机器码。</p>
<p>面向对象：封装、继承、多态、抽象。</p>
<p>垃圾回收（GC机制）：JVM 内存结构，堆、栈、方法区。</p>
<p>语言特性：泛型、lambda、Stream、类型推断</p>
<p>基础类库：集合、IO/NIO、网络、并发、安全</p>
<p>常见垃圾收集器：SerialGC、ParallerGC、CMS、G1</p>
<h1 id="Exception-和-Error有什么区别？"><a href="#Exception-和-Error有什么区别？" class="headerlink" title="Exception 和 Error有什么区别？"></a>Exception 和 Error有什么区别？</h1><p>Exception 和 Error 都是Throwable 的子类，只有 Throwable 类实例才能被抛出（throw）或则捕获（catch），它是异常处理机制的基本组成类型。</p>
<p>Exception 是程序正常运行中，可以预料的意外情况，可以进行捕获并处理。Error 是指在正常运行中，不太可能出现的情况，一旦出现就不可恢复，不能被捕获比如 OOM（OutOfMemoryError）</p>
<p>Exception 分<strong>检查（checked）</strong> 和 <strong>未检查（unchecked）</strong>异常，检查异常在源代码里必须显示的进行捕获处理，是编译器检查的一部分。未检查异常就是所谓的运行时异常（RuntimeException），比如 NullPointerException、ArrayIndexOutOfBoundsException 、 ClassCastException、DateTimeException、SystemException，通过编码避免逻辑错误，按需要来判断是否需要进行捕获处理，并不会在编译器强制要求。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p><img src="/2019/03/10/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%9F%BA%E7%A1%80%E7%AF%87/accba531a365e6ae39614ebfa3273900.png" alt="accba531a365e6ae39614ebfa3273900"></p>
<h3 id="RuntimeException-与-Exception-有什么区别？"><a href="#RuntimeException-与-Exception-有什么区别？" class="headerlink" title="RuntimeException 与 Exception 有什么区别？"></a>RuntimeException 与 Exception 有什么区别？</h3><p>Exception 是 RuntimeException 的父类，所有继承RuntimeException 的子类都属于<strong>不检查（unchecked）</strong>异常即运行时异常。</p>
<p>Exception 定义的异常必须处理，RuntimeException 定义的异常可选择处理。</p>
<h3 id="NoClassDefFoundError-和-ClassNotFoundException-有什么区别？"><a href="#NoClassDefFoundError-和-ClassNotFoundException-有什么区别？" class="headerlink" title="NoClassDefFoundError 和 ClassNotFoundException 有什么区别？"></a>NoClassDefFoundError 和 ClassNotFoundException 有什么区别？</h3><p>NoClassDefFoundError 是指 JVM 或者 ClassLoader 实例尝试加载类的时候，去找不到类的定义。</p>
<p>ClassNotFoundException 是指试图通过类名称或全限定名加载对应的 class 时，找不到对应的 class  文件抛出的异常。 </p>
<h3 id="异常处理基本原则"><a href="#异常处理基本原则" class="headerlink" title="异常处理基本原则"></a>异常处理基本原则</h3><p>一、捕获相匹配的异常，避免捕获 Exception 类似的通用异常。</p>
<p>二、不要生吞（swallo）异常。</p>
<p>生吞异常，往往是基于假设这段代码可能不会发生，或者忽略异常。在产品代码中最好不要有这种假设，如果没把异常抛出来或输出到日志文件，后续没法判断异常出现在那里。</p>
<p>printStackTrace()，也不要出现在产品代码中，尤其是分布式系统，如果发生异常，就无法找到堆栈轨迹（StackTrace）</p>
<h3 id="从性能角度看-Java-的异常处理机制"><a href="#从性能角度看-Java-的异常处理机制" class="headerlink" title="从性能角度看 Java 的异常处理机制"></a>从性能角度看 Java 的异常处理机制</h3><ul>
<li><p>try-catch 代码会产生额外的性能开销，影响 JVM 对代码进行优化，建议仅捕获必要的代码段，尽量不要一个try 包住一大堆代码；也不建议使用异常控制代码流程，还不如选择（if/else、switch）</p>
</li>
<li><p>Java 实例化一个 Exception 都会对当前堆进行快照，这是一个相对比较重的操作。若发生非常频繁，这个开销就不能被忽略了。</p>
</li>
</ul>
<h3 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h3><p><img src="/2019/03/10/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%9F%BA%E7%A1%80%E7%AF%87/异常处理流程.png" alt="异常处理流程"></p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>捕获匹配异常，不要直接捕获 Exception</p>
<p>不要生吞异常，避免在分布式系统和生产系统用printStackTrace() 。</p>
<p>Checked Exception 不兼容 function 编程</p>
<p>try-catch 捕获必要代码，尽量避免 JVM 对于代码进行优化，不要使用异常来控制代码流程</p>
<p>try-catch 也是性能优化的考察点。</p>
<h1 id="谈谈final、finally、finalize-有什么不同？"><a href="#谈谈final、finally、finalize-有什么不同？" class="headerlink" title="谈谈final、finally、finalize 有什么不同？"></a>谈谈final、finally、finalize 有什么不同？</h1><p>final 修饰类表示不可继承；方法不可重写；变量不可修改，只是引用不可再被赋值。</p>
<p>finally 是 Java 用来保证代码一定要被执行的一种机制。使用 try-finally 或者 try-catch-finally 来保证连接或资源关闭、保证 unlock 锁等动作。</p>
<p>finalize 是基础类 java.lang.Object 的一个方法，最初的设计目的是用来保证对象在被垃圾收集前完成特定资源回收。不再推荐，JDK 9 已经标记为 deprecated。</p>
<p>对于 finally 的使用有些偏门的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    System.exit(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;<span class="keyword">finally</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    System.out.println(<span class="string">"print from finally!"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>以上代码中的 finally 模块中的代码就不会执行。</p>
<h2 id="知识扩展-1"><a href="#知识扩展-1" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>final 不是 immutable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">strList.add(<span class="string">"Hello"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">strList.add(<span class="string">"world"</span>);  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; unmodifiableStrList = List.of(<span class="string">"hello"</span>, <span class="string">"world"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">unmodifiableStrList.add(<span class="string">"again"</span>);</span></pre></td></tr></table></figure>

<p>fianl 只能约束 strList 引用不能够被赋值，但 strList 的行为不受 final 影响，添加元素操作是正常的。</p>
<p>如果需要对象本身不可变，需要相应的类支持不可变行为，在上面例子中 List.of()  方法创建的本身就是不可变的List，最后的添加操作在运行时将抛出异常。</p>
<p>实现 immutable 的类，需要做到以下几点：</p>
<ul>
<li><p>将 class 声明为 final</p>
</li>
<li><p>将所有成员定义为 private 和 final，不要实现 setter 方法。</p>
</li>
<li><p>通常构造对象时，成员变量使用深度拷贝来初始化，而非直接赋值，这是一种防御措施，因为你无法确定输入对象不被其他人修改。</p>
</li>
<li><p>如果确实需要实现 setter 方法，或者其他可能返回内部状态的方法，使用 copy-on-write 原则，创建私有 copy。</p>
</li>
</ul>
<p>java 平台逐步使用 java.lang.ref.Cleaner 来替换原有的 finalize 方法。Cleaner 的实现利用了幻想引用也称虚引用（PhantomReference）。利用幻想引用和引用队列，我们可以保证对象被彻底销毁前做一些资源回收工作。每个 Cleaner 的操作都是独立的，有自己的运行线程，所以可以避免以为死锁问题。</p>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>推荐使用 final 关键字来明确代码的语义，也是保证平台安全的必要手段，数据的一致性。</p>
<p>finally 总是执行，特殊情况除外，比如程序或线程被中断情况。</p>
<p>对于关闭连接或资源，推荐使用 Java 7 添加的 try-with-resource 语句。</p>
<p>finallize 并不能真正完成资源回收可参考《Java 编程思想》第四版。</p>
<p>Java 平台逐步使用 java.lang.ref.Cleaner 来替换原有的 finalize 方法。</p>
<h1 id="强引用、软引用、弱引用、幻象引用有什么区别？"><a href="#强引用、软引用、弱引用、幻象引用有什么区别？" class="headerlink" title="强引用、软引用、弱引用、幻象引用有什么区别？"></a>强引用、软引用、弱引用、幻象引用有什么区别？</h1><p>不同的引用类型，主要体现的是<strong>对象不同的可达性（Reachable）状态和垃圾收集的影响。</strong></p>
<h2 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();   <span class="comment">//  强引用</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">obj = <span class="keyword">null</span>; <span class="comment">// 帮助垃圾收集器回收。</span></span></pre></td></tr></table></figure>

<p>常见的普通对象引用，只要强引用指向一个对象，就表明对象还“活着”，垃圾收集器不会回收它。</p>
<p>如果没有其他引用关系，或超出引用的作用域或者显示地将相应强引用赋值为 null， 就可以被垃圾收集。至于什么时候回收要看垃圾收集策略。</p>
<h2 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"HelloWorld"</span>); <span class="comment">// 强引用</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">SoftReference&lt;String&gt; softRef=<span class="keyword">new</span> SoftReference&lt;String&gt;(str);     <span class="comment">// 软引用</span></span></pre></td></tr></table></figure>

<p>软引用是相对强引用弱化了些的引用，只有 JVM 认为内存空间不足是，垃圾收集器才会回收它。</p>
<p>软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了缓存的同时，不会耗尽内存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾收集器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<h2 id="弱引用（WeakReference"><a href="#弱引用（WeakReference" class="headerlink" title="弱引用（WeakReference)"></a>弱引用（WeakReference)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"HelloWorld"</span>);    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; strWeakRef = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">str = <span class="keyword">null</span>;</span></pre></td></tr></table></figure>

<p>弱引用并不能使对象豁免垃圾收集，仅仅是提供一种访问弱引用状态下对象的途径。如果试图获取时对象还在，就使用它，否则重现实例化。同样也是很多缓存实现的选择。</p>
<p>垃圾收集器线程一旦发现具有弱引用的对象，无论内存空间是否足够，都要回收它。由于垃圾回收器是一个优先级很低的线程，因此不一定很快就发现了它。</p>
<h2 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h2><p>虚引用（也称幻想引用），形同虚设，并不会决定对象的生命周期。如果一个对象持有虚引用和没有任何引用是一样的，任何时候都可能被垃圾收集器回收。</p>
<p>虚引用主要用来跟踪对象被垃圾收集状态，可以通过检查与虚引用关联的引用队列中是否已经包含指定的虚引用，从而来判断虚引用引用的对象是否将被回收。</p>
<p>虚引用、幻象引用都是说的同一个，仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。比如：通常用来做 Post-Mortem 清理机制；也有人利用幻象引用监控对象的创建和销毁。</p>
<h2 id="知识扩展-2"><a href="#知识扩展-2" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="对象可达性状态流转分析"><a href="#对象可达性状态流转分析" class="headerlink" title="对象可达性状态流转分析"></a>对象可达性状态流转分析</h3><p><img src="/2019/03/10/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%9F%BA%E7%A1%80%E7%AF%87/36d3c7b158eda9421ef32463cb4d4fb0.png" alt="36d3c7b158eda9421ef32463cb4d4fb0"></p>
<p>这是 Java 定义的不同可达级别（reachability level），具体如下：</p>
<ul>
<li><p>强可达（Strongly Reachable）,当一个对象可以有一个或多个线程可以不通过各种引用访问到的情况。比如，我们创建一个对象，那么创建他的线程对它就是强可达。</p>
</li>
<li><p>软可达（Softly Reachable），当我们只能通过软引用才能访问到对象的状态。</p>
</li>
<li><p>弱可达（Weakly Reachable），无法通过强引用或弱引用访问，只能通过弱引用访问时的状态。这是十分临近 finalize 状态时机，当弱引用被清除的时候，就符合 finalize 的条件了。</p>
</li>
<li><p>幻象可达（Phantom Reachable），就是没有强、软、弱引用关联，并且 finalize 过了，只有幻象引用指向这个对象的时候。</p>
</li>
<li><p>不可达（unreachable），意味着对象被清除了。</p>
</li>
</ul>
<p>所有引用类型都是抽象类 java.lang.ref.Reference 的子类，它提供了 get() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span></span></pre></td></tr></table></figure>

<p>除了幻象引用（因为 get 永远返回 null），如果对象还没有被销毁，都可以通过 get 方法获取原有对象。这意味着，利用软引用和弱引用，我们可以将访问到的对象，重新指向强引用，也就是 人为的改变了对象的可达性状态！</p>
<p>对于软引用、弱引用之类，垃圾收集器可能会存在二次确认的问题，以保证处于弱引用状 态的对象，没有改变为强引用。 </p>
<p><strong>但是，你觉得这里有没有可能出现什么问题呢？</strong></p>
<p>不错，如果我们错误的保持了强引用（比如，赋值给了 static 变量），那么对象可能就没有机会变回类似弱引用的可达性状态了，就会产生内存泄漏。所以，检查弱引用指向对象是否被垃圾收 集，也是诊断是否有特定内存泄漏的一个思路，如果我们的框架使用到弱引用又怀疑有内存泄 漏，就可以从这个角度检查。</p>
<h3 id="ReferenceQueue-引用队列"><a href="#ReferenceQueue-引用队列" class="headerlink" title="ReferenceQueue 引用队列"></a>ReferenceQueue 引用队列</h3><p>ReferenceQueue 可以和软引用、弱引用、幻想引用组合使用。</p>
<p>谈到各种引用的编程，就必然要提到引用队列。我们在创建各种引用并关联到响应对象时，可以选择是否需要关联引用队列，JVM 会在特定时机将引用 enqueue 到队列里，我们可以从队列里 获取引用（remove 方法在这里实际是有获取的意思）进行相关后续逻辑。尤其是幻象引用，get 方法只返回 null，如果再不指定引用队列，基本就没有意义了。看看下面的示例代码。利用引用 队列，我们可以在对象处于相应状态时（对于幻象引用，就是前面说的被 finalize 了，处于幻象 可达状态），执行后期处理逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Object counter = <span class="keyword">new</span> Object();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">ReferenceQueue refQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;Object&gt; p = <span class="keyword">new</span> PhantomReference&lt;&gt;(counter, refQueue);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">counter = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">System.gc();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Remove 是一个阻塞方法，可以指定 timeout，或者选择一直阻塞</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    Reference&lt;Object&gt; ref = refQueue.remove(<span class="number">1000L</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// do something</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Handle it</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="显示地影响软引用垃圾收集影响"><a href="#显示地影响软引用垃圾收集影响" class="headerlink" title="显示地影响软引用垃圾收集影响"></a>显示地影响软引用垃圾收集影响</h3><p>使用什么方法来影响软引用的垃圾收集呢？</p>
<p>软引用通常会在最后一次引用后，还能保持一段时间，默认值是根据堆剩余空间计算的（以 M bytes 为单位）。从 Java 1.3.1 开始，提供了 -XX:SoftRefLRUPolicyMSPerMB 参 数，我们可以以毫秒（milliseconds）为单位设置。比如，下面这个示例就是设置为 3 秒（3000 毫秒）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">-XX:SoftRefLRUPolicyMSPerMB=<span class="number">3000</span></span></pre></td></tr></table></figure>

<p>这个剩余空间，其实会受不同 JVM 模式影响，对于 Client 模式，比如通常的 Windows 32 bit JDK，剩余空间是计算当前堆里空闲的大小，所以更加倾向于回收；而对于 server 模式 JVM， 则是根据 -Xmx 指定的最大值来计算。</p>
<h3 id="诊断-JVM-引用情况"><a href="#诊断-JVM-引用情况" class="headerlink" title="诊断 JVM 引用情况"></a>诊断 JVM 引用情况</h3><p>HotSpot JVM 自身便提供了明确的选项（PrintReferenceGC）去获取相关信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintReferenceGC</span></pre></td></tr></table></figure>

<p>这是 JDK 8 使用 ParrallelGC 收集的垃圾收集日志，各种引用数量非常清晰.</p>
<p>注意：JDK 9 对 JVM 和垃圾收集日志进行了广泛的重构。（PrintGCTimeStamps &amp; PrintReferenceGC 已经移除）</p>
<h3 id="Reachability-Fence"><a href="#Reachability-Fence" class="headerlink" title="Reachability Fence"></a>Reachability Fence</h3><p>除了我前面介绍的几种基本引用类型，还可以通过底层 API 来达到强引用的效果，这就是所 谓的设置reachability fence。</p>
<p>为什么需要这种机制呢？考虑一下这样的场景，按照 Java 语言规范，如果一个对象没有指向强 引用，就符合垃圾收集的标准，有些时候，对象本身并没有强引用，但是也许它的部分属性还在 被使用，这样就导致诡异的问题，所以我们需要一个方法，在没有强引用情况下，通知 JVM 对 象是在被使用的。说起来有点绕，我们来看看 Java 9 中提供的案例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> ExternalResource[] externalResourceArray = ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> myIndex; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"> Resource(...) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">     myIndex = ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">     externalResourceArray[myIndex] = ...;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">     ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">     externalResourceArray[myIndex] = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">     ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"> <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">     <span class="comment">// 需要被保护的代码</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">     <span class="keyword">int</span> i = myIndex;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">     Resource.update(externalResourceArray[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">     <span class="comment">// 调用 reachbilityFence，明确保障对象 strongly reachable</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">     Reference.reachabilityFence(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(ExternalResource ext)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    ext.status = ...;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>参考（<a href="http://mail.openjdk.java.net/pipermail/jdk-dev/2018-October/002067.html" target="_blank" rel="noopener">http://mail.openjdk.java.net/pipermail/jdk-dev/2018-October/002067.html</a>）</p>
<h3 id="Reference-的四种状态"><a href="#Reference-的四种状态" class="headerlink" title="Reference 的四种状态"></a>Reference 的四种状态</h3><ul>
<li>active 一般来说内存一开始被分配的状态，而当被引用的对象的可达性发生变化后gc就会将引用放入pending队列并将其状态改为pending状态。</li>
<li>pending 指的是准备要被放进pending队列的对象。</li>
<li>enqueue 指的是对象的内存已经被回收了。</li>
<li>inactive 这是最终的状态，不能再变为其它状态。</li>
</ul>
<h3 id="JVM怎么知道引用在不在"><a href="#JVM怎么知道引用在不在" class="headerlink" title="JVM怎么知道引用在不在?"></a>JVM怎么知道引用在不在?</h3><p>涉及到了JVM的可达性分析算法了 JVM的可达性分析算法的简单思路就是通过一系列GC Roots作为出发点，向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链，即表明从GC Roots到这个对象不可达时，证明此对象不可用，可被回收。如下图所示</p>
<p><img src="/2019/03/10/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%9F%BA%E7%A1%80%E7%AF%87/gcroots.png" alt="gcroots"></p>
<h3 id="哪些对象可以作为-GC-Roots呢"><a href="#哪些对象可以作为-GC-Roots呢" class="headerlink" title="哪些对象可以作为 GC Roots呢"></a>哪些对象可以作为 GC Roots呢</h3><ul>
<li><p>虚拟机栈中引用的对象</p>
</li>
<li><p>方法区中类静态属性引用的对象 和 常量引用的对象</p>
</li>
<li><p>本地方法栈 JNI 引用的对象</p>
</li>
</ul>
<h1 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h1><p>String 是 Immutable 类，类和属性的声明都是 fianl 。对字符串的操作拼接、分割等都会产生新的 String 对象。</p>
<p>StringBuffer 是为解决 String 拼接操作产生太多的中间对象而提供的。StringBuffer 是线程安全的，有额外的性能开销。</p>
<p>StringBuilder 是 Java1.5 提供，与 StringBuffer 作用一样，不同的是为了减少额外的性能开销去掉了线程安全。</p>
<h2 id="知识扩展-3"><a href="#知识扩展-3" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="字符串设计"><a href="#字符串设计" class="headerlink" title="字符串设计"></a>字符串设计</h3><p>StringBuffer 和 StringBuilder 底层是利用可修改的（char，JDK9 以后是 byte）数组，二者继承了 AbstractStringBuilder，区别仅在于最终方法是否加入了 synchronized</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringConcat</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">       <span class="keyword">return</span> str + “aa” + “bb”;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>以上代码在 JDK1.8 编译后采用 StringBuilder 替代</p>
<h3 id="字符串缓存"><a href="#字符串缓存" class="headerlink" title="字符串缓存"></a>字符串缓存</h3><p>String 在 Java6 提供了 intern() 方法，目的是提示 JVM 把相应字符串缓存起来，便于重复使用。调用 intern() 方法，如果有缓存的字符串就直接返回缓存中的实例，否则就将其缓存起来。使用 new 创建的 String 对象需要手动调用 intern() 方法进行缓存。</p>
<p>历史版本 Java 6 中不推荐 大量使用 intern()？是因为被缓存的字符串是存在 PermGen （永久代），此空间容量有限，基本上不会被 FullGC 之外的垃圾收集。所以使用不当就会造成 OOM。</p>
<p>后续版本，这个缓存被放在了堆中，如此一来就避免了永久代占满的问题，甚至永久代在 Java 8 中被 MetaSpace（元数据）替代了。默认的缓存大小也在不断的扩大中。使用如下代码打印查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">-XX:+PrintStringTableStatistics</span></pre></td></tr></table></figure>

<h1 id="动态代理是基于什么原理？"><a href="#动态代理是基于什么原理？" class="headerlink" title="动态代理是基于什么原理？"></a>动态代理是基于什么原理？</h1><p>反射机制，可以直接操作类或者对象。比如：获取对象的类定义，类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。</p>
<p>动态代理，一种方便运行时动态构建代理、动态处理代理方法调用的机制。比如：AOP 面向切面编程等。</p>
<p>实现动态代理的方式：jdk Proxy、ASM、cglig（基于 ASM）、Javassist</p>
<h2 id="知识扩展-4"><a href="#知识扩展-4" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="反射机制及其演进"><a href="#反射机制及其演进" class="headerlink" title="反射机制及其演进"></a>反射机制及其演进</h3><p>Java 反射机制，java.lang 和 java.lang.reflect 包。利用 Class、Field、Method、Constructor 操作类和对象的元数据对应。值得注意的是反射提供了 <strong>AccessibleObject.setAccessible（boolean flag）</strong>它的子类也都重写了该方法，accessible 可以绕过 public 、protected、private 成员访问限制。 </p>
<p>Java 9 对其进行了改进 ，原因是 Jigsaw 项目新增的模块化系统，出于强封装的考虑，对反射访问进行了限制。 Jigsaw 引入了 Open 概念，只有当被反射操作的模块和指定的包对反射调用者模块 Open，才能使用 setAccessible；否则被认为是不合法的操作。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>通过代理可与实现调用者与实践者之间解耦。比如 RPC 调用，框架内部的寻址、序列化、反序列化，对于调用者没得太大意义，动过代理，提供更加友善的界面。</p>
<p>Jdk 自身的动态代理是以接口为中心才能生成代理对象。</p>
<h3 id="jdk-Proxy-优势？"><a href="#jdk-Proxy-优势？" class="headerlink" title="jdk Proxy 优势？"></a>jdk Proxy 优势？</h3><p>jdk 本身就支持；最小化依赖关系，减少依赖意味着简化开发和维护；平滑升级</p>
<h3 id="cglib-优势？"><a href="#cglib-优势？" class="headerlink" title="cglib 优势？"></a>cglib 优势？</h3><p>没有接口实现类，实现接口是有侵入性质。</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>静态代理：需要手动或借助工具来生成代理类，缺点是每个业务类都需要一个代理类，缺乏灵活性。</p>
<p>动态代理：运行时自动生成代理对象，缺点是生成代理对象和调用代理方法需要额外时间。</p>
<p>JDK 动态代理：基于 Java 反射机制实现，必须实现接口的业务类才能生成代理对象。</p>
<p>cglib 动态代理：基于 ASM 实现，通过生成业务类子类作为代理类。</p>
<h1 id="int和Integer有什么区别？"><a href="#int和Integer有什么区别？" class="headerlink" title="int和Integer有什么区别？"></a>int和Integer有什么区别？</h1><p>Java 的 8 个原始数据类型：long、double、float、int、byte、short、char、boolean</p>
<p>Integer 是 int 的包装类，Java 5 中引入自动装箱和自动拆箱工功能，Java 可以根据上下文自动进行转换。</p>
<p>Integer 值缓存，Java 5 中新增静态工厂方法 valueOf，在调用时利用一个缓存机制，带来性能改进，这个值默认缓存范围是 -128 到 127 之间。</p>
<h2 id="知识扩展-5"><a href="#知识扩展-5" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="理解自动装箱、拆箱"><a href="#理解自动装箱、拆箱" class="headerlink" title="理解自动装箱、拆箱"></a>理解自动装箱、拆箱</h3><p>自动装箱算是一种语法糖。 Java 平台为我们自动进行了一些转换，保证不同的写法在运行时等价，发生在编译阶段，也就是生成的字节码是一致的。</p>
<p>javac 把装箱替换成 Integer.valueOf() ，把拆箱替换成 Integer.intValue() 。</p>
<p><strong>原则上建议避免无意中的装箱和拆箱行为，特别是性能敏感场景。</strong>创建 10 万个 Java 对象和 10 万个整数的开销可不是一个数量级的，不管是内存使用还是处理速度，光是对象头的空间占用就已经是数量级的差距了。</p>
<p><strong>Java 对象保存在内存中由三部分组成：对象头、实例数据、对齐填充字节；</strong></p>
<p><strong>对象头的组成：Mark Word 、指向类的指针、数组长度（对象数组才有）；</strong></p>
<p>计算对象大小可以利用：jol、jmap 或者 instrument api（java agent）等；</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Integer 缓存策略仅在自动装箱（autoboxing）时候有用，使用构造器创建的 Integer 对象不能不缓存。Integer.valueOf() 就是缓存执行的地方。</p>
<p>Integer 缓存范围是 -128 到 127 ,特殊场景也可以通过 JVM 启动参数 <code>-XX:AutoBoxCacheMax=N</code> 调整缓存上限值。</p>
<p>其他包装类的缓存机制：</p>
<ul>
<li>Boolean，缓存了 true/false 对应实例，确切说，只会返回两个常量实例 Boolean.TRUE/FALSE。</li>
<li>Short，同样是缓存了 -128 到 127 之间的数值。</li>
<li>Byte，数值有限，所以全部都被缓存。</li>
<li>Character，缓存范围’\u0000’ 到 ‘\u007F’。</li>
</ul>
<p>Integer 同样是不可变类型。</p>
<p>Integer 等包装类定义了类似 SIZE 和 BYTES 常量，开发人员无需关心 32 位和 64 位平台上的数据位数差异。</p>
<p>其他缓存的对象：</p>
<p>这种缓存行为不仅适用于Integer对象。我们针对所有的整数类型的类都有类似的缓存机制。</p>
<p>ByteCache 用于缓存 Byte 对象</p>
<p>ShortCache 用于缓存 Short 对象</p>
<p>LongCache 用于缓存 Long 对象</p>
<p>CharacterCache 用于缓存 Character 对象</p>
<p><code>Byte</code>, <code>Short</code>, <code>Long</code>有固定范围: -128 到 127。对于<code>Character</code>, 范围是 0 到 127。除了<code>Integer</code>以外，这个范围都不能改变。</p>
<h4 id="Java-原始数据类型和引用类型局限性"><a href="#Java-原始数据类型和引用类型局限性" class="headerlink" title="Java 原始数据类型和引用类型局限性"></a>Java 原始数据类型和引用类型局限性</h4><ul>
<li><p>原始数据类型并不能和泛型配合使用。Java 中的泛型，完全是一种编译阶段使用的技巧，Java 编译器会自动将类型转换为对应的特定类型，这就决定了使用泛型，必须保证相应类型必须转换成 Object。</p>
</li>
<li><p>无法高效的表达数据，也不便于表达复杂的数据结构，如 vector 和 tuple</p>
<p>我们知道 Java 的对象都是引用类型，如果是一个原始数据类型数组，它在内存里是一段连续的内存，而对象数组则不然，数据存储的是引用，对象往往是分散地存储在堆的不同位置。这种设计虽然带来了极大灵活性，但是也导致了数据操作的低效，尤其是无法充分利用现代 CPU 缓存机制。</p>
</li>
</ul>
<h1 id="对比Vector、ArrayList、LinkedList有何区别？"><a href="#对比Vector、ArrayList、LinkedList有何区别？" class="headerlink" title="对比Vector、ArrayList、LinkedList有何区别？"></a>对比Vector、ArrayList、LinkedList有何区别？</h1><p>Vector、ArrayList、LinkedList 都实现了集合框架中的 List（有序集合），都是按照位置进行定位、添加、删除操作、提供迭代器遍历内容等；<strong>Vector 是 Java 早起提供的线程安全的动态数组</strong>，Vector 内部使用对象数组保存数据，可根据需要自动增加容量，当数组满时，则创建新的数组，并拷贝原有的数组数据。</p>
<p>ArrayList 是应用更加广泛的<strong>动态数组</strong>实现，非线程安全，性能好。与Vector 的区别在于扩容，Vector 在扩容是提高 1 倍，ArrayList 则是增加 50%；</p>
<p>LinkedList 是 Java 提供的双向链表，非线程安全，不需要像上面两个那样扩容。</p>
<p>Vector 和 ArrayLIst 作为动态数组，很适合随机访问的场景，除了尾部插入和删除元素，性能较差，比如在中间插入一个元素，需要移动后续所有元素。LinkedList 弥补了前两个在插入和删除上的性能差，但是随机访问性能慢。</p>
<h2 id="问题延伸"><a href="#问题延伸" class="headerlink" title="问题延伸"></a>问题延伸</h2><ul>
<li>Java 集合框架设计结构</li>
<li>Java 容器（集合 &amp; Map）类型，了解或掌握对应的数据结构、算法、思考具体技术选择。</li>
<li>将问题延伸到并发和性能领域。</li>
<li>集合框架的演进与发展。</li>
</ul>
<h2 id="知识扩展-6"><a href="#知识扩展-6" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>排序算法</p>
<p>内部排序：归并排序、交换排序（冒泡、快排）、选择排序、插入排序等；</p>
<p>外部排序：利用内存和外部存储处理超大数据集</p>
<p>Java 集合框架</p>
<p><img src="/2019/03/10/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%9F%BA%E7%A1%80%E7%AF%87/java集合.png" alt="java集合"></p>
<p>Coolection 是所有集合的根，扩展开提供三大类集合：</p>
<ul>
<li><p>List，有序集合</p>
</li>
<li><p>Set，不允许元素重复</p>
</li>
<li><p>Queue/Deque，Java 提供的标准队列结构的实现，除了集合的基本功能，还支持类似先入先出（FIFO，First-in-First-Out）或后进先出（LIFO，Last-in-First-Out）</p>
</li>
</ul>
<p>每种集合的通用逻辑，都被抽象到了抽象类之中。比如：AbastractList。</p>
<p>TreeSet 实际上是利用 TreeMap 实现的；HashSet 也是基于 HashMap 来实现的；</p>
<p>Set</p>
<ul>
<li><p>TreeSet，支持自然顺序访问，但添加、删除、包含等操作相对低效。</p>
</li>
<li><p>HashSet，利用哈希算法，如果哈希散列正常，可以提供常数时间的添加、删除、包含等操作，不保证有序。</p>
</li>
<li><p>LinkedHashSet，内部构件一个记录插入顺序的双向链表，提供按照插入顺序遍历的能力，也保证常数时间的添加、删除、包含操作，性能略低于 HashSet，需要维护链表的开销。</p>
</li>
<li><p>遍历元素时 HashSet 性能受自身容量影响，所以初始化的时候，除非有必要，不然不要将其背后的 HashMap 容量设置过大。而 LinkedhashSet 由其内部链表方式，遍历性能和元素多少有关系。</p>
</li>
</ul>
<p>以上的集合类都不是线程安全的，不像  java.util.concurrent 包内提供的线程安全容器，但是在 java.util.Collections 类中却提供了一系列 synchronized 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span></span></span></pre></td></tr></table></figure>

<p>利用类似的方法来实现线程安全集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList());</span></pre></td></tr></table></figure>

<p><strong>Java 提供的默认排序算法，具体是什么排序方式以及设计思路？</strong></p>
<p>这个问题本身就是有点陷阱的意味，因为需要区分是 Arrays.sort() 还是 Collections.sort() （底层是调用 Arrays.sort()）；什么数据类型；多大的数据集（太小的数据集，复杂排序是没必要的，Java 会直接进行二分插入排序）等。</p>
<ul>
<li><p>对于原始数据类型，目前使用的是所谓双轴快速排序（Dual-Pivot QuickSort），是一种改进的快速排序算法，早期版本是相对传统的快速排序。</p>
</li>
<li><p>而对于对象数据类型，目前则是使用<a href="http://hg.openjdk.java.net/jdk/jdk/file/26ac622a4cab/src/java.base/share/classes/java/util/TimSort.java" target="_blank" rel="noopener">TimSort</a>，思想上也是一种归并和二分插入排序（binarySort）结合的优化排序算法。TimSort 并不是 Java 的独创，简单说它的思路是查找数据集中已经排好序的分区（这里叫 run），然后合并这些分区来达到排序的目的。</p>
</li>
</ul>
<p>Java 8 引入了并行排序算法（直接使用 parallelSort 方法），利用现代多核处理器的计算能力，底层基于 fork-join 框架实现，当数据量增长到百万级别是，提供就很大，取决于处理器和系统环境。</p>
<p>Java 9 中新增了一系列静态工厂方法：比如 List.of()、Set.of() 用来简化构建容器较小容器实例的代码量。</p>
<h1 id="Hashtable、HashMap、TreeMap有什么不同？"><a href="#Hashtable、HashMap、TreeMap有什么不同？" class="headerlink" title="Hashtable、HashMap、TreeMap有什么不同？"></a>Hashtable、HashMap、TreeMap有什么不同？</h1><p>三者都实现了 Map 接口也都是以<strong>键值对</strong>形式进行存储和操作数据的容器类型。</p>
<p>HashTable 是 Java 类库早起提供的哈希表实现，不支持键值为 null ，其本身是同步的，所以有额外的性能开销。</p>
<p>HashMap 也是基于哈希表的实现，行为和HashTable 一直，主要区别在于 HashMap 不是同步的，允许键值为 null。</p>
<p>TreeMap 是基于红黑树的一种提供顺序访问的 Map ，与 HashMap 不同它的 get 、put  、remove 操作都是 O（long(n))）的时间复杂度，具体的顺序可以有指定的 Comparator 来决定，或者根据键的自然顺序来判断。</p>
<h2 id="知识扩展-7"><a href="#知识扩展-7" class="headerlink" title="知识扩展"></a>知识扩展</h2><ul>
<li><p>理解 Map 相关类似整体结构，尤其是有序数据结构的一些要点。</p>
</li>
<li><p>从源码去分析 HashMap 的设计和实现要点，理解容量、负载影因子等，为什么需要这些参数，如何影响 Map 的性能，实践中如何取舍等。</p>
</li>
<li><p>理解树化改造的相关原理和改进原因。</p>
</li>
</ul>
<h3 id="Map-整体结构"><a href="#Map-整体结构" class="headerlink" title="Map 整体结构"></a>Map 整体结构</h3><p>Map 虽然包含在 Java 集合框架中，但本身并不是狭义的集合类型。</p>
<p><img src="/2019/03/10/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%9F%BA%E7%A1%80%E7%AF%87/Map结构.png" alt="Map结构"></p>
<p>HashTable 比较特殊，作为类似 Vector 、 Stack 的早期集合相关类型，它继承至 Dictionary 类，类结构上和 HashMap 明显不同。</p>
<p>HashMap、EnumMap、TreeMap 继承至 AbstractMap 类，包含了通用的操作方法。</p>
<p>大部分使用 Map 场景通常都是插入、访问、删除而且对顺序没有要求的 HashMap 作为首选。</p>
<p>hashMap 的性能表现非常依赖于哈希码的有效性，必须掌握 hashCode 和 equals 的一些基本约定。</p>
<ul>
<li><p>equals 相等，hashCode 一定要相等。</p>
</li>
<li><p>重写 hashCode 也要重写 equals。</p>
</li>
<li><p>hashCode 需要保持一致性，状态改变返回的哈希码要保持一致。</p>
</li>
<li><p>equals 的对称、反射、传递等特性。</p>
</li>
</ul>
<p>LinkedHashMap 和 TreeMap 都可以保证某种顺序，但二者还是非常不同的。</p>
<ul>
<li>LinkedHashMap 通常提供遍历顺序符合插入顺序，它的实现是通过为键值对维护一个双向链表。注意，通过特定构造函数，我们可以创建反映访问顺序的实例，所谓的 put、get、compute 等，都算作“访问”。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapSample</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        LinkedHashMap&lt;String, String&gt; accessOrderedMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;(<span class="number">16</span>, <span class="number">0.75F</span>, <span class="keyword">true</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;String, String&gt; eldest)</span> </span>&#123; <span class="comment">// 实现自定义删除策略，否则行为就和普遍 Map 没有区别</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> size() &gt; <span class="number">3</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        accessOrderedMap.put(<span class="string">"Project1"</span>, <span class="string">"Valhalla"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        accessOrderedMap.put(<span class="string">"Project2"</span>, <span class="string">"Panama"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        accessOrderedMap.put(<span class="string">"Project3"</span>, <span class="string">"Loom"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        accessOrderedMap.forEach( (k,v) -&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            System.out.println(k +<span class="string">":"</span> + v);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 模拟访问</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        accessOrderedMap.get(<span class="string">"Project2"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        accessOrderedMap.get(<span class="string">"Project2"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        accessOrderedMap.get(<span class="string">"Project3"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Iterate over should be not affected:"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        accessOrderedMap.forEach( (k,v) -&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            System.out.println(k +<span class="string">":"</span> + v);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 触发删除</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        accessOrderedMap.put(<span class="string">"Project4"</span>, <span class="string">"Mission Control"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Oldest entry should be removed:"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        accessOrderedMap.forEach( (k,v) -&gt; &#123;<span class="comment">// 遍历顺序不变</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            System.out.println(k +<span class="string">":"</span> + v);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li>TreeMap ，整体顺序是由键的顺序关系决定的，通过 Comparator 或 Comparable（自然顺序）来决定。</li>
</ul>
<h3 id="HashMap-源码分析"><a href="#HashMap-源码分析" class="headerlink" title="HashMap 源码分析"></a>HashMap 源码分析</h3><ul>
<li><p>HashMap 内部实现基本点分析</p>
</li>
<li><p>容量（capacity）和负载因子（load factor）</p>
</li>
<li><p>树化</p>
</li>
</ul>
<p><strong>HashMap 内部结构可以看做是数组（Node&lt;K,V&gt;[] talbe）和链表结合组成的复合结构，数组被分为一个个桶（bucket），通过哈希值决定了键值对这个数组的寻址；哈希值相同的键值对，则以链表形式存储；</strong>参考如下示意图。需要注意的是，<strong>如果链表大小超过阈值（TREEIFY_THRESHOLD,8）,图中的链表就会被改造成树形结构。</strong></p>
<p><img src="/2019/03/10/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%9F%BA%E7%A1%80%E7%AF%87/桶数组.png" alt="桶数组"></p>
<p>从非拷贝构造函数的实现来看，这个表格（数组）似乎并没有在最初就初始化好，仅仅设置了一些初始值而已。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span></span>&#123;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ... </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>所以，我们深刻怀疑，HashMap 也许是按照 lazy-load 原则，在首次使用时被初始化（拷贝构造函数除外，我这里仅介绍最通用的场景）。既然如此，我们去看看 put 方法实现，似乎只有一个 putVal 的调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>看来主要的密码似乎藏在 putVal 里面，到底有什么秘密呢？为了节省空间，我这里只截取了 putVal 比较关键的几部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbent,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evit)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> , i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) = <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        n = (tab = resize()).length;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == ull)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        tab[i] = newNode(hash, key, value, nll);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for first </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">           treeifyBin(tab, hash);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//  ... </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li><p>如果表格是 null，resize 方法会负责初始化它，这从 tab = resize() 可以看出。</p>
</li>
<li><p>resize 方法兼顾两个职责，创建初始存储表格，或者在容量不满足需求的时候，进行扩容（resize）。</p>
</li>
<li><p>在放置新的键值对的过程中，如果发生下面条件，就会发生扩容。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    resize();</span></pre></td></tr></table></figure>

<p>具体键值对在哈希表中的位置（数组 index）取决于下面的位运算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">i = (n - <span class="number">1</span>) &amp; hash</span></pre></td></tr></table></figure>

<p>仔细观察哈希值的源头，我们会发现，它并不是 key 本身的 hashCode，而是来自于 HashMap 内部的另外一个 hash 方法。注意，为什么这里需要将高位数据移位到低位进行异或运算呢？<strong>这是因为有些数据计算出的哈希值差异主要在高位，而 HashMap 里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以有效避免类似情况下的哈希碰撞。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object kye)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> h;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt;<span class="number">16</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>HashMap resice()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACIY &amp;&amp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPAITY)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double there</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">       <span class="comment">// ... </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        newCap = oldThr;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// zero initial threshold signifies using defaultsfults</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        newCap = DEFAULT_INITIAL_CAPAITY;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_ATOR* DEFAULT_INITIAL_CAPACITY；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (newThr ==<span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFator;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?(<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    threshold = neThr;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newap];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    table = n；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 移动到新的数组结构 e 数组结构 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr></table></figure>

<p>依据 resize 源码，不考虑极端情况（容量理论最大极限由 MAXIMUM_CAPACITY 指定，数值为 1&lt;&lt;30，也就是 2 的 30 次方），我们可以归纳为：</p>
<ul>
<li><p>门限值等于（负载因子） x （容量），在构建 HashMap 没有指定它们，那就是依据相应的默认常量值。</p>
</li>
<li><p>门限值通常是以倍数进行调整（newThr = oldThr &lt;&lt; 1）,根据 putVal 中的逻辑，当元素个数超过门限大小时则调整 Map 大小。</p>
</li>
<li><p>扩容后，需要将老的数组的元素重新放置到新的数组，这是扩容的一个组要开销来源。</p>
</li>
</ul>
<h3 id="容量、负载因子和树化"><a href="#容量、负载因子和树化" class="headerlink" title="容量、负载因子和树化"></a>容量、负载因子和树化</h3><p><strong>为什么容量和负载因子这么重要？</strong>因为容量和负载因子决定可用桶的数量，空桶多了浪费空间，若使用得太满则严重影响操作性能。极端情况下，假设只有一个桶，那么它就退化成了链表，完全不能提供所谓常数时间存的性能。</p>
<p>实践中如何选择呢？预估<code>负载因子 * 容量 &gt; 元素数量</code></p>
<p>负载因子的建议：</p>
<ul>
<li><p>没有特殊需求不建议改动， JDK 自身默认的负载因子满足了通用场景。</p>
</li>
<li><p>实在要调整，建议不要超过 0.75 的数值，因为会显著增加冲突，降低 HashMap 的性能。</p>
</li>
<li><p>若使用太小的负载因子，按上面的公式，预设容量值也要进行调整，否则可能会导致更加频繁的扩容。</p>
</li>
</ul>
<h3 id="树化改造"><a href="#树化改造" class="headerlink" title="树化改造"></a>树化改造</h3><p>树化改造，对应逻辑主要在 putVal 和 treeifyBin 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        resize();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 树化改造逻辑</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li><p>如果容量小于 MIN_TREEIFY_CAPACITY，只会进行简单的扩容。</p>
</li>
<li><p>如果容量大于 MIN_TREEIFY_CAPACITY ，则会进行树化改造。</p>
</li>
</ul>
<p><strong>为什么HashMap 要树化呢？本质上是个安全问题。因为在元素的放置过程中，如果一个对象哈希冲突，都被放置到同一个桶里，则会形成链表，链表是线性查询，会严重影响存取的性能。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/09/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%20Java%20%E7%9A%84%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mofei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫非的技术笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/09/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%20Java%20%E7%9A%84%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">谈谈你对 Java 平台的理解？</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-09 00:00:00" itemprop="dateCreated datePublished" datetime="2019-03-09T00:00:00+08:00">2019-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-10 19:59:53" itemprop="dateModified" datetime="2019-12-10T19:59:53+08:00">2019-12-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">后端笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="谈谈你对-Java-平台的理解？“Java-是解释执行“，这句话正确吗？"><a href="#谈谈你对-Java-平台的理解？“Java-是解释执行“，这句话正确吗？" class="headerlink" title="谈谈你对 Java 平台的理解？“Java 是解释执行“，这句话正确吗？"></a>谈谈你对 Java 平台的理解？“Java 是解释执行“，这句话正确吗？</h2><p>Java 平台最为显著的两方面特性：</p>
<p>一是跨平台能力，即所谓的“一次编译，到处执行“。</p>
<p>二是垃圾回收器（GC，Garbage Collection），回收已分配的内存空间，开发人员无需操心对内存的分配和回收。</p>
<p>JRE（Java Runtime Enviroment) Java 运行时环境，包括 JVM 标准实现及 Java 核心类库。JRE 自带的核心类库主要是 <code>JRE\lib\rt.jar</code>这个文件。</p>
<p>JDK（Java Development Kit）Java 开发环境，可以看作是JRE 的超集。它包含了Java 的运行环境（JVM + Java 系统类库）和 Java 工具，提供更多的工具，比如编译器、调试器、诊断工具。</p>
<h3 id="JDK-的基础组件包括："><a href="#JDK-的基础组件包括：" class="headerlink" title="JDK 的基础组件包括："></a>JDK 的基础组件包括：</h3><p>javac：编译器，将源程序转化为字节码。（.java 转 .class）</p>
<p>jar: 打包工具，将相关类文件打包成一个文件。</p>
<p>javadoc：Java 文档生成工具，将源代码中的注释提取成文档。</p>
<p>jdb：debugger，Java 调试工具。</p>
<p>java：运行编译后的 Java 程序（.class后缀）</p>
<p>appletviewer：小程序浏览器，一种可运行在 HTML 文件上的 Java 小程序的 Java 浏览器。</p>
<p>Jconsole：Java 进行系统调试和监控工具。</p>
<h3 id="JDK-的基础类库"><a href="#JDK-的基础类库" class="headerlink" title="JDK 的基础类库"></a>JDK 的基础类库</h3><p>java.lang：基础类库，比如 String ，这个包是唯一不需要 import 关键字就可以使用的包。 </p>
<p>java.io：有关输入输出的类，比如对文件的操作。</p>
<p>java.nio：为了完善 io 包的功能，提高 io 包的性能而新增的包，比如 nio 非阻塞应用。</p>
<p>java.net：有关网络的类，比如 URI、URLConnection等。</p>
<p>java.util：系统辅助类，特别是集合 Collection 、List、Map等。</p>
<p>java.sql：数据库操作相关类，Connection、Statement、ResultSet等。</p>
<p>javax.servlet：jsp、servlet 等所使用的类。</p>
<h3 id="Java-是解释执行，正确吗？"><a href="#Java-是解释执行，正确吗？" class="headerlink" title="Java 是解释执行，正确吗？"></a>Java 是解释执行，正确吗？</h3><p>这个说法不太正确，我们开发好的 Java 源代码，首先是经过 javac 编译成字节码（bytecode），然后在运行时，通过JVM（Java 虚拟机）内嵌的解释器将编译好的字节码转化成最终的机器码。但是常用的JVM 比如Oracle 提供的 Hotspot JVM，都提供了 JIT （Just-In-Time Compiler）即时编译器，JIT 能够在运行时将热点代码编译成机器码，这个过程成为“编译执行“而非“解释执行“。</p>
<blockquote>
<p>JIT（Just-In-Time）即时编译器，通常通过 javac 将程序源代码编译，转换成 java 字节码，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。为了提高执行速度，引入了 JIT 技术。</p>
<p>在运行时 JIT 会把翻译过的机器码保存起来，以备下次使用，因此从理论上来说，采用该 JIT 技术可以接近以前纯编译技术。</p>
</blockquote>
<p>我们通常把 Java 分为编译期和运行时。</p>
<p>这里说的 Java 的编译和 C/C++ 是有着不同的意义的，Javac 的编译，编译 Java 源码生成“.class”文件里面实际是字节码，而不是可以直接执行的机器码。Java 通过字节码和 Java 虚拟机（JVM）这种跨平台的抽象，屏蔽了操作系统和硬件的细节，这也是实现“一次编译，到处执行”的基础。</p>
<p>在运行时，JVM 会通过类加载器（Class-Loader）加载字节码，解释或者编译执行。就像我前面提到的，主流 Java 版本中，如 JDK 8 实际是解释和编译混合的一种模式，即所谓的混合模式（-Xmixed）。通常运行在 server 模式的 JVM，会进行上万次调用以收集足够的信息进行高效的编译，client 模式这个门限是 1500 次。Oracle Hotspot JVM 内置了两个不同的 JIT compiler，C1 对应前面说的 client 模式，适用于对于启动速度敏感的应用，比如普通 Java 桌面应用；C2 对应 server 模式，它的优化是为长时间运行的服务器端应用设计的。默认是采用所谓的分层编译（TieredCompilation）。</p>
<p>除了我们日常最常见的 Java 使用模式，其实还有一种新的编译方式，即所谓的 AOT（Ahead-of-Time Compilation），直接将字节码编译成机器代码，这样就避免了 JIT 预热等各方面的开销，比如 Oracle JDK 9 就引入了实验性的 AOT 特性，并且增加了新的 jaotc 工具。利用下面的命令把某个类或者某个模块编译成为 AOT 库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">jaotc --output libHelloWorld.so HelloWorld<span class="class">.<span class="keyword">class</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="title">jaotc</span> --<span class="title">output</span> <span class="title">libjava</span>.<span class="title">base</span>.<span class="title">so</span> --<span class="title">module</span> <span class="title">java</span>.<span class="title">base</span></span></span></pre></td></tr></table></figure>

<p>然后在启动时直接指定就可以了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">java -XX:AOTLibrary=./libHelloWorld.so,./libjava.base.so HelloWorld</span></pre></td></tr></table></figure>

<p>而且，Oracle JDK 支持分层编译和 AOT 协作使用，这两者并不是二选一的关系。如果你有兴趣，可以参考相关文档：<a href="http://openjdk.java.net/jeps/295" target="_blank" rel="noopener">http://openjdk.java.net/jeps/295</a>。AOT 也不仅仅是只有这一种方式，业界早就有第三方工具（如 GCJ、Excelsior JET）提供相关功能。</p>
<h2 id="精彩评论"><a href="#精彩评论" class="headerlink" title="精彩评论"></a>精彩评论</h2><blockquote>
<p>Woj</p>
<p>“一次编译、到处运行”说的是Java语言跨平台的特性，Java的跨平台特性与Java虚拟机的存在密不可分，可在不同的环境中运行。比如说Windows平台和Linux平台都有相应的JDK，安装好JDK后也就有了Java语言的运行环境。其实Java语言本身与其他的编程语言没有特别大的差异，并不是说Java语言可以跨平台，而是在不同的平台都有可以让Java语言运行的环境而已，所以才有了Java一次编译，到处运行这样的效果。<br>严格的讲，跨平台的语言不止Java一种，但Java是较为成熟的一种。“一次编译，到处运行”这种效果跟编译器有关。编程语言的处理需要编译器和解释器。Java虚拟机和DOS类似，相当于一个供程序运行的平台。<br>程序从源代码到运行的三个阶段：编码——编译——运行——调试。Java在编译阶段则体现了跨平台的特点。编译过程大概是这样的：首先是将Java源代码转化成.CLASS文件字节码，这是第一次编译。.class文件就是可以到处运行的文件。然后Java字节码会被转化为目标机器代码，这是是由JVM来执行的，即Java的第二次编译。<br>“到处运行”的关键和前提就是JVM。因为在第二次编译中JVM起着关键作用。在可以运行Java虚拟机的地方都内含着一个JVM操作系统。从而使JAVA提供了各种不同平台上的虚拟机制，因此实现了“到处运行”的效果。需要强调的一点是，java并不是编译机制，而是解释机制。Java字节码的设计充分考虑了JIT这一即时编译方式，可以将字节码直接转化成高性能的本地机器码，这同样是虚拟机的一个构成部分。</p>
<p>一叶追寻</p>
<p>对Java平台的理解，首先想到的是Java的一些特性，比如平台无关性、面向对象、GC机制等，然后会在这几个方面去回答。平台无关性依赖于JVM，将.class文件解释为适用于操作系统的机器码。面向对象则会从封装、继承、多态这些特性去解释，具体内容就不在评论里赘述了。另外Java的内存回收机制，则涉及到Java的内存结构，堆、栈、方法区等，然后围绕什么样的对象可以回收以及回收的执行。以上是我对本道题的理解，不足之处还请杨老师指出，希望通过这次学习能把Java系统的总结一下~</p>
<p>三军</p>
<p>Java特性: </p>
<ol>
<li><p>面向对象（封装，继承，多态）</p>
</li>
<li><p>平台无关性（JVM运行.class文件)</p>
</li>
<li><p>语言（泛型，Lambda）</p>
</li>
<li><p>类库（集合，并发，网络，IO/NIO）</p>
</li>
<li><p>JRE（Java运行环境，JVM，类库）</p>
</li>
<li><p>JDK（Java开发工具，包括JRE，javac，诊断工具）</p>
</li>
</ol>
<p>Java是解析运行吗？  不正确！</p>
<ol>
<li><p>Java源代码经过Javac编译成.class文件</p>
</li>
<li><p>.class文件经JVM解析或编译运行。</p>
<p>（1）解析:.class文件经过JVM内嵌的解析器解析执行。</p>
<p>（2）编译:存在JIT编译器（Just In Time Compile 即时编译器）把经常运行的代码作为”热点代码”编译与本地平台相关的机器码，并进行各种层次的优化。</p>
<p>（3） AOT编译器: Java 9提供的直接将所有代码编译成机器码执行。</p>
</li>
</ol>
<p>jack：Java平台包括java语言，class文件结构，jvm，api类库，第三方库，各种编译、监控和诊断工具等。<br>Java语言是一种面向对象的高级语言；通过平台中立的class文件格式和屏蔽底层硬件差异的jvm实现‘一次编写，到处运行’；<br>通过‘垃圾收集器’管理内存的分配和回收。<br>jvm通过使用class文件这种中间表示和具体语言解耦，使得任何在源码早期编译过程中以class文件为中间表示或者<br>能够转换成class文件的具体语言，都能运行jvm之上，也就可以使用jvm的各种特性。<br>api类库主要包含集合、IO/NIO、网络、并发等。<br>第三方库包括各种商业机构和开源社区的java库，如spring、mybatis等。<br>各种工具如javac、jconsole、jmap、jstack等。</p>
<p>杨文奇： 解释器是把代码一行一行解释为二进制指令，编译器是把代码一次性编译为二进制指令，对JAVA语言来说，在执行阶段区分编译和解释，但对C语言来说，在执行阶段是直接执行二进制指令，不存在编译和解释，不知道理解对吗？</p>
<p>作者回复：嗯，c语言直接编译为机器码，并不存在虚拟机，不存在Java的部分概念</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/03/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mofei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫非的技术笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/03/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">如何设计一个秒杀系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-03 00:00:00" itemprop="dateCreated datePublished" datetime="2019-03-03T00:00:00+08:00">2019-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-10 19:50:03" itemprop="dateModified" datetime="2019-12-10T19:50:03+08:00">2019-12-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">技术架构</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>专栏《如何设计一个秒杀系统-许令波》学习笔记</p>
<p>秒杀特点：稳、准、快</p>
<p>重点围绕：并发读 和 并发写；</p>
<p>并发读核心优化理念：尽量减少用户到服务端来“读”数据；并发写的原则类似，要求将数据层独立出来，特殊处理。另外还需要兜底方案。</p>
</blockquote>
<h1 id="01-设计秒杀系统应注意的5个架构原则？"><a href="#01-设计秒杀系统应注意的5个架构原则？" class="headerlink" title="01|设计秒杀系统应注意的5个架构原则？"></a>01|设计秒杀系统应注意的5个架构原则？</h1><p><strong>数据要尽量少</strong> </p>
<p>用户请求数据尽量少，请求和响应都需要时间，服务器在写网络通常要做压缩和编码很好 CPU，所以尽量让秒杀界面简洁实用。</p>
<p><strong>请求数量尽量少</strong></p>
<p>主要包括图片、JavaScript、CSS等，脚本合并成一个文件，在 URL 中用逗号隔开（服务端需要组件来解析该URL，然后将这些动态文件合并起来一并返回。）</p>
<p><strong>路径要尽量短</strong></p>
<p>所谓“路径”，就是用户发出请求到返回数据这个过程中，需求经过的中间的节点数。（不要转来转去）</p>
<p><strong>依赖要尽量少</strong></p>
<p>所谓依赖，指的是要完成一次用户请求必须依赖的系统或者服务，这里的依赖指的是强依赖。</p>
<p>例子：秒杀商品页面依赖商品详情信息、用户信息、优惠卷诸如此类的；</p>
<p><strong>不要有单点</strong></p>
<p>单点意味着没有备份，分布式系统重要的原则就是消除单点。</p>
<h1 id="02-如何做好动静分离？有哪些方案可选？"><a href="#02-如何做好动静分离？有哪些方案可选？" class="headerlink" title="02|如何做好动静分离？有哪些方案可选？"></a>02|如何做好动静分离？有哪些方案可选？</h1><p>动静分离，区分出秒杀网页中的动态数据（每个人看到都不一样）和静态数据（每个人看到都一样）。</p>
<p>对静态数据做缓存处理，自然就能提高访问效率。</p>
<h2 id="静态数据如何做缓存？"><a href="#静态数据如何做缓存？" class="headerlink" title="静态数据如何做缓存？"></a>静态数据如何做缓存？</h2><ul>
<li><p><strong>将静态数据缓存到离用户最近的地方</strong>。常见有三种：服务端Cache、浏览器、CDN。</p>
</li>
<li><p><strong>静态化改造就是直接缓存 HTTP 连接。</strong>静态化改造是直接缓存 HTTP 连接而不是仅仅缓存数据，如下图所示，Web 代理服务器根据请求 URL，直接取出对应的 HTTP 响应头和响应体然后直接返回，这个响应过程简单得连 HTTP 协议都不用重新组装，甚至连 HTTP 请求头也不需要解析。</p>
</li>
</ul>
<p><img src="/2019/03/03/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/缓存HTTP连接.jpg" alt="缓存HTTP连接"></p>
<ul>
<li><strong>谁来做静态数据缓存。</strong>直接在 Web 服务器层上做（Nginx、Apache、Varnish）更擅长处理大并发的静态文件请求。</li>
</ul>
<h2 id="如何做动静分离改造？"><a href="#如何做动静分离改造？" class="headerlink" title="如何做动静分离改造？"></a>如何做动静分离改造？</h2><ul>
<li><p>URL 唯一化。商品详情系统天然地就可以做到 URL 唯一化，比如每个商品都由 ID 来标识，那么 <a href="http://item.xxx.com/item.htm?id=xxxx" target="_blank" rel="noopener">http://item.xxx.com/item.htm?id=xxxx</a> 就可以作为唯一的 URL 标识。为啥要 URL 唯一呢？前面说了我们是要缓存整个 HTTP 连接，那么以什么作为 Key 呢？就以 URL 作为缓存的 Key，例如以 id=xxx 这个格式进行区分。</p>
</li>
<li><p>分离浏览者相关的因素，浏览者相关的因素包括是否已登录，以及登录身份等，这些相关因素我们可以单独拆分出来，通过动态请求来获取。</p>
</li>
<li><p>分离时间因素。服务端输出的时间也通过动态请求获取。</p>
</li>
<li><p>异步化地域因素。详情页面上与地域相关的因素做成异步方式获取，当然你也可以通过动态请求方式获取，只是这里通过异步获取更合适。</p>
</li>
<li><p>去掉 Cookie。服务端输出的页面包含的 Cookie 可以通过代码软件来删除，如 Web 服务器 Varnish 可以通过 unset req.http.cookie 命令去掉 Cookie。注意，这里说的去掉 Cookie 并不是用户端收到的页面就不含 Cookie 了，而是说，在缓存的静态数据中不含有 Cookie。</p>
</li>
</ul>
<blockquote>
<p>分离出动态内容之后，如何组织这些内容页就变得非常关键了。这里我要提醒你一点，因为这其中很多动态内容都会被页面中的其他模块用到，如判断该用户是否已登录、用户 ID 是否匹配等，所以这个时候我们应该将这些信息 JSON 化（用 JSON 格式组织这些数据），以方便前端获取。</p>
</blockquote>
<p><strong>动态内容处理方案：</strong></p>
<ol>
<li><p><a href="https://baike.baidu.com/item/ESI/42448?fr=aladdin" target="_blank" rel="noopener">ESI</a>（Edge Side Includes）即在 Web 代理服务器上做动态内容请求，将请求内容插入到静态页面中；</p>
</li>
<li><p>CSI（Client Side Include）即单独发起一个异步 JavaScript 请求，向服务端获取动态内容。</p>
</li>
</ol>
<h1 id="03-二八原则：有正对性地处理好系统的“热点数据”"><a href="#03-二八原则：有正对性地处理好系统的“热点数据”" class="headerlink" title="03|二八原则：有正对性地处理好系统的“热点数据”"></a>03|二八原则：有正对性地处理好系统的“热点数据”</h1><p>用户在购物网站执行的一系列操作都可以抽象为“读请求”和“写请求”，而写请求瓶颈一般都在存储层。</p>
<p>热点数据又分为：静态热点数据 和 动态热点数据。</p>
<h2 id="如何发现热点数据"><a href="#如何发现热点数据" class="headerlink" title="如何发现热点数据"></a>如何发现热点数据</h2><p><strong>发现静态热点数据</strong>，有两种方式，其一，是通过卖家报名，通过运营系统把参加活动商品标识出来，然后通过后台系统对热点商品进行预热处理，比如提前缓存。其二，利用技术手段统计出买家访问的商品进行大数据统计分析，统计出 TOP N的商品，就可以认为是热点商品。</p>
<p><strong>发现动态热点数据</strong>，前面两种方式实时性太差。想办法构建几个动态热点发现系统。</p>
<blockquote>
<p>构建一个异步的系统，它可以收集交易链路上各个环节中的中间件产品的热点 Key，如 Nginx、缓存、RPC 服务框架等这些中间件（一些中间件产品本身已经有热点统计模块）。</p>
<p>建立一个热点上报和可以按照需求订阅的热点服务的下发规范，主要目的是通过交易链路上各个系统（包括详情、购物车、交易、优惠、库存、物流等）访问的时间差，把上游已经发现的热点透传给下游系统，提前做好保护。比如，对于大促高峰期，详情系统是最早知道的，在统一接入层上 Nginx 模块统计的热点 URL。</p>
<p>将上游系统收集的热点数据发送到热点服务台，然后下游系统（如交易系统）就会知道哪些商品会被频繁调用，然后做热点保护。</p>
<p>这里我给出了一个图，其中用户访问商品时经过的路径有很多，我们主要是依赖前面的导购页面（包括首页、搜索页面、商品详情、购物车等）提前识别哪些商品的访问量高，通过这些系统中的中间件来收集热点数据，并记录到日志中。</p>
<p><img src="/2019/03/03/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/\构建动态热点发现系统.jpg" alt="img\构建动态热点发现系统"></p>
<h2 id="处理热点数据"><a href="#处理热点数据" class="headerlink" title="处理热点数据"></a>处理热点数据</h2><p>处理热点数据思路：一优化，二限制，三隔离</p>
<p>优化：指的是将热点数据放在缓存中。</p>
<p>限制：对访问商品的ID 做一致性 Hash，然后根据 Hash 做分桶，每个分桶设置一个处理队列，吧热点商品限制在请求队列里，防止因某些热点商品占用太多的服务器资源，从而使其他请求始终得到服务器的处理资源。</p>
<p>隔离：隔离的原则是不要让 1% 的请求影响到其他 99%，对这 1% 做针对性优化。</p>
</blockquote>
<h1 id="04-流量削峰这事应该怎么做？"><a href="#04-流量削峰这事应该怎么做？" class="headerlink" title="04|流量削峰这事应该怎么做？"></a>04|流量削峰这事应该怎么做？</h1><h2 id="为什么要削峰？"><a href="#为什么要削峰？" class="headerlink" title="为什么要削峰？"></a>为什么要削峰？</h2><p>这个问题就好比交通限行限号是一个道理。</p>
<p>对于互联网系统引入削峰手段第，一、可以保证服务器处理变得更加平稳。二、可以节省服务器的资源成本。本质上来讲削峰更多的 是延缓用户发出的请求，以便减少或过滤掉一些无效请求，遵循“<strong>请求数量尽量少</strong>”的原则。</p>
<h2 id="削峰的操作思路？"><a href="#削峰的操作思路？" class="headerlink" title="削峰的操作思路？"></a>削峰的操作思路？</h2><p>无损方案：排队、答题、分层过滤（无损，即不会损失用户发出的请求）</p>
<p>有损方案：限流、机器负载保护等一些强制措施。</p>
<h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h3><p>排队的方式：</p>
<p>一、利用线程池加锁等待。</p>
<p>二、先进先出、先进后出等常用内存排序算法。</p>
<p>三、把请求序列化到文件中，然后在顺序地读文件来恢复请求。</p>
<p>四、利用消息队列方式。</p>
<p>最通用的解决方案，用消息队列缓冲流量的方案。这就好比在河道中修一座大坝留几个出口来泄洪，但洪水持续过大终究还是会被压垮的。把同步的直接调用转换成异步的间接推送，中间通过一个队列在一端承接瞬时的洪峰流量，在另一端平滑地将消息推送出去。</p>
<p><img src="/2019/03/03/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/削峰-消息队列缓冲流量.jpg" alt="img\削峰-消息队列缓冲流量"></p>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a>答题</h3><p>答题的两个目的：一、防止秒杀器作弊。二、延缓请求，起到对请求流量削峰的作用。</p>
<p>秒杀答题思路如下图：</p>
<p><img src="/2019/03/03/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/秒杀答题思路.jpg" alt="img\秒杀答题思路"></p>
<p>秒杀答题的主要逻辑：</p>
<ol>
<li><p>题库生成模块。生成一个个问题和答案</p>
</li>
<li><p>题库推送模块。将题目提前推送给详情系统和交易系统。推送主要是保证用户请求的题目是唯一的。</p>
</li>
<li><p>题库图片生成模块。网络拥挤是，应该把图片提前推送至 CDN 并进行预热处理。</p>
</li>
</ol>
<p>问题和答案用如下的 key 进行 MD5 加密：</p>
<p>问题 key：userId + itemId + questionId + time  + PK</p>
<p>答案 key：userId + itemId + answer + PK</p>
<p>答题的验证逻辑：</p>
<p><img src="/2019/03/03/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/答题的验证逻辑.jpg" alt="img\答题的验证逻辑"></p>
<p>注意：这里的逻辑，除了验证问题答案外还包括用户身份验证。</p>
<p>除了答题的正确性验证，还可以对提交答案时间做限制。</p>
<h3 id="分层过滤"><a href="#分层过滤" class="headerlink" title="分层过滤"></a>分层过滤</h3><p>分层过滤的核心思想：<strong>像漏斗一样在不同层次过滤掉无效请求，进入末端的请求才是有效的</strong>。</p>
<p>分层过滤的目的是过滤掉一些无效请求。</p>
<p><img src="/2019/03/03/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/如何设计一个秒杀系统\分层过滤.jpg" alt="img\分层过滤"></p>
<ul>
<li><p>CDN 层：拦截大部分数据的读取。</p>
</li>
<li><p>前台系统层的数据（包括强一致性的数据）尽量走 Cache ，过滤一些无效请求。</p>
</li>
<li><p>后台系统层：主要执行数据的二次校验，对系统做好保护和限流，减少数据量和请求。</p>
</li>
<li><p>DB 层：完成数据的强一致性校验。</p>
</li>
</ul>
<h3 id="分层过滤的基本原则"><a href="#分层过滤的基本原则" class="headerlink" title="分层过滤的基本原则"></a>分层过滤的基本原则</h3><ol>
<li><p>将动态请求的读数据缓存（Cache）在 Web 端，过滤掉无效的数据读。</p>
</li>
<li><p>对读数据不做强一致性校验，减少因为一致性校验产生瓶颈的问题。</p>
</li>
<li><p>对写数据进行基于时间的合理分片，过滤掉过期的失效请求。</p>
</li>
<li><p>对写请求做限流保护，将超出系统承载能力的请求过滤掉。</p>
</li>
<li><p>对写数据进行强一致性校验，只保留最后有效的数据。</p>
</li>
</ol>
<h1 id="05-影响性能的因素？该如何提高系统的性能？"><a href="#05-影响性能的因素？该如何提高系统的性能？" class="headerlink" title="05|影响性能的因素？该如何提高系统的性能？"></a>05|影响性能的因素？该如何提高系统的性能？</h1><blockquote>
<p>IOPS （Input/Output Operations Per Second，每秒读写操作次数 ）</p>
<p>QPS （Query Per Second，每秒请求数）</p>
<p>RT（Response Time，响应时间）</p>
</blockquote>
<p>QPS 一般用来衡量一个系统服务端性能，还有一个影响和 QPS 息息相关， RT 可理解为服务器处理响应耗时。</p>
<p>正常情况下 RT（响应时间） 越短，一秒处理请求数（QPS）自然就越多，这在单线程处理的情况下看起来是线性的关系，即我们自要把每个请求的响应时间降到最低，那么性能就会最高。</p>
<h2 id="响应时间对-QPS-的影响"><a href="#响应时间对-QPS-的影响" class="headerlink" title="响应时间对 QPS 的影响"></a>响应时间对 QPS 的影响</h2><p>响应时间一般是由 CPU 执行时间和线程等待时间（RPC、IO等待、Sleep、Wait等）组成，即服务器在处理每一个请求时，一部分事 CPU 本身在做运算，还有一部分是在等待。</p>
<p>真正对性能有影响的是 CPU 的执行时间，应致力于减少 CPU 的执行时间。</p>
<h2 id="线程数对-QPS-的影响"><a href="#线程数对-QPS-的影响" class="headerlink" title="线程数对 QPS 的影响"></a>线程数对 QPS 的影响</h2><p>线程越多的系统，线程的切换成本越高，而且线程也会消耗一定内存。</p>
<p>线程场景默认配置，<strong>线程数= 2 * CPU 核数 + 1</strong>，除此配置外，最佳实践得来公式</p>
<p><code>线程数 = [(线程等待时间 + 线程 CPU 时间)  / 线程CPU时间] * CPU 数量</code></p>
<p>最好是通过性能测试来发现最佳的线程数。</p>
<p>要想显著的提升性能我们要减少 CPU 的执行时间，除此之外还需要设置一个合理的并发线程数。</p>
<h2 id="如何发现瓶颈？"><a href="#如何发现瓶颈？" class="headerlink" title="如何发现瓶颈？"></a>如何发现瓶颈？</h2><p>服务器出现瓶颈的地方：CPU、内存、磁盘、网络。</p>
<p>万物相生相克，缓存系统——内存；存储型系统——I/O</p>
<h3 id="有那些工具可发现-CPU-瓶颈呢？"><a href="#有那些工具可发现-CPU-瓶颈呢？" class="headerlink" title="有那些工具可发现 CPU 瓶颈呢？"></a>有那些工具可发现 CPU 瓶颈呢？</h3><p>JProfiler 和 Yourkit，就可以列出整个请求中每个函数的 CPU 执行时间，还可以发现那个函数消耗的 CPU 时间最多。</p>
<p>对于海量请求涌过来，页面又大，网络也可能出现瓶颈。</p>
<h3 id="如何判断-CPU-是不是瓶颈呢？"><a href="#如何判断-CPU-是不是瓶颈呢？" class="headerlink" title="如何判断 CPU 是不是瓶颈呢？"></a>如何判断 CPU 是不是瓶颈呢？</h3><p>看 QPS 达到极限时，服务器 CPU 使用率是否超过 95% ，如果草果，那表示 CPU 还有提升空间，要么有锁限制，要么有本地 I/O 等待发生。</p>
<h2 id="如何优化系统？"><a href="#如何优化系统？" class="headerlink" title="如何优化系统？"></a>如何优化系统？</h2><p>1、减少编码</p>
<p> Java 的编码运行比较慢，这是 Java 的一大硬伤。在很多场景下，只要涉及字符串的操作（如输入输出操作、I/O 操作）都比较耗 CPU 资源，不管它是磁盘 I/O 还是网络 I/O，因为都需要将字符转换成字节，而这个转换必须编码。</p>
<p>每个字符的编码都需要查表，而这种查表的操作非常耗资源，所以减少字符到字节或者相反的转换、减少字符编码会非常有成效。减少编码就可以大大提升性能。</p>
<p>那么如何才能减少编码呢？例如，网页输出是可以直接进行流输出的，即用 resp.getOutputStream() 函数写数据，把一些静态的数据提前转化成字节，等到真正往外写的时候再直接用 OutputStream() 函数写，就可以减少静态数据的编码转换。</p>
<p>序列化大部分是在 RPC 中发生的，因此避免或者减少 RPC 就可以减少序列化，当然当前的序列化协议也已经做了很多优化来提升性能。有一种新的方案，就是可以将多个关联性比较强的应用进行“合并部署”，而减少不同应用之间的 RPC 也可以减少序列化的消耗。</p>
<p>2、减少序列化</p>
<p>序列化也是 Java 性能的一大天敌，减少 Java 中的序列化操作也能大大提升性能。又因为序列化往往是和编码同时发生的，所以减少序列化也就减少了编码。</p>
<p>3、Java极致优化</p>
<p>对Web 系统做静态化改造，让大部分请求和数据直接在 Nginx 服务器或则 Web代理服务器（Varnish、Squid）上直接返回，这样做的好处是减少数据的序列化和反序列化，让 Java 层处理少量的动态数据请求。</p>
<ul>
<li><p>直接使用 Servlet 处理请求。避免使用传统的 MVC 框架，这样可以绕过一大堆复杂且用处不大的处理逻辑，节省 1ms 时间（具体取决于你对 MVC 框架的依赖程度）。</p>
</li>
<li><p>直接输出流数据。使用 resp.getOutputStream() 而不是 resp.getWriter() 函数，可以省掉一些不变字符数据的编码，从而提升性能；数据输出时推荐使用 JSON 而不是模板引擎（一般都是解释执行）来输出页面。</p>
</li>
</ul>
<p>4、并发读优化</p>
<p>答案是采用应用层的 LocalCache，即在秒杀系统的单机上缓存商品相关的数据。</p>
<h1 id="06-秒杀系统”减库存”设计的核心逻辑？"><a href="#06-秒杀系统”减库存”设计的核心逻辑？" class="headerlink" title="06|秒杀系统”减库存”设计的核心逻辑？"></a>06|秒杀系统”减库存”设计的核心逻辑？</h1><h2 id="减库存有那几种方式？"><a href="#减库存有那几种方式？" class="headerlink" title="减库存有那几种方式？"></a>减库存有那几种方式？</h2><ul>
<li><p>下单减库存，即买家下单后，就去商品总库存中减去购买数量。一定不会出现超卖现象，但是买家不一定付款。</p>
</li>
<li><p>付款减库存，即买家下单付款后，才去商品总库存中减去购买数量，否则将库存一直保留给其他买家。如果并发很高，可能会导致买家付不了款，因为商品被其他买家买走了，又会导致库存超卖。</p>
</li>
<li><p>预扣库存，常见的减库存方式，买家下单后，库存将保持一段时间，超过时间，自动释放库存；释放后其他买家可继续购买。在买家付款前，系统会校验订单库存是否还有保留，如果没有保留，则再次尝试预扣；如果库存不足（预扣失败），则不允许继续付款；如果预扣成功，则完成付款并实际地减去库存。</p>
</li>
</ul>
<h3 id="如何避免恶意买家操作？"><a href="#如何避免恶意买家操作？" class="headerlink" title="如何避免恶意买家操作？"></a>如何避免恶意买家操作？</h3><p>打标，也就是要识别出那些是恶意买家，给某些类目设置最大购买数量、以及重复下单不付款的操作次数进行限制。</p>
<p><strong>“超卖”</strong>现象仍旧会发生，只能通过补货；或者买家付款时提示库存不足。</p>
<h3 id="秒杀场景如何减库存？"><a href="#秒杀场景如何减库存？" class="headerlink" title="秒杀场景如何减库存？"></a>秒杀场景如何减库存？</h3><p>秒杀，即秒到即赚到，应该采用“<strong>下单减库存</strong>”方案。</p>
<p>“<strong>下单减库存</strong>”主要解决的问题是，保证大并发请求时库存数据不能为负数，常见的解决方案如下：</p>
<p>一、应用程序中通过事务来判断，即保证减库存后不能为负数，否则就回滚事务；</p>
<p>二、直接将数据库的字段数据为无符号整数，只要减库存字段值小于零时运行SQL 语句来报错；</p>
<p>三、利用 CASE WHEN 判断语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> item <span class="keyword">SET</span> inventory = <span class="keyword">CASE</span> <span class="keyword">WHEN</span> inventory &gt;= xxx <span class="keyword">THEN</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">inventory - xxx <span class="keyword">ELSE</span> inventory <span class="keyword">END</span></span></pre></td></tr></table></figure>

<h2 id="秒杀库存的极致优化"><a href="#秒杀库存的极致优化" class="headerlink" title="秒杀库存的极致优化"></a>秒杀库存的极致优化</h2><p>提升读性能：库存，作为关键数据和热点数据，秒杀场景并不需要对库存有精确性的一致性读，把库存数据放到缓存（Cache）；</p>
<p>解决打并发读问题：采用 LocalCahe（即秒杀系统的单机上缓存商品相关数据）和对数据进行分层过滤方式。无论如何也无法避免大并发减库存操作。</p>
<h3 id="如何在缓存中减库存和数据库中减库存？"><a href="#如何在缓存中减库存和数据库中减库存？" class="headerlink" title="如何在缓存中减库存和数据库中减库存？"></a>如何在缓存中减库存和数据库中减库存？</h3><blockquote>
<p>如果你的秒杀商品的减库存逻辑非常单一，比如没有复杂的 SKU 库存和总库存这种联动关系的话，我觉得完全可以放在缓存中减库存。但是如果有比较复杂的减库存逻辑，或者需要使用事务，你还是必须在数据库中完成减库存。</p>
<p>由于 MySQL 存储数据的特点，同一数据在数据库里肯定是一行存储（MySQL），因此会有大量线程来竞争 InnoDB 行锁，而并发度越高时等待线程会越多，TPS（Transaction Per Second，即每秒处理的消息数）会下降，响应时间（RT）会上升，数据库的吞吐量就会严重受影响。</p>
<p>这就可能引发一个问题，就是单个热点商品会影响整个数据库的性能， 导致 0.01% 的商品影响 99.99% 的商品的售卖，这是我们不愿意看到的情况。一个解决思路是遵循前面介绍的原则进行隔离，把热点商品放到单独的热点库中。但是这无疑会带来维护上的麻烦，比如要做热点数据的动态迁移以及单独的数据库等。</p>
<p>而分离热点商品到单独的数据库还是没有解决并发锁的问题，我们应该怎么办呢？要解决并发锁的问题，有两种办法：</p>
<ul>
<li><p>应用层做排队，按照商品维度设置队列顺序，能减少同一台机器对数据同一行进行操作的并发度，同时也能控制单个商品占用数据库连接数量，防止热点商品占用太多的数据库连接。</p>
</li>
<li><p>数据库分层做排队，应用层只能做到单机的排队，但是应用机器数本身很多，这种排队方式控制并发的能力仍然有限，所以如果能在数据库层做全局排队是最理想的。阿里的数据库团队开发了针对这种 MySQL 的 InnoDB 层上的补丁程序（patch），可以在数据库层上对单行记录做到并发排队。</p>
</li>
</ul>
</blockquote>
<h1 id="07-准备Plan-B：如何设计兜底方案？"><a href="#07-准备Plan-B：如何设计兜底方案？" class="headerlink" title="07|准备Plan B：如何设计兜底方案？"></a>07|准备Plan B：如何设计兜底方案？</h1><p>任何一个系统都需要“反脆弱”。</p>
<h2 id="高可用系统建设"><a href="#高可用系统建设" class="headerlink" title="高可用系统建设"></a>高可用系统建设</h2><p><img src="/2019/03/03/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/如何设计一个秒杀系统\高可用系统全生命周期.jpg" alt="img\高可用系统全生命周期"></p>
<blockquote>
<ul>
<li><p>架构阶段：架构阶段主要考虑系统的可扩展性和容错性，要避免系统出现单点问题。例如多机房单元化部署，即使某个城市的某个机房出现整体故障，仍然不会影响整体网站的运转。</p>
</li>
<li><p>编码阶段：编码最重要的是保证代码的健壮性，例如涉及远程调用问题时，要设置合理的超时退出机制，防止被其他系统拖垮，也要对调用的返回结果集有预期，防止返回的结果超出程序处理范围，最常见的做法就是对错误异常进行捕获，对无法预料的错误要有默认处理结果。</p>
</li>
<li><p>测试阶段：测试主要是保证测试用例的覆盖度，保证最坏情况发生时，我们也有相应的处理流程。</p>
</li>
<li><p>发布阶段：发布时也有一些地方需要注意，因为发布时最容易出现错误，因此要有紧急的回滚机制。</p>
</li>
<li><p>运行阶段：运行时是系统的常态，系统大部分时间都会处于运行态，运行态最重要的是对系统的监控要准确及时，发现问题能够准确报警并且报警数据要准确详细，以便于排查问题。</p>
</li>
<li><p>故障发生：故障发生时首先最重要的就是及时止损，例如由于程序问题导致商品价格错误，那就要及时下架商品或者关闭购买链接，防止造成重大资产损失。然后就是要能够及时恢复服务，并定位原因解决问题。</p>
</li>
</ul>
</blockquote>
<h3 id="如何保障系统稳定运行"><a href="#如何保障系统稳定运行" class="headerlink" title="如何保障系统稳定运行"></a>如何保障系统稳定运行</h3><p>那么针对秒杀系统，我们重点介绍在遇到大流量时，应该从哪些方面来保障系统的稳定运行，所以更多的是看如何针对运行阶段进行处理，这就引出了接下来的内容：降级、限流和拒绝服务。</p>
<h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><p>当系统的容量达到一定程度时，限制或者关闭系统的某些非核心功能，从而把有限的资源保留给更核心的业务。</p>
<p>它是一个有目的、有计划的执行过程，所以对降级我们一般需要有一套预案来配合执行。如果我们把它系统化，就可以通过预案系统和开关系统来实现降级。</p>
<p><img src="/2019/03/03/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/如何设计一个秒杀系统\开关系统.jpg" alt="img\开关系统"></p>
<h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><p>限流就是当系统容量达到瓶颈时，我们需要通过限制一部分流量来保护系统，并做到既可以人工执行开关，也支持自动化保护的措施。</p>
<ul>
<li><p>客户端限流，好处可以限制请求的发出，通过减少发出无用请求从而减少对系统的消耗。缺点就是当客户端比较分散时，没法设置合理的限流阈值：如果阈值设的太小，会导致服务端没有达到瓶颈时客户端已经被限制；而如果设的太大，则起不到限制的作用。</p>
</li>
<li><p>服务端限流：好处是可以根据服务端的性能设置合理的阈值，而缺点就是被限制的请求都是无效的请求，处理这些无效的请求本身也会消耗服务器资源。</p>
</li>
</ul>
<p><img src="/2019/03/03/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/如何设计一个秒杀系统\限流.jpg" alt="img\限流"></p>
<h4 id="拒绝服务"><a href="#拒绝服务" class="headerlink" title="拒绝服务"></a>拒绝服务</h4><p>实在招架不住，也就只能拒绝服务了。</p>
<p>当系统负载达到一定阈值时，例如 CPU 使用率达到 90% 或者系统 load 值达到 2*CPU 核数时，系统直接拒绝所有请求，这种方式是最暴力但也最有效的系统保护方式。例如秒杀系统，我们在如下几个环节设计过载保护：</p>
<blockquote>
<p>在最前端的 Nginx 上设置过载保护，当机器负载达到某个值时直接拒绝 HTTP 请求并返回 503 错误码，在 Java 层同样也可以设计过载保护。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/22/krpano%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mofei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="莫非的技术笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/22/krpano%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">krpano 配置文件（三）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-22 21:24:08" itemprop="dateCreated datePublished" datetime="2019-02-22T21:24:08+08:00">2019-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-10 19:44:46" itemprop="dateModified" datetime="2019-12-10T19:44:46+08:00">2019-12-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">前端笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="krpano-XML"><a href="#krpano-XML" class="headerlink" title="krpano XML"></a>krpano XML</h1><blockquote>
<p>krpano 使用xml 文件来存储 krpano 的设置。任何文本编辑器都能进行编辑，但需要遵守标准的 xml 语法规则。</p>
<p><a href="https://krpano.com/docu/xml/#top" target="_blank" rel="noopener">krpano XML 文档</a></p>
<p>我将此文件称为“主配置文件”。因为它是整个全景程序运行的核心文件，充当着关键数据存储库，krpano 运行时将 xml 元素节点数取出存入运行时数据结构，此文件存放在根目录中。</p>
<p>此文件默认名称<code>tour.xml</code>，文件名称取决于在<code>vtour-normal.config</code> 配置文件中的定义</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># xml output</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">xml=true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">xmlpath=%INPUTPATH%/vtour/tour.xml</span></pre></td></tr></table></figure>
</blockquote>
<h1 id="krpano-xml-文件结构"><a href="#krpano-xml-文件结构" class="headerlink" title="krpano xml 文件结构"></a>krpano xml 文件结构</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;krpano&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &lt;include&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    &lt;preview&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &lt;image&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &lt;view&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &lt;area&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &lt;display&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &lt;control&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &lt;cursors&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &lt;autorotate&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &lt;plugin&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &lt;layer&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &lt;hotspot&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &lt;style&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &lt;events&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &lt;action&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &lt;contextmenu&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &lt;network&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &lt;memory&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &lt;security&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &lt;textstyle&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &lt;lensflareset&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    &lt;lensflare&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &lt;<span class="keyword">data</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &lt;scene&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    &lt;set&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    &lt;debug&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">&lt;/krpano&gt;</span></pre></td></tr></table></figure>



<p>文件结构详细信息移步至<a href="官方文档">官方文档</a>，这里着重介绍几点：</p>
<ol>
<li><p>krpano 作为文件根节点，其他节点必须包含在内。</p>
</li>
<li><p>krpano 中的所有子节点是可选项，完全一样的节点定义多个会被后面的覆盖。</p>
</li>
<li><p>krpano 根节点中还可以包含krpano 节点。 </p>
</li>
</ol>
<h1 id="节点介绍"><a href="#节点介绍" class="headerlink" title="节点介绍"></a>节点介绍</h1><p>关于节点属性请点击表格中标签移步<a href="https://krpano.com/docu/xml/" target="_blank" rel="noopener">官方文档</a>浏览</p>
<table>
<thead>
<tr>
<th><a href="https://krpano.com/docu/xml/#include" target="_blank" rel="noopener">include</a></th>
<th>包含其他 xml 文件，建议将所有包含外部节点放在根节点首行。</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://krpano.com/docu/xml/#preview" target="_blank" rel="noopener">preview</a></td>
<td>全景图像预览图，一般包含在<scene>节点中。</scene></td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#image" target="_blank" rel="noopener">image</a></td>
<td>定义全景图像</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#view" target="_blank" rel="noopener">view</a></td>
<td>视图，可配置视野位置、水平、垂直方向、缩放限制。</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#area" target="_blank" rel="noopener">area</a></td>
<td>定义应显示全景图像的区域/窗口</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#display" target="_blank" rel="noopener">display</a></td>
<td>配置显示模式和渲染质量以及性能</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#control" target="_blank" rel="noopener">control</a></td>
<td>鼠标键盘控制</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#cursors" target="_blank" rel="noopener">cursors</a></td>
<td>鼠标光标样式</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#autorotate" target="_blank" rel="noopener">autorotate</a></td>
<td>自动旋转，没有用户交互的情况下开启总动旋转。</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#plugin" target="_blank" rel="noopener">plugin</a></td>
<td>引入外部插件</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#layer" target="_blank" rel="noopener">layer</a></td>
<td>用来定义图片、容器、文本</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#hotspot" target="_blank" rel="noopener">hotspot</a></td>
<td>热点，对鼠标悬停或点击做交互。可支持多边形</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#style" target="_blank" rel="noopener">style</a></td>
<td>定义通用样式</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#events" target="_blank" rel="noopener">events</a></td>
<td>用于在特定事件发生时调用动作或函数。分全局事件和独立本地事件。</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#action" target="_blank" rel="noopener">action</a></td>
<td>定义动作，</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#contextmenu" target="_blank" rel="noopener">contextmenu</a></td>
<td>自定义鼠标右键菜单</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#network" target="_blank" rel="noopener">network</a></td>
<td>网络设置，显示错误消息之前加载（服务器）错误的自动下载重试次数。</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#memory" target="_blank" rel="noopener">memory</a></td>
<td>内存使用设置，HTML5：桌面150-400MB，手机：75MB</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#security" target="_blank" rel="noopener">security</a></td>
<td>跨域安全设置</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#textstyle" target="_blank" rel="noopener">textstyle</a></td>
<td>文本样式。不再推荐使用。</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#lensflareset" target="_blank" rel="noopener">lensflareset</a></td>
<td>镜头光晕设置，仅限Flash</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#data" target="_blank" rel="noopener">data</a></td>
<td>原始数据，可存储任何类型的信息或数据。krpano不会解析其内容</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#scene" target="_blank" rel="noopener">scene</a></td>
<td>场景</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#set" target="_blank" rel="noopener">set</a></td>
<td>在 xml 解析期间设置/定义变量</td>
</tr>
<tr>
<td><a href="https://krpano.com/docu/xml/#debug" target="_blank" rel="noopener">debug</a></td>
<td>允许 xml 解析期间跟踪/记录某些内容。</td>
</tr>
<tr>
<td>skin_settings</td>
<td>允许自定义设置，包括皮肤、地图、导航、文本等等。</td>
</tr>
</tbody></table>
<h2 id="skin-settings-节点"><a href="#skin-settings-节点" class="headerlink" title="skin_settings 节点"></a>skin_settings 节点</h2><p>官方网站没有介绍此节点，但是在生成后的“主配置文件”中包含此节点，并给出注解。</p>
<p>此节点的主要作用就是允许你自定义任何类型的配置节点。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;!-- customize skin settings: maps, gyro, webvr, thumbnails, tooltips, layout, design, ... --&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">	&lt;skin_settings maps=<span class="string">"false"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	               maps_type=<span class="string">"google"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	               maps_bing_api_key=<span class="string">""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">	               maps_google_api_key=<span class="string">""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">	               maps_zoombuttons=<span class="string">"false"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	               gyro=<span class="string">"true"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">	               webvr=<span class="string">"true"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">	               webvr_gyro_keeplookingdirection=<span class="string">"false"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">	               webvr_prev_next_hotspots=<span class="string">"true"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">	               littleplanetintro=<span class="string">"true"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">	               title=<span class="string">"true"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">	               thumbs=<span class="string">"true"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">	               thumbs_width=<span class="string">"120"</span> thumbs_height=<span class="string">"80"</span> thumbs_padding=<span class="string">"10"</span> thumbs_crop=<span class="string">"0|40|240|160"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">	               thumbs_opened=<span class="string">"false"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">	               thumbs_text=<span class="string">"true"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">	               thumbs_dragging=<span class="string">"true"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">	               thumbs_onhoverscrolling=<span class="string">"false"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">	               thumbs_scrollbuttons=<span class="string">"false"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">	               thumbs_scrollindicator=<span class="string">"false"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">	               thumbs_loop=<span class="string">"false"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">	               tooltips_buttons=<span class="string">"false"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">	               tooltips_thumbs=<span class="string">"false"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">	               tooltips_hotspots=<span class="string">"false"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">	               tooltips_mapspots=<span class="string">"false"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">	               deeplinking=<span class="string">"false"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">	               loadscene_flags=<span class="string">"MERGE"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">	               loadscene_blend=<span class="string">"OPENBLEND(0.5, 0.0, 0.75, 0.05, linear)"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">	               loadscene_blend_prev=<span class="string">"SLIDEBLEND(0.5, 180, 0.75, linear)"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">	               loadscene_blend_next=<span class="string">"SLIDEBLEND(0.5,   0, 0.75, linear)"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">	               loadingtext=<span class="string">"加载中..."</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">	               layout_width=<span class="string">"100%"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">	               layout_maxwidth=<span class="string">"814"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">	               controlbar_width=<span class="string">"-24"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">	               controlbar_height=<span class="string">"40"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">				   scene_select_text=<span class="string">"场景选择"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">	               controlbar_offset=<span class="string">"20"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">	               controlbar_offset_closed=<span class="string">"-40"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">	               controlbar_overlap.no-fractionalscaling=<span class="string">"10"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">	               controlbar_overlap.fractionalscaling=<span class="string">"0"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">	               design_skin_images=<span class="string">"vtourskin.png"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">	               design_bgcolor=<span class="string">"0x2D3E50"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">	               design_bgalpha=<span class="string">"0.8"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">	               design_bgborder=<span class="string">"0"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">	               design_bgroundedge=<span class="string">"1"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">	               design_bgshadow=<span class="string">"0 4 10 0x000000 0.3"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">	               design_thumbborder_bgborder=<span class="string">"3 0xFFFFFF 1.0"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">	               design_thumbborder_padding=<span class="string">"2"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">	               design_thumbborder_bgroundedge=<span class="string">"0"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">	               design_text_css=<span class="string">"color:#FFFFFF; font-family:Arial;"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">	               design_text_shadow=<span class="string">"1"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">	               /&gt;</span></pre></td></tr></table></figure>

<p>此节点中的自定义属性，可以在其他 xml 配置文件中获取。获取方式如下：<code>get:variable</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;layer name=<span class="string">"skin_btn_thumbs_text"</span> type=<span class="string">"text"</span> align=<span class="string">"center"</span> x=<span class="string">"50"</span> y=<span class="string">"10"</span> html=<span class="string">"get:skin_settings.controlbar_scene_select_text"</span>  bg=<span class="string">"false"</span> /&gt;</span></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>下一章节介绍下动作和脚本还有样式，回顾本章掌握 krpano xml 配置文件结构及其用途，关键节点上属性及作用官网文档有更好的说明就不再赘述。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">mofei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mofei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.1.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
